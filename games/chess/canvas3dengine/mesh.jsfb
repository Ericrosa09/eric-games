/*
 * javascript/canvas textured 3d renderer v0.3.1
 * copyright (c) 2008 jacob seidelin, cupboy@gmail.com
 * this software is free to use for non-commercial purposes. for anything else, please contact the author.
 * this is a version modified by stefano gioffre'.
 */

canvas3d.mesh = function() {

	this._oposition = new canvas3d.vec3(0,0,0);
	this._orotation = new canvas3d.vec3(0,0,0);

	this._avertices = []; // vertex positions in object space
	this._aglobalvertices = []; // vertices translated to global space
	this._afaces = [];
	this._anormals = [];
	this._amaterials = [];

	this._bdirty = true;

	this._bvisible = true;

	this._iforcedz = -1;
	this._bhidewhenrotating = false;

	this._odefaultcolor = {r:155,g:155,b:155};
	this._odefaultmaterial = {};
	this._isize = 1;

	this._fscale = 1;

	this._bfill = true;		// render filled triangles
	this._bwire = false;		// render wireframe
	this._bshading = true;		// shade/light filled triangles
	this._bbackfacecull = true;	// only draw triangles facing the camera
	this._bzsort = true;		// sort triangles back-to-front
	this._bexpandclippath = true;	// expand clip path by 1px, to minimize gaps

	this._btexture = false;		// render textured triangles (must enable bfill as well)
	this._btextureshading = false;	// render shading on textured triangles (must enable bshading as well)

	// sometimes the exported normals from max are messed up, or they're imported wrong or whatever, i don't know.
	// we can recalculate them after loading.
	this._bcalcnormals = true;

	// only allow textures if canvas is available
	var ocanvas = document.createelement("canvas");
	this._bcantexture = false;	
	this._bcantextureuv = false;	
	if (ocanvas.getcontext && ocanvas.getcontext("2d")) {
		this._bcantexture = true;
		if (ocanvas.getcontext("2d").getimagedata) {
			this._bcantextureuv = true;
		}
	}

};

// parse the mesh data
// the mesh data (vertices, faces, texture coordinates, materials) are read from a json object structure
// and copied into local arrays
// normals are recalculated, if enabled.
canvas3d.mesh.prototype.setmeshdata = function(omeshdata, oscene) {
	this._omeshdata = omeshdata;

	this._avertices = [];
	this._afaces = [];
	this._anormals = [];
	this._amaterials = [];

	var opos = this._oposition;

	var me = this;

	if (this._omeshdata.mat) {
		for (var m=0;m<this._omeshdata.mat.length;m++) {
			var omat = this._omeshdata.mat[m];
			omat.idx = m;
			if (omat.t) {
				omat.image = new image();
				if (omat.uv && this._bcantextureuv) {
					omat.image.mat = omat;
					omat.image.onload = function() {
						me._baketexture(this.mat);
						if (oscene) {
							oscene.setdirty(true);
						}
						this.onload = null;
					}
				}
				omat.image.src = "textures/" + omat.t;
			}
			this._amaterials.push(omat);
		}
	}

	for (var o=0;o<this._omeshdata.obj.length;o++) {

		var oobject = this._omeshdata.obj[o];
		var avertices = oobject.vrt;
		var atexcoords = oobject.tex;

		this._atexcoords = atexcoords;

		var ivertoffset = this._avertices.length;

		var ftotalx = 0;
		var ftotaly = 0;
		var ftotalz = 0;

		var inumvertices = avertices.length;

		for (var v=0;v<inumvertices;v++) {
			var overtex = new canvas3d.vec3(
					avertices[v][0],
					avertices[v][1],
					avertices[v][2]
			);

			this._avertices.push(overtex);

			this._aglobalvertices.push(
				new canvas3d.vec3(
					overtex.x + opos.x,
					overtex.y + opos.y,
					overtex.z + opos.z
				)
			);

			ftotalx += overtex.x;
			ftotaly += overtex.y;
			ftotalz += overtex.z;
		}

		var favgx = ftotalx / inumvertices;
		var favgy = ftotaly / inumvertices;
		var favgz = ftotalz / inumvertices;

		var olocalcenter = new canvas3d.vec3(favgx, favgy, favgz);

		var afaces = oobject.fac;
		for (var f=0;f<afaces.length;f++) {
			var oface = afaces[f];

			var opoint1 = this._aglobalvertices[oface[0] + ivertoffset];
			var opoint2 = this._aglobalvertices[oface[1] + ivertoffset];
			var opoint3 = this._aglobalvertices[oface[2] + ivertoffset];

			var ocenter = new canvas3d.vec3(
				(opoint1.x + opoint2.x + opoint3.x) / 3,
				(opoint1.y + opoint2.y + opoint3.y) / 3,
				(opoint1.z + opoint2.z + opoint3.z) / 3
			);

			var onormal = new canvas3d.vec3(
					oobject.nrm[f][0],
					oobject.nrm[f][1],
					oobject.nrm[f][2]
			);

			var oface = {
					a : oface[0] + ivertoffset,
					b : oface[1] + ivertoffset,
					c : oface[2] + ivertoffset,
					normal : onormal,
					center : ocenter,
					mat : oface[3],
					idx : f,
					lights : []
			}

			this._afaces.push(oface);
		}

		if (this._bcalcnormals) {
			this._recalcnormals();
		}
	}
}

// here we prepare the texture for easy rendering.
// for each face, a triangular region is drawn onto a canvas containing the image data for that face
// we draw a triangular section on the destination canvas containing the corresponding pixel data from the source texture,
// using the uv coords to retrieve the correct pixels
// that way, we have all texture parts rotated and scaled into a common form, so they can easily be drawn later
// at the moment, the data is read with getimagedata and is rather slow, but it should be possible do to sort of the reverse process
// of the drawtexturetriangle transform to draw these texture parts.
canvas3d.mesh.prototype._baketexture = function(omat) {

	var f = this._afaces.length;

	var atexfaces = [];
	// find all face that need this texture
	do {
		var oface = this._afaces[f-1];
		if (oface.mat == omat.idx) {
			atexfaces.push(oface);
			oface.texidx = atexfaces.length-1;
		}
	} while (--f)

	f = atexfaces.length;
	if (f < 1) {
		return;
	}

	var fc = atexfaces.length;

	var itexres = omat.res;
	var itexwidth = itexres * f + f*2;
	var itexheight = itexres + 2;

	var isrcwidth = omat.w;
	var isrcheight = omat.h;

	// create canvas for source texture image and paint the texture on it
	var osource = document.createelement("canvas");
	osource.width = isrcwidth;
	osource.height = isrcheight;
	osource.style.width = isrcwidth+"px";
	osource.style.height = isrcheight+"px";
	var osrcctx = osource.getcontext("2d");
	osrcctx.drawimage(omat.image, 0, 0, isrcwidth, isrcheight);
	var osrcdataobj = osrcctx.getimagedata(0, 0, isrcwidth, isrcheight);
	var asrcdata = osrcdataobj.data;

	// create canvas for finished face textures.
	var otexcanvas = document.createelement("canvas");
	otexcanvas.width = itexwidth;
	otexcanvas.height = itexheight;
	otexcanvas.style.width = itexwidth+"px";
	otexcanvas.style.height = (itexheight)+"px";
	otexcanvas.style.backgroundcolor = "rgb(255,0,255)";
	otexcanvas.resolution = itexres;
	var odstctx = otexcanvas.getcontext("2d");
	odstctx.fillstyle = "rgb(255,0,255)";
	odstctx.fillrect(0,0,itexwidth,itexheight);

	var odstdataobj = odstctx.getimagedata(0, 0, itexwidth, itexheight);
	var adstdata = odstdataobj.data;

	var ocontext = otexcanvas.getcontext("2d");

	//uncomment to see how the texture is prepared
	//document.body.appendchild(osource);
	//document.body.appendchild(otexcanvas);

	var itexoffsetx = itexres;

	do {
		var oface = atexfaces[f-1];

		var ocoords = this._atexcoords[oface.idx];

		var otexpoint1 = ocoords[1];
		var otexpoint2 = ocoords[2];
		var otexpoint3 = ocoords[0];

		var x1 = otexpoint1[0] * isrcwidth;
		var y1 = (1 - otexpoint1[1]) * isrcheight;
		var x3 = otexpoint2[0] * isrcwidth;
		var y3 = (1 - otexpoint2[1]) * isrcheight;
		var x2 = otexpoint3[0] * isrcwidth;
		var y2 = (1 - otexpoint3[1]) * isrcheight;

		var funitax = (x2 - x1);
		var funitay = (y2 - y1);

		var funitbx = (x3 - x2);
		var funitby = (y3 - y2);

		var ioffsetx = 0;

		var idstxoffset = (itexwidth - itexoffsetx - (fc-f)*2-2);

		// we paint the triangular texture with a 1px margin on each side and let the texture spill over into this margin.
		// this is to prevent small transparent gaps to appear between the triangles when they are rotated and scaled into place during rendering.

		var y = itexres+2;
		do {
			var idsty = itexres+2-y;
			var fstepy = (itexres+1-y) / itexres;

			var fstepyunitbx = fstepy*funitbx;
			var fstepyunitby = fstepy*funitby;

			var idstyoffset = idsty*itexwidth*4;

			var x = itexres+2 - ioffsetx;
			do {
				var idstx = x + idstxoffset - 1;
				var fstepx = (x-1 + ioffsetx) / itexres;
	
				var isrcx = math.floor(x1 + fstepx*funitax + fstepyunitbx);
				var isrcy = math.floor(y1 + fstepx*funitay + fstepyunitby);

				if (isrcx < 0) isrcx = 0;
				if (isrcy < 0) isrcy = 0;

				if (isrcx >= isrcwidth) isrcx = isrcwidth-1;
				if (isrcy >= isrcheight) isrcy = isrcheight-1;

				var idstpixoffset = idstyoffset + idstx*4;
				var isrcpixoffset = (isrcy*isrcwidth + isrcx)*4;
	
				adstdata[idstpixoffset] = asrcdata[isrcpixoffset];
				adstdata[idstpixoffset+1] = asrcdata[isrcpixoffset+1];
				adstdata[idstpixoffset+2] = asrcdata[isrcpixoffset+2];

				adstdata[idstpixoffset+3] = omat.texalpha ? asrcdata[isrcpixoffset+3] : 255;

			} while (--x);

			ioffsetx++;
			idstxoffset++;

		} while (--y);

		itexoffsetx += itexres;

	} while (--f);

	odstctx.putimagedata(odstdataobj, 0, 0);
	odstctx.fillrect(0,0,0,0); // opera doesn't update until we draw something?
	omat.facecanvas = otexcanvas;
}

var fnczsort = function(a, b) {
	return a.transcenter.z - b.transcenter.z;
}

// math and misc shortcuts
var sin = math.sin;
var cos = math.cos;
var asin = math.asin;
var acos = math.acos;
var pow = math.pow;
var sqrt = math.sqrt;

var fraddeg = 180 / math.pi;
var fdegrad = math.pi / 180;
var fdegrad45 = fdegrad*45;
var fdegrad90 = fdegrad*90;
var fdegrad180 = fdegrad*180;
var fsqrt2div2 = sqrt(2) / 2;

// this functions draws a textured (and shaded) triangle on the canvas
// this is done by rotating/scaling a triangular section in place, setting up a clipping path and drawing the image.
// if uv coords are enabled, only the correct part of the triangle-strip texture is drawn
// if not, the entire texture is drawn for each face
// some of the code used for skewing the image was inspired by the as function found here:
// http://www.senocular.com/flash/actionscript.php?file=actionscript_1.0/prototypes/movieclip/skew.as

canvas3d.mesh.prototype._drawtexturetriangle = function(ocontext, omat, opoint1, opoint2, opoint3, ioffsetx, ioffsety, fshade, onormal, iidx) {
	if (!omat.image) {
		return;
	}
	if (!omat.image.complete) {
		return;
	}

	var omatimage = omat.image;

	if (!omatimage.canvas) {
		// first time around, we paint the texture image to a canvas
		// drawing the triangle later on is slightly faster using another canvas object rather than an image object
		// this should be moved to someplace else

		var itexwidth = 50;
		var itexheight = 50;

		var otexturecanvas = document.createelement("canvas");

		otexturecanvas.width = itexwidth;
		otexturecanvas.height = itexheight;

		otexturecanvas.style.width = itexwidth + "px";
		otexturecanvas.style.height = itexheight + "px";

		var otexctx = otexturecanvas.getcontext("2d");
		otexctx.drawimage(omatimage, 0, 0, itexwidth, itexheight);

		omatimage.canvas = otexturecanvas;
	}

	var x1 = opoint1.x;
	var y1 = opoint1.y;
	var x2 = opoint2.x;
	var y2 = opoint2.y;
	var x3 = opoint3.x;
	var y3 = opoint3.y;

	// trig to calc the angle we need to rotate in order get our texturetriangle in place
	var dx = x3 - x2;
	var dy = y3 - y2;
	var a = sqrt((dx*dx + dy*dy));

	dx = x3 - x1;
	dy = y3 - y1;
	var b = sqrt((dx*dx + dy*dy));

	dx = x2 - x1;
	dy = y2 - y1;
	var c = sqrt((dx*dx + dy*dy));

	var aa = a*a, bb = b*b, cc = c*c;

	var fcosb = (aa + cc - bb) / (2*a*c);
	var fangleb = acos(fcosb);
	if (isnan(fangleb)) return;

	var fcosc = (aa + bb - cc) / (2*a*b);
	var fanglec = acos(fcosc);
	if (isnan(fanglec)) return;

	if ((fangleb + fanglec) == 0) return;

	var fskewx = -(fdegrad90 - (fangleb + fanglec));

	var ftrirotation = -(asin((y2 - y1) / c));

	if (x2 > x1) { // rotate the other way around if triangle is flipped
		ftrirotation = fdegrad180 - ftrirotation;
	}

	if (fskewx == fdegrad90) fskewx = fdegrad*89.99;
	if (fskewx == -fdegrad90) fskewx = -fdegrad*89.99;

	var fcosx = cos(fskewx);

	var frotation = fdegrad45 + fskewx * 0.5;

	var fdiv = 1 / (sin(frotation) * fsqrt2div2);

	var fscalex = fcosx * fdiv;
	var fscaley = (sin(fskewx) + 1) * fdiv;

	// setup the clipping path, so only texture within the triangle is drawn.
	var iclipx1 = x1 + ioffsetx;
	var iclipy1 = y1 + ioffsety;

	var iclipx2 = x2 + ioffsetx;
	var iclipy2 = y2 + ioffsety;

	var iclipx3 = x3 + ioffsetx;
	var iclipy3 = y3 + ioffsety;

	// here we try to expand the clip path by 1 pixel to get rid of (some of the) gaps between the triangles
	// we do this simply by moving the topmost point 1px up, the leftmost point 1px left, and so on.
	// later, we also render the triangle itself 1 px too big
	// drawbacks are that the contour of the object will appear a bit "pointy".
	if (this._bexpandclippath && false) {
		if (iclipy1 < iclipy2 && iclipy1 < iclipy3)
			iclipy1--;
		else if (iclipy2 < iclipy1 && iclipy2 < iclipy3)
			iclipy2--;
		else if (iclipy3 < iclipy1 && iclipy3 < iclipy2)
			iclipy3--;

		if (iclipy1 > iclipy2 && iclipy1 > iclipy3)
			iclipy1++;
		else if (iclipy2 > iclipy1 && iclipy2 > iclipy3)
			iclipy2++;
		else if (iclipy3 > iclipy1 && iclipy3 > iclipy2)
			iclipy3++;

		if (iclipx1 < iclipx2 && iclipx1 < iclipx3)
			iclipx1--;
		else if (iclipx2 < iclipx1 && iclipx2 < iclipx3)
			iclipx2--;
		else if (iclipx3 < iclipx1 && iclipx3 < iclipx2)
			iclipx3--;

		if (iclipx1 > iclipx2 && iclipx1 > iclipx3)
			iclipx1++;
		else if (iclipx2 > iclipx1 && iclipx2 > iclipx3)
			iclipx2++;
		else if (iclipx3 > iclipx1 && iclipx3 > iclipx2)
			iclipx3++;
	}

	ocontext.save();

	// do the clip path
	ocontext.beginpath();
	ocontext.moveto(iclipx1, iclipy1);
	ocontext.lineto(iclipx2, iclipy2);
	ocontext.lineto(iclipx3, iclipy3);
	ocontext.closepath();
	ocontext.clip();

	// setup the skew/rotation transformation
	ocontext.translate(x2 + ioffsetx, y2 + ioffsety);
	ocontext.rotate(frotation + ftrirotation);
	ocontext.scale(fscalex, fscaley);
	ocontext.rotate(-fdegrad45);

	var ftriscalex = c / 2; // 100 * 50;
	var ftriscaley = b / 2; // 100 * 50;

	if (omat.uv) {
		// we are using uv coordinates for texturing
		if (this._bcantextureuv && omat.facecanvas) {
			var itexres = omat.facecanvas.resolution;
			// draw our texture
			// there will be a small gap between the triangles. drawing the texture at offset (-1,-1)  gets rid of some of it.
			ocontext.drawimage(
				omat.facecanvas,
				iidx * itexres + iidx*2+1, 1, itexres, itexres,
				-1, -1,
				ftriscalex + 2,
				ftriscaley + 2
			);
		}
	} else {
		// no uv, just draw the same texture for all faces
		ocontext.drawimage(
			omatimage.canvas,
			-1, -1,
			ftriscalex + 2,
			ftriscaley + 2
		);
	}

	ocontext.restore();

	// if shading is turned on, render a semi-transparent black triangle on top.
	// that means that a fully lit triangle will just be the raw texture, and the less lit a triangle is, the darker it gets.
	// we could render semi-transparent white on top to make it brighter, but it doesn't look right, so we settle for that.
	if (this._btextureshading && fshade > 0) {
		ocontext.beginpath();
		ocontext.moveto(iclipx1, iclipy1);
		ocontext.lineto(iclipx2, iclipy2);
		ocontext.lineto(iclipx3, iclipy3);
		ocontext.closepath();
	
		ocontext.fillstyle = "rgba(0,0,0," + (fshade*0.5) + ")";
		ocontext.fill();
	}
}

// draw the mesh on the ocontext canvas context, at offset [ioffsetx, ioffsety]
canvas3d.mesh.prototype.draw = function(ocontext, ioffsetx, ioffsety) {
	if (!this._bvisible) return;

	var oscene = this._oscene;

	var ocam = oscene.getactivecamera();
	var oambient = oscene.getambientlight()

	// if shading is enabled, calculate the direction vectors to all light sources
	var blightdirty = false;
	if (this._bshading && this._bfill) {
		var alights = oscene.getlights();
		var alightdirections = [];
		for (var l=0;l<alights.length;l++) {
			// todo: this should be position relative to mesh
			var olightpos = alights[l].getposition();
			var olightdirection = olightpos.unit();
			alightdirections.push(olightdirection);

			if (alights[l].getdirty())
				blightdirty = true;
		}
	}

	var avertices = this._aglobalvertices;
	var afaces = this._afaces;

	if (avertices.length < 3 || afaces.length < 1) {
		// nothing to draw
		return;
	}

	// let the camera transform all vertices and project them to 2d.
	var apoints2d = [];
	var atransvertices = [];
	var v = avertices.length;
	do {
		var overtex = avertices[v-1];

		var ovec = ocam.transformpoint(overtex);
		atransvertices[v-1] = ovec;

		var opoint2d = ocam.project(ovec);
		apoints2d[v-1] = opoint2d;
	} while (--v);

	var asortedfaces;

	// if the faces are filled, we need to do z-sorting
	if (this._bfill && this._bzsort) {
		var f = afaces.length;
		do {
			var oface = afaces[f-1];
			oface.transcenter = ocam.transformpoint(oface.center);
		} while (--f);

		asortedfaces = afaces.sort(fnczsort);

	// if not, just use the raw list
	} else {

		asortedfaces = afaces;
	}

	f = asortedfaces.length;
	if (f < 1) {
		return;
	}

	// run through all faces
	do {
		var oface = asortedfaces[f-1];

		var opoint1 = apoints2d[oface.a];
		var opoint2 = apoints2d[oface.b];
		var opoint3 = apoints2d[oface.c];

		var onormal = oface.normal;

		var bdraw = false;

		// do backface culling in screen space
		if (this._bbackfacecull) {
			// screen space backface culling adapted from http://www.kirupa.com/developer/actionscript/backface_culling.htm
			if (((opoint3.y-opoint1.y)/(opoint3.x-opoint1.x) - (opoint2.y-opoint1.y)/(opoint2.x-opoint1.x) <= 0) ^ (opoint1.x <= opoint3.x == opoint1.x > opoint2.x)){
     				bdraw = true;
			}
		} else {
			bdraw = true;
		}

		if (ocam.clip(atransvertices[oface.a]) || ocam.clip(atransvertices[oface.b]) || ocam.clip(atransvertices[oface.c])) {
			bdraw = false;
		}

		
		// if triangle is facing camera, draw it
		if (bdraw) {

			// get the material for this face
			var ofacemat = this._amaterials[oface.mat];
			if (ofacemat) {
				ofacecolor = ofacemat;
			} else {
				ofacemat = this._odefaultmaterial;
				ofacecolor = this._odefaultcolor;
			}
			var bfacetexture = this._btexture && ofacemat.t;

			// save the original color
			var ofaceorgcolor = {r:ofacecolor.r, g:ofacecolor.g, b:ofacecolor.b};

			var flight = 0;
			var fshade = 1;

			if (this._bfill) {
				// setup ambient face color
				if (!bfacetexture) {
					if (blightdirty || this._bdirty) {
						var ofacecoloramb = {
							r:(oambient.r / 255) * ofacecolor.r,
							g:(oambient.g / 255) * ofacecolor.g,
							b:(oambient.b / 255) * ofacecolor.b
						};
					}
				}

				// do lighting
				if (this._bshading) {
					if (blightdirty || this._bdirty) {
						for (var l=0;l<alights.length;l++) {

							var olightpos = alights[l].getposition();
							var olightdir = new canvas3d.vec3(
								olightpos.x - oface.center.x,
								olightpos.y - oface.center.y,
								olightpos.z - oface.center.z
							).unit();

							var fdot = -olightdir.dot(onormal);

							// is the face facing the light source
							if (fdot > 0) {
								//fdot = math.sqrt(fdot);
								flight = fdot * alights[l].getintensity();
								fshade = fshade - flight;

								// lighten the face by the light intensity
								if (!bfacetexture) {
									ofacecoloramb = {
										r: ofacecoloramb.r + ofacecolor.r * flight,
										g: ofacecoloramb.g + ofacecolor.g * flight,
										b: ofacecoloramb.b + ofacecolor.b * flight
									};
								}
							}
						}

						ofacecoloramb.r = math.floor(ofacecoloramb.r);
						ofacecoloramb.g = math.floor(ofacecoloramb.g);
						ofacecoloramb.b = math.floor(ofacecoloramb.b);

						if (ofacecoloramb.r < 0) ofacecoloramb.r = 0;
						if (ofacecoloramb.g < 0) ofacecoloramb.g = 0;
						if (ofacecoloramb.b < 0) ofacecoloramb.b = 0;

						if (ofacecoloramb.r > 255) ofacecoloramb.r = 255;
						if (ofacecoloramb.g > 255) ofacecoloramb.g = 255;
						if (ofacecoloramb.b > 255) ofacecoloramb.b = 255;

						oface.calccolor = ofacecoloramb;
						oface.shade = fshade;
					}
					ofacecoloramb = oface.calccolor;
					fshade = oface.shade;
				}
				if (!bfacetexture) {
					ofacecolor = ofacecoloramb;
				}
			}

			ocontext.beginpath();
			ocontext.moveto(opoint1.x + ioffsetx, opoint1.y + ioffsety);
			ocontext.lineto(opoint2.x + ioffsetx, opoint2.y + ioffsety)
			ocontext.lineto(opoint3.x + ioffsetx, opoint3.y + ioffsety)
			ocontext.closepath();

			if (this._bfill) {
				if (this._bcantexture && this._btexture && ofacemat.image) {
					this._drawtexturetriangle(ocontext, ofacemat, opoint1, opoint2, opoint3, ioffsetx, ioffsety, fshade, onormal, oface.texidx);
				} else {
					ocontext.fillstyle = "rgb(" + ofacecolor.r + "," + ofacecolor.g + "," + ofacecolor.b + ")";
					ocontext.fill();
					if (!this._bwire) {
						ocontext.linewidth = 0.7;
						ocontext.strokestyle = "rgb(" + ofacecolor.r + "," + ofacecolor.g + "," + ofacecolor.b + ")";
						ocontext.stroke();
					}
				}
			}

			if (this._bwire) {
				ofaceorgcolor.r = math.min(math.max(math.round(ofaceorgcolor.r),0),255);
				ofaceorgcolor.g = math.min(math.max(math.round(ofaceorgcolor.g),0),255);
				ofaceorgcolor.b = math.min(math.max(math.round(ofaceorgcolor.b),0),255);

				ocontext.linewidth = 1;
				ocontext.strokestyle = "rgb(" + ofaceorgcolor.r + "," + ofaceorgcolor.g + "," + ofaceorgcolor.b + ")";
				ocontext.stroke();
			}

		}
	} while (--f);
	this._bdirty = false;
}

canvas3d.mesh.prototype.setscene = function(oscene) {
	if (this._oscene != oscene) {
		this._oscene = oscene;
	}
}

canvas3d.mesh.prototype.setlighting = function(benable) {
	this._bshading = benable;
}

canvas3d.mesh.prototype.setbackfacecull = function(benable) {
	this._bbackfacecull = benable;
}

canvas3d.mesh.prototype.setzsort = function(benable) {
	this._bzsort = benable;
}

canvas3d.mesh.prototype.setfill = function(benable) {
	this._bfill = benable;
}

canvas3d.mesh.prototype.setwire = function(benable) {
	this._bwire = benable;
}

canvas3d.mesh.prototype.settexture = function(benable) {
	this._btexture = benable;
}

canvas3d.mesh.prototype.settextureshading = function(benable) {
	this._btextureshading = benable;
}

canvas3d.mesh.prototype._updateglobalvertices = function() {
	var orot = this._orotation;
	var opos = this._oposition;

	for (var i = 0; i < this._avertices.length; i++) {
		var orotatedvertex = new canvas3d.vec3(
			this._avertices[i].x,
			this._avertices[i].y,
			this._avertices[i].z
		);

		if (orot.x)
			orotatedvertex.rotatex(orot.x);
		if (orot.y)
			orotatedvertex.rotatey(orot.y);
		if (orot.z)
			orotatedvertex.rotatez(orot.z);

		this._aglobalvertices[i].x = orotatedvertex.x * this._fscale + opos.x;
		this._aglobalvertices[i].y = orotatedvertex.y * this._fscale + opos.y;
		this._aglobalvertices[i].z = orotatedvertex.z * this._fscale + opos.z;
	}

	this._recalcnormals();
}

canvas3d.mesh.prototype._recalcnormals = function() {
	for (var f = 0; f < this._afaces.length; f++) {
		var oface = this._afaces[f];

		var opoint1 = this._aglobalvertices[oface.a];
		var opoint2 = this._aglobalvertices[oface.b];
		var opoint3 = this._aglobalvertices[oface.c];

		var ocenter = new canvas3d.vec3(
			(opoint1.x + opoint2.x + opoint3.x) / 3,
			(opoint1.y + opoint2.y + opoint3.y) / 3,
			(opoint1.z + opoint2.z + opoint3.z) / 3
		);

		oface.center = ocenter;

		var onormal = new canvas3d.vec3(
			((opoint1.y - opoint2.y) * (opoint1.z - opoint3.z)) - ((opoint1.z - opoint2.z) * (opoint1.y - opoint3.y)),
			((opoint1.z - opoint2.z) * (opoint1.x - opoint3.x)) - ((opoint1.x - opoint2.x) * (opoint1.z - opoint3.z)),
			((opoint1.x - opoint2.x) * (opoint1.y - opoint3.y)) - ((opoint1.y - opoint2.y) * (opoint1.x - opoint3.x))
		).unit();
		oface.normal = onormal;
	}
}

canvas3d.mesh.prototype.setposition = function(ovec) {
	if (ovec.x != this._oposition.x || ovec.y != this._oposition.y || ovec.z != this._oposition.z) {
		this._oposition = ovec;
		this._updateglobalvertices();
		this._bdirty = true;
	}
}

canvas3d.mesh.prototype.setrotation = function(ovec) {
	this._orotation = ovec;
	this._updateglobalvertices();

	this._bdirty = true;

}

canvas3d.mesh.prototype.getposition = function(ovec) {
	return this._oposition;
}

canvas3d.mesh.prototype.setforcedz = function(iz) {
	this._iforcedz = iz;
}

canvas3d.mesh.prototype.getforcedz = function() {
	return this._iforcedz;
}

canvas3d.mesh.prototype.gethidewhenrotating = function() {
	return this._bhidewhenrotating;
}

canvas3d.mesh.prototype.sethidewhenrotating = function(benable) {
	this._bhidewhenrotating = benable;
}

canvas3d.mesh.prototype.getdirty = function() {
	return this._bdirty;
}

canvas3d.mesh.prototype.hide = function() {
	this._bvisible = false;
	this._bdirty = true;
}

canvas3d.mesh.prototype.show = function() {
	this._bvisible = true;
	this._bdirty = true;
}

canvas3d.mesh.prototype.isvisible = function() {
	return this._bvisible;
}

canvas3d.mesh.prototype.setscale = function(fscale) {
	this._fscale = fscale;
	this._bdirty = true;
	this._updateglobalvertices();
}

canvas3d.mesh.prototype.getscale = function() {
	return this._fscale;
}
