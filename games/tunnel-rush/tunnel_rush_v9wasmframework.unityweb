unityloader["2a4956e740b59b60b50e2d9d9e786bda"]=(function(module) {
module['prerun'].push(function (){
	// initialize the indexeddb based file system. module['unityfilesysteminit'] allows
	// developers to override this with their own function, when they want to do cloud storage 
	// instead.
	var unityfilesysteminit = module['unityfilesysteminit'] || function (){
		if (!module.indexeddb)
		{
			console.log('indexeddb is not available. data will not persist in cache and playerprefs will not be saved.');
		}
		fs.mkdir('/idbfs');
		fs.mount(idbfs, {}, '/idbfs');
		module.addrundependency('js_filesystem_mount');
		fs.syncfs(true, function (err) {
			module.removerundependency('js_filesystem_mount'); 
		});
	};	
	unityfilesysteminit();
});
module["setfullscreen"] = function (fullscreen) {
  if (typeof runtimeinitialized === 'undefined' || !runtimeinitialized) {
    console.log ("runtime not initialized yet.");
  } else if (typeof jsevents === 'undefined') {
    console.log ("player not loaded yet.");
  } else {
    var tmp = jsevents.canperformeventhandlerrequests;
    jsevents.canperformeventhandlerrequests = function () { return 1; };
    module.ccall("setfullscreen", null, ["number"], [fullscreen]);
    jsevents.canperformeventhandlerrequests = tmp;
  }
};
// the following code overrides the default emscripten instantiation of the webassembly module
// as a workaround for incorrectly initialized runtime object properties
// (module export is not available at launch time if the module is compiled asynchronously).
// this file should be removed as soon as this bug is fixed in emscripten.

integratewasmjs = function integratewasmjs(module) {
  // wasm.js has several methods for creating the compiled code module here:
  //  * 'native-wasm' : use native webassembly support in the browser
  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret
  //  * 'interpret-binary': load binary wasm and interpret
  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret
  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)
  // the method can be set at compile time (binaryen_method), or runtime by setting module['wasmjsmethod'].
  // the method can be a comma-separated list, in which case, we will try the
  // options one by one. some of them can fail gracefully, and then we can try
  // the next.

  // inputs

  var method = module['wasmjsmethod'] || 'native-wasm';
  module['wasmjsmethod'] = method;

  var wasmtextfile = module['wasmtextfile'] || 'build.wast';
  var wasmbinaryfile = module['wasmbinaryfile'] || 'build.wasm';
  var asmjscodefile = module['asmjscodefile'] || 'build.asm.js';

  // utilities

  var wasmpagesize = 64*1024;

  var asm2wasmimports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
      return x % y;
    },
    "f64-to-int": function(x) {
      return x | 0;
    },
    "i32s-div": function(x, y) {
      return ((x | 0) / (y | 0)) | 0;
    },
    "i32u-div": function(x, y) {
      return ((x >>> 0) / (y >>> 0)) >>> 0;
    },
    "i32s-rem": function(x, y) {
      return ((x | 0) % (y | 0)) | 0;
    },
    "i32u-rem": function(x, y) {
      return ((x >>> 0) % (y >>> 0)) >>> 0;
    },
    "debugger": function() {
      debugger;
    },
  };

  var info = {
    'global': null,
    'env': null,
    'asm2wasm': asm2wasmimports,
    'parent': module // module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.
  };

  var exports = null;

  function lookupimport(mod, base) {
    var lookup = info;
    if (mod.indexof('.') < 0) {
      lookup = (lookup || {})[mod];
    } else {
      var parts = mod.split('.');
      lookup = (lookup || {})[parts[0]];
      lookup = (lookup || {})[parts[1]];
    }
    if (base) {
      lookup = (lookup || {})[base];
    }
    if (lookup === undefined) {
      abort('bad lookupimport to (' + mod + ').' + base);
    }
    return lookup;
  }

  function mergememory(newbuffer) {
    // the wasm instance creates its memory. but static init code might have written to
    // buffer already, including the mem init file, and we must copy it over in a proper merge.
    // todo: avoid this copy, by avoiding such static init writes
    // todo: in shorter term, just copy up to the last static init write
    var oldbuffer = module['buffer'];
    if (newbuffer.bytelength < oldbuffer.bytelength) {
      module['printerr']('the new buffer in mergememory is smaller than the previous one. in native wasm, we should grow memory here');
    }
    var oldview = new int8array(oldbuffer);
    var newview = new int8array(newbuffer);

    // if we have a mem init file, do not trample it
    if (!memoryinitializer) {
      oldview.set(newview.subarray(module['static_base'], module['static_base'] + module['static_bump']), module['static_base']);
    }

    newview.set(oldview);
    updateglobalbuffer(newbuffer);
    updateglobalbufferviews();
  }

  var wasmtypes = {
    none: 0,
    i32: 1,
    i64: 2,
    f32: 3,
    f64: 4
  };

  function fiximports(imports) {
    if (!0) return imports;
    var ret = {};
    for (var i in imports) {
      var fixed = i;
      if (fixed[0] == '_') fixed = fixed.substr(1);
      ret[fixed] = imports[i];
    }
    return ret;
  }

  function getbinary() {
    var binary;
    if (environment_is_web || environment_is_worker) {
      binary = module['wasmbinary'];
      assert(binary, "on the web, we need the wasm binary to be preloaded and set on module['wasmbinary']. emcc.py will do that for you when generating html (but not js)");
      binary = new uint8array(binary);
    } else {
      binary = module['readbinary'](wasmbinaryfile);
    }
    return binary;
  }

  // do-method functions

  function dojustasm(global, env, providedbuffer) {
    // if no module.asm, or it's the method handler helper (see below), then apply
    // the asmjs
    if (typeof module['asm'] !== 'function' || module['asm'] === methodhandler) {
      if (!module['asmpreload']) {
        // you can load the .asm.js file before this, to avoid this sync xhr and eval
        eval(module['read'](asmjscodefile)); // set module.asm
      } else {
        module['asm'] = module['asmpreload'];
      }
    }
    if (typeof module['asm'] !== 'function') {
      module['printerr']('asm evalling did not set the module properly');
      return false;
    }
    return module['asm'](global, env, providedbuffer);
  }

  function donativewasm(global, env, providedbuffer) {
    if (typeof webassembly !== 'object') {
      module['printerr']('no native wasm support detected');
      return false;
    }
    // prepare memory import
    if (!(module['wasmmemory'] instanceof webassembly.memory)) {
      module['printerr']('no native wasm memory in use');
      return false;
    }
    env['memory'] = module['wasmmemory'];
    // load the wasm module and create an instance of using native support in the js engine.
    info['global'] = {
      'nan': nan,
      'infinity': infinity
    };
    info['global.math'] = global.math;
    info['env'] = env;
    // handle a generated wasm instance, receiving its exports and
    // performing other necessary setup
    function receiveinstance(instance) {
      exports = instance.exports;
      if (exports.memory) mergememory(exports.memory);
      module["usingwasm"] = true;
    }
    module['print']('asynchronously preparing wasm');
    addrundependency('wasm-instantiate'); // we can't run yet
    webassembly.instantiate(getbinary(), info).then(function(output) {
      receiveinstance(output.instance);
      asm = module['asm'] = exports; // swap in the exports so they can be called

      runtime.stackalloc = exports['stackalloc'];
      runtime.stacksave = exports['stacksave'];
      runtime.stackrestore = exports['stackrestore'];
      runtime.establishstackspace = exports['establishstackspace'];
      runtime.settempret0 = exports['settempret0'];
      runtime.gettempret0 = exports['gettempret0'];

      removerundependency('wasm-instantiate');
    });
    return {}; // no exports yet; we'll fill them in later
    var instance;
    try {
      instance = new webassembly.instance(new webassembly.module(getbinary()), info)
    } catch (e) {
      module['printerr']('failed to compile wasm module: ' + e);
      if (e.tostring().indexof('imported memory with incompatible size') >= 0) {
        module['printerr']('memory size incompatibility issues may be due to changing total_memory at runtime to something too large. use allow_memory_growth to allow any size memory (and also make sure not to set total_memory at runtime to something smaller than it was at compile time).');
      }
      return false;
    }
    receiveinstance(instance);
    return exports;
  }

  function dowasmpolyfill(global, env, providedbuffer, method) {
    if (typeof wasmjs !== 'function') {
      module['printerr']('wasmjs not detected - polyfill not bundled?');
      return false;
    }

    // use wasm.js to polyfill and execute code in a wasm interpreter.
    var wasmjs = wasmjs({});

    // xxx don't be confused. module here is in the outside program. wasmjs is the inner wasm-js.cpp.
    wasmjs['outside'] = module; // inside wasm-js.cpp, module['outside'] reaches the outside module.

    // information for the instance of the module.
    wasmjs['info'] = info;

    wasmjs['lookupimport'] = lookupimport;

    assert(providedbuffer === module['buffer']); // we should not even need to pass it as a 3rd arg for wasm, but that's the asm.js way.

    info.global = global;
    info.env = env;

    // polyfill interpreter expects an arraybuffer
    assert(providedbuffer === module['buffer']);
    env['memory'] = providedbuffer;
    assert(env['memory'] instanceof arraybuffer);

    wasmjs['providedtotalmemory'] = module['buffer'].bytelength;

    // prepare to generate wasm, using either asm2wasm or s-exprs
    var code;
    if (method === 'interpret-binary') {
      code = getbinary();
    } else {
      code = module['read'](method == 'interpret-asm2wasm' ? asmjscodefile : wasmtextfile);
    }
    var temp;
    if (method == 'interpret-asm2wasm') {
      temp = wasmjs['_malloc'](code.length + 1);
      wasmjs['writeasciitomemory'](code, temp);
      wasmjs['_load_asm2wasm'](temp);
    } else if (method === 'interpret-s-expr') {
      temp = wasmjs['_malloc'](code.length + 1);
      wasmjs['writeasciitomemory'](code, temp);
      wasmjs['_load_s_expr2wasm'](temp);
    } else if (method === 'interpret-binary') {
      temp = wasmjs['_malloc'](code.length);
      wasmjs['heapu8'].set(code, temp);
      wasmjs['_load_binary2wasm'](temp, code.length);
    } else {
      throw 'what? ' + method;
    }
    wasmjs['_free'](temp);

    wasmjs['_instantiate'](temp);

    if (module['newbuffer']) {
      mergememory(module['newbuffer']);
      module['newbuffer'] = null;
    }

    exports = wasmjs['asmexports'];

    return exports;
  }

  // we may have a preloaded value in module.asm, save it
  module['asmpreload'] = module['asm'];

  // memory growth integration code
  module['reallocbuffer'] = function(size) {
    size = math.ceil(size / wasmpagesize) * wasmpagesize; // round up to wasm page size
    var old = module['buffer'];
    var result = exports['__growwasmmemory'](size / wasmpagesize); // tiny wasm method that just does grow_memory
    if (module["usingwasm"]) {
      if (result !== (-1 | 0)) {
        // success in native wasm memory growth, get the buffer from the memory
        return module['buffer'] = module['wasmmemory'].buffer;
      } else {
        return null;
      }
    } else {
      // in interpreter, we replace module.buffer if we allocate
      return module['buffer'] !== old ? module['buffer'] : null; // if it was reallocated, it changed
    }
  };

  // provide an "asm.js function" for the application, called to "link" the asm.js module. we instantiate
  // the wasm module at that time, and it receives imports and provides exports and so forth, the app
  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.

  module['asm'] = function(global, env, providedbuffer) {
    global = fiximports(global);
    env = fiximports(env);

    // import table
    if (!env['table']) {
      var table_size = module['wasmtablesize'];
      if (table_size === undefined) table_size = 1024; // works in binaryen interpreter at least
      var max_table_size = module['wasmmaxtablesize'];
      if (typeof webassembly === 'object' && typeof webassembly.table === 'function') {
        if (max_table_size !== undefined) {
          env['table'] = new webassembly.table({ initial: table_size, maximum: max_table_size, element: 'anyfunc' });
        } else {
          env['table'] = new webassembly.table({ initial: table_size, element: 'anyfunc' });
        }
      } else {
        env['table'] = new array(table_size); // works in binaryen interpreter at least
      }
      module['wasmtable'] = env['table'];
    }

    if (!env['memorybase']) {
      env['memorybase'] = module['static_base']; // tell the memory segments where to place themselves
    }
    if (!env['tablebase']) {
      env['tablebase'] = 0; // table starts at 0 by default, in dynamic linking this will change
    }

    // try the methods. each should return the exports if it succeeded

    var exports;
    var methods = method.split(',');

    for (var i = 0; i < methods.length; i++) {
      var curr = methods[i];

      module['print']('trying binaryen method: ' + curr);

      if (curr === 'native-wasm') {
        if (exports = donativewasm(global, env, providedbuffer)) break;
      } else if (curr === 'asmjs') {
        if (exports = dojustasm(global, env, providedbuffer)) break;
      } else if (curr === 'interpret-asm2wasm' || curr === 'interpret-s-expr' || curr === 'interpret-binary') {
        if (exports = dowasmpolyfill(global, env, providedbuffer, curr)) break;
      } else {
        throw 'bad method: ' + curr;
      }
    }

    if (!exports) throw 'no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/webassembly#binaryen-methods';

    module['print']('binaryen method succeeded.');

    return exports;
  };

  var methodhandler = module['asm']; // note our method handler, as we may modify module['asm'] later
}

module["demangle"] = demangle || (function (symbol) {return symbol});

var mediadevices = [];

module['prerun'].push(function ()
{

	var enumeratemediadevices = function ()
	{

		var getmedia  = navigator.getusermedia ||
						navigator.webkitgetusermedia ||
						navigator.mozgetusermedia ||
						navigator.msgetusermedia;

		if (!getmedia) 
			return;

		function adddevice(label) 
		{
			label = label ? label : ("device #" + mediadevices.length);

			var device = 
			{
				devicename: label,
				refcount: 0,
				video: null
			};

			mediadevices.push(device);
		}

		// try mediadevices.enumeratedevices, if available
		if (!navigator.mediadevices || !navigator.mediadevices.enumeratedevices) 
		{
			if (typeof mediastreamtrack == 'undefined' ||
				typeof mediastreamtrack.getsources == 'undefined') 
			{
				console.log("media devices cannot be enumerated on this browser.");
				return;
			}

			function gotsources(sourceinfos) 
			{

				for (var i = 0; i !== sourceinfos.length; ++i) 
				{
					var sourceinfo = sourceinfos[i];
					if (sourceinfo.kind === 'video') 
						adddevice(sourceinfo.label);
				}
			}

			// mediastreamtrack.getsources asynchronously returns a list of objects that identify devices
			// and for privacy purposes the .label properties are not filled in unless the user has consented to
			// device access through getusermedia.
			mediastreamtrack.getsources(gotsources);
		}

		// list cameras and microphones.
		navigator.mediadevices.enumeratedevices().then(function(devices) 
		{
			devices.foreach(function(device) 
			{
			  	// device: kind, label, deviceid
				if (device.kind == 'videoinput')
					adddevice(device.label);
			});
		})
		.catch(function(err) 
		{
			console.log(err.name + ": " + error.message);
		});
	};
	enumeratemediadevices();
});

function sendmessage(gameobject, func, param)
{
    if (param === undefined)
        module.ccall("sendmessage", null, ["string", "string"], [gameobject, func]);
    else if (typeof param === "string")
        module.ccall("sendmessagestring", null, ["string", "string", "string"], [gameobject, func, param]);
    else if (typeof param === "number")
        module.ccall("sendmessagefloat", null, ["string", "string", "number"], [gameobject, func, param]);
    else
        throw "" + param + " is does not have a type which is supported by sendmessage.";
}
module["sendmessage"] = sendmessage; // to avoid emscripten stripping
// the module object: our interface to the outside world. we import
// and export values on it, and do the work to get that through
// closure compiler if necessary. there are various ways module can be used:
// 1. not defined. we create it here
// 2. a function parameter, function(module) { ..generated code.. }
// 3. pre-run appended it, var module = {}; ..generated code..
// 4. external script tag defines var module.
// we need to do an eval in order to handle the closure compiler
// case, where this code here is minified but module was defined
// elsewhere (e.g. case 4 above). we also need to check if module
// already exists (e.g. case 3 above).
// note that if you want to run closure, and also to use module
// after the generated code, you will need to define   var module = {};
// before the code. then that object will be used in the code, and you
// can continue to use module afterwards as well.
var module;
if (!module) module = (typeof module !== 'undefined' ? module : null) || {};

// sometimes an existing module object exists with properties
// meant to overwrite the default module functionality. here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleoverrides = {};
for (var key in module) {
  if (module.hasownproperty(key)) {
    moduleoverrides[key] = module[key];
  }
}

// the environment setup code below is customized to use module.
// *** environment setup code ***
var environment_is_web = false;
var environment_is_worker = false;
var environment_is_node = false;
var environment_is_shell = false;

// three configurations we can be running in:
// 1) we could be the application main() thread running in the main js ui thread. (environment_is_worker == false and environment_is_pthread == false)
// 2) we could be the application main() thread proxied to worker. (with emscripten -s proxy_to_worker=1) (environment_is_worker == true, environment_is_pthread == false)
// 3) we could be an application pthread running in a worker. (environment_is_worker == true and environment_is_pthread == true)

if (module['environment']) {
  if (module['environment'] === 'web') {
    environment_is_web = true;
  } else if (module['environment'] === 'worker') {
    environment_is_worker = true;
  } else if (module['environment'] === 'node') {
    environment_is_node = true;
  } else if (module['environment'] === 'shell') {
    environment_is_shell = true;
  } else {
    throw new error('the provided module[\'environment\'] value is not valid. it must be one of: web|worker|node|shell.');
  }
} else {
  environment_is_web = typeof window === 'object';
  environment_is_worker = typeof importscripts === 'function';
  environment_is_node = typeof process === 'object' && typeof require === 'function' && !environment_is_web && !environment_is_worker;
  environment_is_shell = !environment_is_web && !environment_is_node && !environment_is_worker;
}


if (environment_is_node) {
  // expose functionality in the same simple way that the shells work
  // note that we pollute the global namespace here, otherwise we break in node
  if (!module['print']) module['print'] = console.log;
  if (!module['printerr']) module['printerr'] = console.warn;

  var nodefs;
  var nodepath;

  module['read'] = function read(filename, binary) {
    if (!nodefs) nodefs = require('fs');
    if (!nodepath) nodepath = require('path');
    filename = nodepath['normalize'](filename);
    var ret = nodefs['readfilesync'](filename);
    return binary ? ret : ret.tostring();
  };

  module['readbinary'] = function readbinary(filename) {
    var ret = module['read'](filename, true);
    if (!ret.buffer) {
      ret = new uint8array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  module['load'] = function load(f) {
    globaleval(read(f));
  };

  if (!module['thisprogram']) {
    if (process['argv'].length > 1) {
      module['thisprogram'] = process['argv'][1].replace(/\\/g, '/');
    } else {
      module['thisprogram'] = 'unknown-program';
    }
  }

  module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = module;
  }

  process['on']('uncaughtexception', function(ex) {
    // suppress exitstatus exceptions from showing an error
    if (!(ex instanceof exitstatus)) {
      throw ex;
    }
  });

  module['inspect'] = function () { return '[emscripten module object]'; };
}
else if (environment_is_shell) {
  if (!module['print']) module['print'] = print;
  if (typeof printerr != 'undefined') module['printerr'] = printerr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    module['read'] = read;
  } else {
    module['read'] = function read() { throw 'no read() available' };
  }

  module['readbinary'] = function readbinary(f) {
    if (typeof readbuffer === 'function') {
      return new uint8array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptargs != 'undefined') {
    module['arguments'] = scriptargs;
  } else if (typeof arguments != 'undefined') {
    module['arguments'] = arguments;
  }

}
else if (environment_is_web || environment_is_worker) {
  module['read'] = function read(url) {
    var xhr = new xmlhttprequest();
    xhr.open('get', url, false);
    xhr.send(null);
    return xhr.responsetext;
  };

  module['readasync'] = function readasync(url, onload, onerror) {
    var xhr = new xmlhttprequest();
    xhr.open('get', url, true);
    xhr.responsetype = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file urls can return 0
        onload(xhr.response);
      } else {
        onerror();
      }
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  if (typeof arguments != 'undefined') {
    module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!module['print']) module['print'] = function print(x) {
      console.log(x);
    };
    if (!module['printerr']) module['printerr'] = function printerr(x) {
      console.warn(x);
    };
  } else {
    // probably a worker, and without console.log. we can do very little here...
    var try_use_dump = false;
    if (!module['print']) module['print'] = (try_use_dump && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postmessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (environment_is_worker) {
    module['load'] = importscripts;
  }

  if (typeof module['setwindowtitle'] === 'undefined') {
    module['setwindowtitle'] = function(title) { document.title = title };
  }
}
else {
  // unreachable because shell is dependant on the others
  throw 'unknown runtime environment. where are we?';
}

function globaleval(x) {
  eval.call(null, x);
}
if (!module['load'] && module['read']) {
  module['load'] = function load(f) {
    globaleval(module['read'](f));
  };
}
if (!module['print']) {
  module['print'] = function(){};
}
if (!module['printerr']) {
  module['printerr'] = module['print'];
}
if (!module['arguments']) {
  module['arguments'] = [];
}
if (!module['thisprogram']) {
  module['thisprogram'] = './this.program';
}

// *** environment setup code ***

// closure helpers
module.print = module['print'];
module.printerr = module['printerr'];

// callbacks
module['prerun'] = [];
module['postrun'] = [];

// merge back in the overrides
for (var key in moduleoverrides) {
  if (moduleoverrides.hasownproperty(key)) {
    module[key] = moduleoverrides[key];
  }
}
// free the object hierarchy contained in the overrides, this lets the gc
// reclaim data used e.g. in memoryinitializerrequest, which is a large typed array.
moduleoverrides = undefined;



// {{preamble_additions}}

// === preamble library stuff ===

// documentation for the public apis defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// a prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// you can also build docs locally as html or other formats in site/
// an online html version (which may be of a different version of emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// runtime code shared with compiler
//========================================

var runtime = {
  settempret0: function (value) {
    tempret0 = value;
  },
  gettempret0: function () {
    return tempret0;
  },
  stacksave: function () {
    return stacktop;
  },
  stackrestore: function (stacktop) {
    stacktop = stacktop;
  },
  getnativetypesize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return runtime.quantum_size; // a pointer
        } else if (type[0] === 'i') {
          var bits = parseint(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getnativefieldsize: function (type) {
    return math.max(runtime.getnativetypesize(type), runtime.quantum_size);
  },
  stack_align: 16,
  prepvararg: function (ptr, type) {
    if (type === 'double' || type === 'i64') {
      // move so the load is aligned
      if (ptr & 7) {
        assert((ptr & 7) === 4);
        ptr += 4;
      }
    } else {
      assert((ptr & 3) === 0);
    }
    return ptr;
  },
  getalignsize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return math.min(size, 8); // align structures internally to 64 bits
    return math.min(size || (type ? runtime.getnativefieldsize(type) : 0), runtime.quantum_size);
  },
  dyncall: function (sig, ptr, args) {
    if (args && args.length) {
      return module['dyncall_' + sig].apply(null, [ptr].concat(args));
    } else {
      return module['dyncall_' + sig].call(null, ptr);
    }
  },
  functionpointers: [],
  addfunction: function (func) {
    for (var i = 0; i < runtime.functionpointers.length; i++) {
      if (!runtime.functionpointers[i]) {
        runtime.functionpointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'finished up all reserved function pointers. use a higher value for reserved_function_pointers.';
  },
  removefunction: function (index) {
    runtime.functionpointers[(index-2)/2] = null;
  },
  warnonce: function (text) {
    if (!runtime.warnonce.shown) runtime.warnonce.shown = {};
    if (!runtime.warnonce.shown[text]) {
      runtime.warnonce.shown[text] = 1;
      module.printerr(text);
    }
  },
  funcwrappers: {},
  getfuncwrapper: function (func, sig) {
    assert(sig);
    if (!runtime.funcwrappers[sig]) {
      runtime.funcwrappers[sig] = {};
    }
    var sigcache = runtime.funcwrappers[sig];
    if (!sigcache[func]) {
      // optimize away arguments usage in common cases
      if (sig.length === 1) {
        sigcache[func] = function dyncall_wrapper() {
          return runtime.dyncall(sig, func);
        };
      } else if (sig.length === 2) {
        sigcache[func] = function dyncall_wrapper(arg) {
          return runtime.dyncall(sig, func, [arg]);
        };
      } else {
        // general case
        sigcache[func] = function dyncall_wrapper() {
          return runtime.dyncall(sig, func, array.prototype.slice.call(arguments));
        };
      }
    }
    return sigcache[func];
  },
  getcompilersetting: function (name) {
    throw 'you must build with -s retain_compiler_settings=1 for runtime.getcompilersetting or emscripten_get_compiler_setting to work';
  },
  stackalloc: function (size) { var ret = stacktop;stacktop = (stacktop + size)|0;stacktop = (((stacktop)+15)&-16); return ret; },
  staticalloc: function (size) { var ret = statictop;statictop = (statictop + size)|0;statictop = (((statictop)+15)&-16); return ret; },
  dynamicalloc: function (size) { var ret = heap32[dynamictop_ptr>>2];var end = (((ret + size + 15)|0) & -16);heap32[dynamictop_ptr>>2] = end;if (end >= total_memory) {var success = enlargememory();if (!success) {heap32[dynamictop_ptr>>2] = ret;return 0;}}return ret;},
  alignmemory: function (size,quantum) { var ret = size = math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makebigint: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0))); return ret; },
  global_base: 1024,
  quantum_size: 4,
  __dummy__: 0
}



module["runtime"] = runtime;



//========================================
// runtime essentials
//========================================

var abort = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var exitstatus = 0;

function assert(condition, text) {
  if (!condition) {
    abort('assertion failed: ' + text);
  }
}

var globalscope = this;

// returns the c function with a specified identifier (for c++, you need to do manual name mangling)
function getcfunc(ident) {
  var func = module['_' + ident]; // closure exported function
  if (!func) {
    try { func = eval('_' + ident); } catch(e) {}
  }
  assert(func, 'cannot call unknown function ' + ident + ' (perhaps llvm optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var jsfuncs = {
    // helpers for cwrap -- it can't refer to runtime directly because it might
    // be renamed by closure, instead it calls jsfuncs['stacksave'].body to find
    // out what the minified function name is.
    'stacksave': function() {
      runtime.stacksave()
    },
    'stackrestore': function() {
      runtime.stackrestore()
    },
    // type conversion from js to c
    'arraytoc' : function(arr) {
      var ret = runtime.stackalloc(arr.length);
      writearraytomemory(arr, ret);
      return ret;
    },
    'stringtoc' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per utf-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = runtime.stackalloc(len);
        stringtoutf8(str, ret, len);
      }
      return ret;
    }
  };
  // for fast lookup of conversion functions
  var toc = {'string' : jsfuncs['stringtoc'], 'array' : jsfuncs['arraytoc']};

  // c calling interface.
  ccall = function ccallfunc(ident, returntype, argtypes, args, opts) {
    var func = getcfunc(ident);
    var cargs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toc[argtypes[i]];
        if (converter) {
          if (stack === 0) stack = runtime.stacksave();
          cargs[i] = converter(args[i]);
        } else {
          cargs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cargs);
    if (returntype === 'string') ret = pointer_stringify(ret);
    if (stack !== 0) {
      if (opts && opts.async) {
        emterpreterasync.asyncfinalizers.push(function() {
          runtime.stackrestore(stack);
        });
        return;
      }
      runtime.stackrestore(stack);
    }
    return ret;
  }

  var sourceregex = /^function\s*[a-za-z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
  function parsejsfunc(jsfunc) {
    // match the body and the return value of a javascript function source
    var parsed = jsfunc.tostring().match(sourceregex).slice(1);
    return {arguments : parsed[0], body : parsed[1], returnvalue: parsed[2]}
  }

  // sources of useful functions. we create this lazily as it can trigger a source decompression on this entire file
  var jssource = null;
  function ensurejssource() {
    if (!jssource) {
      jssource = {};
      for (var fun in jsfuncs) {
        if (jsfuncs.hasownproperty(fun)) {
          // elements of tocsource are arrays of three items:
          // the code, and the return value
          jssource[fun] = parsejsfunc(jsfuncs[fun]);
        }
      }
    }
  }

  cwrap = function cwrap(ident, returntype, argtypes) {
    argtypes = argtypes || [];
    var cfunc = getcfunc(ident);
    // when the function takes numbers and returns a number, we can just return
    // the original function
    var numericargs = argtypes.every(function(type){ return type === 'number'});
    var numericret = (returntype !== 'string');
    if ( numericret && numericargs) {
      return cfunc;
    }
    // creation of the arguments list (["$1","$2",...,"$nargs"])
    var argnames = argtypes.map(function(x,i){return '$'+i});
    var funcstr = "(function(" + argnames.join(',') + ") {";
    var nargs = argtypes.length;
    if (!numericargs) {
      // generate the code needed to convert the arguments from javascript
      // values to pointers
      ensurejssource();
      funcstr += 'var stack = ' + jssource['stacksave'].body + ';';
      for (var i = 0; i < nargs; i++) {
        var arg = argnames[i], type = argtypes[i];
        if (type === 'number') continue;
        var convertcode = jssource[type + 'toc']; // [code, return]
        funcstr += 'var ' + convertcode.arguments + ' = ' + arg + ';';
        funcstr += convertcode.body + ';';
        funcstr += arg + '=(' + convertcode.returnvalue + ');';
      }
    }

    // when the code is compressed, the name of cfunc is not literally 'cfunc' anymore
    var cfuncname = parsejsfunc(function(){return cfunc}).returnvalue;
    // call the function
    funcstr += 'var ret = ' + cfuncname + '(' + argnames.join(',') + ');';
    if (!numericret) { // return type can only by 'string' or 'number'
      // convert the result to a string
      var strgfy = parsejsfunc(function(){return pointer_stringify}).returnvalue;
      funcstr += 'ret = ' + strgfy + '(ret);';
    }
    if (!numericargs) {
      // if we had a stack, restore it
      ensurejssource();
      funcstr += jssource['stackrestore'].body.replace('()', '(stack)') + ';';
    }
    funcstr += 'return ret})';
    return eval(funcstr);
  };
})();
module["ccall"] = ccall;
module["cwrap"] = cwrap;

function setvalue(ptr, value, type, nosafe) {
  type = type || 'i8';
  if (type.charat(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': heap8[((ptr)>>0)]=value; break;
      case 'i8': heap8[((ptr)>>0)]=value; break;
      case 'i16': heap16[((ptr)>>1)]=value; break;
      case 'i32': heap32[((ptr)>>2)]=value; break;
      case 'i64': (tempi64 = [value>>>0,(tempdouble=value,(+(math_abs(tempdouble))) >= 1.0 ? (tempdouble > 0.0 ? ((math_min((+(math_floor((tempdouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(math_ceil((tempdouble - +(((~~(tempdouble)))>>>0))/4294967296.0)))))>>>0) : 0)],heap32[((ptr)>>2)]=tempi64[0],heap32[(((ptr)+(4))>>2)]=tempi64[1]); break;
      case 'float': heapf32[((ptr)>>2)]=value; break;
      case 'double': heapf64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setvalue: ' + type);
    }
}
module["setvalue"] = setvalue;


function getvalue(ptr, type, nosafe) {
  type = type || 'i8';
  if (type.charat(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return heap8[((ptr)>>0)];
      case 'i8': return heap8[((ptr)>>0)];
      case 'i16': return heap16[((ptr)>>1)];
      case 'i32': return heap32[((ptr)>>2)];
      case 'i64': return heap32[((ptr)>>2)];
      case 'float': return heapf32[((ptr)>>2)];
      case 'double': return heapf64[((ptr)>>3)];
      default: abort('invalid type for setvalue: ' + type);
    }
  return null;
}
module["getvalue"] = getvalue;

var alloc_normal = 0; // tries to use _malloc()
var alloc_stack = 1; // lives for the duration of the current function call
var alloc_static = 2; // cannot be freed
var alloc_dynamic = 3; // cannot be freed except through sbrk
var alloc_none = 4; // do not allocate
module["alloc_normal"] = alloc_normal;
module["alloc_stack"] = alloc_stack;
module["alloc_static"] = alloc_static;
module["alloc_dynamic"] = alloc_dynamic;
module["alloc_none"] = alloc_none;

// allocate(): this is for internal use. you can use it yourself as well, but the interface
//             is a little tricky (see docs right below). the reason is that it is optimized
//             for multiple syntaxes to save space in generated code. so you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setvalue(), and so forth.
// @slab: an array of data, or a number. if a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. this only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: how to allocate memory, see alloc_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singletype = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == alloc_none) {
    ret = ptr;
  } else {
    ret = [typeof _malloc === 'function' ? _malloc : runtime.staticalloc, runtime.stackalloc, runtime.staticalloc, runtime.dynamicalloc][allocator === undefined ? alloc_static : allocator](math.max(size, singletype ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      heap32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      heap8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singletype === 'i8') {
    if (slab.subarray || slab.slice) {
      heapu8.set(slab, ret);
    } else {
      heapu8.set(new uint8array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typesize, previoustype;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = runtime.getfunctionindex(curr);
    }

    type = singletype || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setvalue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previoustype !== type) {
      typesize = runtime.getnativetypesize(type);
      previoustype = type;
    }
    i += typesize;
  }

  return ret;
}
module["allocate"] = allocate;

// allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getmemory(size) {
  if (!staticsealed) return runtime.staticalloc(size);
  if (!runtimeinitialized) return runtime.dynamicalloc(size);
  return _malloc(size);
}
module["getmemory"] = getmemory;

function pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // todo: use textdecoder
  // find the length, and check for utf while doing so
  var hasutf = 0;
  var t;
  var i = 0;
  while (1) {
    t = heapu8[(((ptr)+(i))>>0)];
    hasutf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasutf < 128) {
    var max_chunk = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = string.fromcharcode.apply(string, heapu8.subarray(ptr, ptr + math.min(length, max_chunk)));
      ret = ret ? ret + curr : curr;
      ptr += max_chunk;
      length -= max_chunk;
    }
    return ret;
  }
  return module['utf8tostring'](ptr);
}
module["pointer_stringify"] = pointer_stringify;

// given a pointer 'ptr' to a null-terminated ascii-encoded string in the emscripten heap, returns
// a copy of that string as a javascript string object.

function asciitostring(ptr) {
  var str = '';
  while (1) {
    var ch = heap8[((ptr++)>>0)];
    if (!ch) return str;
    str += string.fromcharcode(ch);
  }
}
module["asciitostring"] = asciitostring;

// copies the given javascript string object 'str' to the emscripten heap at address 'outptr',
// null-terminated and encoded in ascii form. the copy will require at most str.length+1 bytes of space in the heap.

function stringtoascii(str, outptr) {
  return writeasciitomemory(str, outptr, false);
}
module["stringtoascii"] = stringtoascii;

// given a pointer 'ptr' to a null-terminated utf8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a javascript string object.

var utf8decoder = typeof textdecoder !== 'undefined' ? new textdecoder('utf8') : undefined;
function utf8arraytostring(u8array, idx) {
  var endptr = idx;
  // textdecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // also, use the length info to avoid running tiny strings through textdecoder, since .subarray() allocates garbage.
  while (u8array[endptr]) ++endptr;

  if (endptr - idx > 16 && u8array.subarray && utf8decoder) {
    return utf8decoder.decode(u8array.subarray(idx, endptr));
  } else {
    var u0, u1, u2, u3, u4, u5;

    var str = '';
    while (1) {
      // for utf8 byte structure, see http://en.wikipedia.org/wiki/utf-8#description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
      u0 = u8array[idx++];
      if (!u0) return str;
      if (!(u0 & 0x80)) { str += string.fromcharcode(u0); continue; }
      u1 = u8array[idx++] & 63;
      if ((u0 & 0xe0) == 0xc0) { str += string.fromcharcode(((u0 & 31) << 6) | u1); continue; }
      u2 = u8array[idx++] & 63;
      if ((u0 & 0xf0) == 0xe0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u3 = u8array[idx++] & 63;
        if ((u0 & 0xf8) == 0xf0) {
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
        } else {
          u4 = u8array[idx++] & 63;
          if ((u0 & 0xfc) == 0xf8) {
            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
          } else {
            u5 = u8array[idx++] & 63;
            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
          }
        }
      }
      if (u0 < 0x10000) {
        str += string.fromcharcode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += string.fromcharcode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));
      }
    }
  }
}
module["utf8arraytostring"] = utf8arraytostring;

// given a pointer 'ptr' to a null-terminated utf8-encoded string in the emscripten heap, returns
// a copy of that string as a javascript string object.

function utf8tostring(ptr) {
  return utf8arraytostring(heapu8,ptr);
}
module["utf8tostring"] = utf8tostring;

// copies the given javascript string object 'str' to the given byte array at address 'outidx',
// encoded in utf8 form and null-terminated. the copy will require at most str.length*4+1 bytes of space in the heap.
// use the function lengthbytesutf8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// parameters:
//   str: the javascript string to copy.
//   outu8array: the array to copy to. each index in this array is assumed to be one 8-byte element.
//   outidx: the starting offset in the array to begin the copying.
//   maxbytestowrite: the maximum number of bytes this function can write to the array. this count should include the null
//                    terminator, i.e. if maxbytestowrite=1, only the null terminator will be written and nothing else.
//                    maxbytestowrite=0 does not write any bytes to the output, not even the null terminator.
// returns the number of bytes written, excluding the null terminator.

function stringtoutf8array(str, outu8array, outidx, maxbytestowrite) {
  if (!(maxbytestowrite > 0)) // parameter maxbytestowrite is not optional. negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startidx = outidx;
  var endidx = outidx + maxbytestowrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // gotcha: charcodeat returns a 16-bit word that is a utf-16 encoded code unit, not a unicode code point of the character! so decode utf16->utf32->utf8.
    // see http://unicode.org/faq/utf_bom.html#utf16-3
    // for utf8 byte structure, see http://en.wikipedia.org/wiki/utf-8#description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charcodeat(i); // possibly a lead surrogate
    if (u >= 0xd800 && u <= 0xdfff) u = 0x10000 + ((u & 0x3ff) << 10) | (str.charcodeat(++i) & 0x3ff);
    if (u <= 0x7f) {
      if (outidx >= endidx) break;
      outu8array[outidx++] = u;
    } else if (u <= 0x7ff) {
      if (outidx + 1 >= endidx) break;
      outu8array[outidx++] = 0xc0 | (u >> 6);
      outu8array[outidx++] = 0x80 | (u & 63);
    } else if (u <= 0xffff) {
      if (outidx + 2 >= endidx) break;
      outu8array[outidx++] = 0xe0 | (u >> 12);
      outu8array[outidx++] = 0x80 | ((u >> 6) & 63);
      outu8array[outidx++] = 0x80 | (u & 63);
    } else if (u <= 0x1fffff) {
      if (outidx + 3 >= endidx) break;
      outu8array[outidx++] = 0xf0 | (u >> 18);
      outu8array[outidx++] = 0x80 | ((u >> 12) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 6) & 63);
      outu8array[outidx++] = 0x80 | (u & 63);
    } else if (u <= 0x3ffffff) {
      if (outidx + 4 >= endidx) break;
      outu8array[outidx++] = 0xf8 | (u >> 24);
      outu8array[outidx++] = 0x80 | ((u >> 18) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 12) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 6) & 63);
      outu8array[outidx++] = 0x80 | (u & 63);
    } else {
      if (outidx + 5 >= endidx) break;
      outu8array[outidx++] = 0xfc | (u >> 30);
      outu8array[outidx++] = 0x80 | ((u >> 24) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 18) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 12) & 63);
      outu8array[outidx++] = 0x80 | ((u >> 6) & 63);
      outu8array[outidx++] = 0x80 | (u & 63);
    }
  }
  // null-terminate the pointer to the buffer.
  outu8array[outidx] = 0;
  return outidx - startidx;
}
module["stringtoutf8array"] = stringtoutf8array;

// copies the given javascript string object 'str' to the emscripten heap at address 'outptr',
// null-terminated and encoded in utf8 form. the copy will require at most str.length*4+1 bytes of space in the heap.
// use the function lengthbytesutf8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// returns the number of bytes written, excluding the null terminator.

function stringtoutf8(str, outptr, maxbytestowrite) {
  return stringtoutf8array(str, heapu8,outptr, maxbytestowrite);
}
module["stringtoutf8"] = stringtoutf8;

// returns the number of bytes the given javascript string takes if encoded as a utf8 byte array, excluding the null terminator byte.

function lengthbytesutf8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // gotcha: charcodeat returns a 16-bit word that is a utf-16 encoded code unit, not a unicode code point of the character! so decode utf16->utf32->utf8.
    // see http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charcodeat(i); // possibly a lead surrogate
    if (u >= 0xd800 && u <= 0xdfff) u = 0x10000 + ((u & 0x3ff) << 10) | (str.charcodeat(++i) & 0x3ff);
    if (u <= 0x7f) {
      ++len;
    } else if (u <= 0x7ff) {
      len += 2;
    } else if (u <= 0xffff) {
      len += 3;
    } else if (u <= 0x1fffff) {
      len += 4;
    } else if (u <= 0x3ffffff) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
module["lengthbytesutf8"] = lengthbytesutf8;

// given a pointer 'ptr' to a null-terminated utf16le-encoded string in the emscripten heap, returns
// a copy of that string as a javascript string object.

var utf16decoder = typeof textdecoder !== 'undefined' ? new textdecoder('utf-16le') : undefined;
function utf16tostring(ptr) {
  var endptr = ptr;
  // textdecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // also, use the length info to avoid running tiny strings through textdecoder, since .subarray() allocates garbage.
  var idx = endptr >> 1;
  while (heap16[idx]) ++idx;
  endptr = idx << 1;

  if (endptr - ptr > 32 && utf16decoder) {
    return utf16decoder.decode(heapu8.subarray(ptr, endptr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeunit = heap16[(((ptr)+(i*2))>>1)];
      if (codeunit == 0) return str;
      ++i;
      // fromcharcode constructs a character from a utf-16 code unit, so we can pass the utf16 string right through.
      str += string.fromcharcode(codeunit);
    }
  }
}


// copies the given javascript string object 'str' to the emscripten heap at address 'outptr',
// null-terminated and encoded in utf16 form. the copy will require at most str.length*4+2 bytes of space in the heap.
// use the function lengthbytesutf16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// parameters:
//   str: the javascript string to copy.
//   outptr: byte address in emscripten heap where to write the string to.
//   maxbytestowrite: the maximum number of bytes this function can write to the array. this count should include the null
//                    terminator, i.e. if maxbytestowrite=2, only the null terminator will be written and nothing else.
//                    maxbytestowrite<2 does not write any bytes to the output, not even the null terminator.
// returns the number of bytes written, excluding the null terminator.

function stringtoutf16(str, outptr, maxbytestowrite) {
  // backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxbytestowrite === undefined) {
    maxbytestowrite = 0x7fffffff;
  }
  if (maxbytestowrite < 2) return 0;
  maxbytestowrite -= 2; // null terminator.
  var startptr = outptr;
  var numcharstowrite = (maxbytestowrite < str.length*2) ? (maxbytestowrite / 2) : str.length;
  for (var i = 0; i < numcharstowrite; ++i) {
    // charcodeat returns a utf-16 encoded code unit, so it can be directly written to the heap.
    var codeunit = str.charcodeat(i); // possibly a lead surrogate
    heap16[((outptr)>>1)]=codeunit;
    outptr += 2;
  }
  // null-terminate the pointer to the heap.
  heap16[((outptr)>>1)]=0;
  return outptr - startptr;
}


// returns the number of bytes the given javascript string takes if encoded as a utf16 byte array, excluding the null terminator byte.

function lengthbytesutf16(str) {
  return str.length*2;
}


function utf32tostring(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = heap32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // gotcha: fromcharcode constructs a character from a utf-16 encoded code (pair), not from a unicode code point! so encode the code point to utf-16 for constructing.
    // see http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += string.fromcharcode(0xd800 | (ch >> 10), 0xdc00 | (ch & 0x3ff));
    } else {
      str += string.fromcharcode(utf32);
    }
  }
}


// copies the given javascript string object 'str' to the emscripten heap at address 'outptr',
// null-terminated and encoded in utf32 form. the copy will require at most str.length*4+4 bytes of space in the heap.
// use the function lengthbytesutf32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// parameters:
//   str: the javascript string to copy.
//   outptr: byte address in emscripten heap where to write the string to.
//   maxbytestowrite: the maximum number of bytes this function can write to the array. this count should include the null
//                    terminator, i.e. if maxbytestowrite=4, only the null terminator will be written and nothing else.
//                    maxbytestowrite<4 does not write any bytes to the output, not even the null terminator.
// returns the number of bytes written, excluding the null terminator.

function stringtoutf32(str, outptr, maxbytestowrite) {
  // backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxbytestowrite === undefined) {
    maxbytestowrite = 0x7fffffff;
  }
  if (maxbytestowrite < 4) return 0;
  var startptr = outptr;
  var endptr = startptr + maxbytestowrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // gotcha: charcodeat returns a 16-bit word that is a utf-16 encoded code unit, not a unicode code point of the character! we must decode the string to utf-32 to the heap.
    // see http://unicode.org/faq/utf_bom.html#utf16-3
    var codeunit = str.charcodeat(i); // possibly a lead surrogate
    if (codeunit >= 0xd800 && codeunit <= 0xdfff) {
      var trailsurrogate = str.charcodeat(++i);
      codeunit = 0x10000 + ((codeunit & 0x3ff) << 10) | (trailsurrogate & 0x3ff);
    }
    heap32[((outptr)>>2)]=codeunit;
    outptr += 4;
    if (outptr + 4 > endptr) break;
  }
  // null-terminate the pointer to the heap.
  heap32[((outptr)>>2)]=0;
  return outptr - startptr;
}


// returns the number of bytes the given javascript string takes if encoded as a utf16 byte array, excluding the null terminator byte.

function lengthbytesutf32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // gotcha: charcodeat returns a 16-bit word that is a utf-16 encoded code unit, not a unicode code point of the character! we must decode the string to utf-32 to the heap.
    // see http://unicode.org/faq/utf_bom.html#utf16-3
    var codeunit = str.charcodeat(i);
    if (codeunit >= 0xd800 && codeunit <= 0xdfff) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}


function demangle(func) {
  var __cxa_demangle_func = module['___cxa_demangle'] || module['__cxa_demangle'];
  if (__cxa_demangle_func) {
    try {
      var s =
        func.substr(1);
      var len = lengthbytesutf8(s)+1;
      var buf = _malloc(len);
      stringtoutf8(s, buf, len);
      var status = _malloc(4);
      var ret = __cxa_demangle_func(buf, 0, 0, status);
      if (getvalue(status, 'i32') === 0 && ret) {
        return pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed
    } catch(e) {
      // ignore problems here
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
    // failure when using libcxxabi, don't demangle
    return func;
  }
  runtime.warnonce('warning: build with  -s demangle_support=1  to link in libcxxabi demangling');
  return func;
}

function demangleall(text) {
  var regex =
    /__z[\w\d_]+/g;
  return text.replace(regex,
    function(x) {
      var y = demangle(x);
      return x === y ? x : (x + ' [' + y + ']');
    });
}

function jsstacktrace() {
  var err = new error();
  if (!err.stack) {
    // ie10+ special cases: it does have callstack info, but it is only populated if an error object is thrown,
    // so try that as a special-case.
    try {
      throw new error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.tostring();
}

function stacktrace() {
  var js = jsstacktrace();
  if (module['extrastacktrace']) js += '\n' + module['extrastacktrace']();
  return demangleall(js);
}
module["stacktrace"] = stacktrace;

// memory management

var page_size = 4096;

function alignmemorypage(x) {
  if (x % 4096 > 0) {
    x += (4096 - (x % 4096));
  }
  return x;
}

var heap;
var buffer;
var heap8, heapu8, heap16, heapu16, heap32, heapu32, heapf32, heapf64;

function updateglobalbuffer(buf) {
  module['buffer'] = buffer = buf;
}

function updateglobalbufferviews() {
  module['heap8'] = heap8 = new int8array(buffer);
  module['heap16'] = heap16 = new int16array(buffer);
  module['heap32'] = heap32 = new int32array(buffer);
  module['heapu8'] = heapu8 = new uint8array(buffer);
  module['heapu16'] = heapu16 = new uint16array(buffer);
  module['heapu32'] = heapu32 = new uint32array(buffer);
  module['heapf32'] = heapf32 = new float32array(buffer);
  module['heapf64'] = heapf64 = new float64array(buffer);
}

var static_base, statictop, staticsealed; // static area
var stack_base, stacktop, stack_max; // stack area
var dynamic_base, dynamictop_ptr; // dynamic area handled by sbrk

  static_base = statictop = stack_base = stacktop = stack_max = dynamic_base = dynamictop_ptr = 0;
  staticsealed = false;



function abortoncannotgrowmemory() {
  abort('cannot enlarge memory arrays. either (1) compile with  -s total_memory=x  with x higher than the current value ' + total_memory + ', (2) compile with  -s allow_memory_growth=1  which adjusts the size at runtime but prevents some optimizations, (3) set module.total_memory to a higher value before the program runs, or if you want malloc to return null (0) instead of this abort, compile with  -s aborting_malloc=0 ');
}


function enlargememory() {
  abortoncannotgrowmemory();
}


var total_stack = module['total_stack'] || 5242880;
var total_memory = module['total_memory'] || 268435456;

var wasm_page_size = 64 * 1024;

var totalmemory = wasm_page_size;
while (totalmemory < total_memory || totalmemory < 2*total_stack) {
  if (totalmemory < 16*1024*1024) {
    totalmemory *= 2;
  } else {
    totalmemory += 16*1024*1024;
  }
}
if (totalmemory !== total_memory) {
  total_memory = totalmemory;
}

// initialize the runtime's memory



// use a provided buffer, if there is one, or else allocate a new one
if (module['buffer']) {
  buffer = module['buffer'];
} else {
  // use a webassembly memory where available
  if (typeof webassembly === 'object' && typeof webassembly.memory === 'function') {
    module['wasmmemory'] = new webassembly.memory({ initial: total_memory / wasm_page_size, maximum: total_memory / wasm_page_size });
    buffer = module['wasmmemory'].buffer;
  } else
  {
    buffer = new arraybuffer(total_memory);
  }
}
updateglobalbufferviews();


function gettotalmemory() {
  return total_memory;
}

// endianness check (note: assumes compiler arch was little-endian)
  heap32[0] = 0x63736d65; /* 'emsc' */
heap16[1] = 0x6373;
if (heapu8[2] !== 0x73 || heapu8[3] !== 0x63) throw 'runtime error: expected the system to be little-endian!';

module['heap'] = heap;
module['buffer'] = buffer;
module['heap8'] = heap8;
module['heap16'] = heap16;
module['heap32'] = heap32;
module['heapu8'] = heapu8;
module['heapu16'] = heapu16;
module['heapu32'] = heapu32;
module['heapf32'] = heapf32;
module['heapf64'] = heapf64;

function callruntimecallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        module['dyncall_v'](func);
      } else {
        module['dyncall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __atprerun__  = []; // functions called before the runtime is initialized
var __atinit__    = []; // functions called during startup
var __atmain__    = []; // functions called when main() is to be run
var __atexit__    = []; // functions called during shutdown
var __atpostrun__ = []; // functions called after the runtime has exited

var runtimeinitialized = false;
var runtimeexited = false;


function prerun() {
  // compatibility - merge in anything from module['prerun'] at this time
  if (module['prerun']) {
    if (typeof module['prerun'] == 'function') module['prerun'] = [module['prerun']];
    while (module['prerun'].length) {
      addonprerun(module['prerun'].shift());
    }
  }
  callruntimecallbacks(__atprerun__);
}

function ensureinitruntime() {
  if (runtimeinitialized) return;
  runtimeinitialized = true;
  callruntimecallbacks(__atinit__);
}

function premain() {
  callruntimecallbacks(__atmain__);
}

function exitruntime() {
  callruntimecallbacks(__atexit__);
  runtimeexited = true;
}

function postrun() {
  // compatibility - merge in anything from module['postrun'] at this time
  if (module['postrun']) {
    if (typeof module['postrun'] == 'function') module['postrun'] = [module['postrun']];
    while (module['postrun'].length) {
      addonpostrun(module['postrun'].shift());
    }
  }
  callruntimecallbacks(__atpostrun__);
}

function addonprerun(cb) {
  __atprerun__.unshift(cb);
}
module["addonprerun"] = addonprerun;

function addoninit(cb) {
  __atinit__.unshift(cb);
}
module["addoninit"] = addoninit;

function addonpremain(cb) {
  __atmain__.unshift(cb);
}
module["addonpremain"] = addonpremain;

function addonexit(cb) {
  __atexit__.unshift(cb);
}
module["addonexit"] = addonexit;

function addonpostrun(cb) {
  __atpostrun__.unshift(cb);
}
module["addonpostrun"] = addonpostrun;

// tools


function intarrayfromstring(stringy, dontaddnull, length /* optional */) {
  var len = length > 0 ? length : lengthbytesutf8(stringy)+1;
  var u8array = new array(len);
  var numbyteswritten = stringtoutf8array(stringy, u8array, 0, u8array.length);
  if (dontaddnull) u8array.length = numbyteswritten;
  return u8array;
}
module["intarrayfromstring"] = intarrayfromstring;

function intarraytostring(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xff) {
      chr &= 0xff;
    }
    ret.push(string.fromcharcode(chr));
  }
  return ret.join('');
}
module["intarraytostring"] = intarraytostring;

// deprecated: this function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. prefer calling the
// function stringtoutf8array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
function writestringtomemory(string, buffer, dontaddnull) {
  runtime.warnonce('writestringtomemory is deprecated and should not be called! use stringtoutf8() instead!');

  var lastchar, end;
  if (dontaddnull) {
    // stringtoutf8array always appends null. if we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthbytesutf8(string);
    lastchar = heap8[end];
  }
  stringtoutf8(string, buffer, infinity);
  if (dontaddnull) heap8[end] = lastchar; // restore the value under the null character.
}
module["writestringtomemory"] = writestringtomemory;

function writearraytomemory(array, buffer) {
  heap8.set(array, buffer);
}
module["writearraytomemory"] = writearraytomemory;

function writeasciitomemory(str, buffer, dontaddnull) {
  for (var i = 0; i < str.length; ++i) {
    heap8[((buffer++)>>0)]=str.charcodeat(i);
  }
  // null-terminate the pointer to the heap.
  if (!dontaddnull) heap8[((buffer)>>0)]=0;
}
module["writeasciitomemory"] = writeasciitomemory;

function unsign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*math.abs(1 << (bits-1)) + value // need some trickery, since if bits == 32, we are right at the limit of the bits js uses in bitshifts
                    : math.pow(2, bits)         + value;
}
function resign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. with 64-bit ints, we get rounding and errors
                                                       // todo: in i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // cannot bitshift half, as it may be at the limit of the bits js uses in bitshifts
  }
  return value;
}


// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!math['imul'] || math['imul'](0xffffffff, 5) !== -5) math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
math.imul = math['imul'];

if (!math['fround']) {
  var froundbuffer = new float32array(1);
  math['fround'] = function(x) { froundbuffer[0] = x; return froundbuffer[0] };
}
math.fround = math['fround'];

if (!math['clz32']) math['clz32'] = function(x) {
  x = x >>> 0;
  for (var i = 0; i < 32; i++) {
    if (x & (1 << (31 - i))) return i;
  }
  return 32;
};
math.clz32 = math['clz32']

if (!math['trunc']) math['trunc'] = function(x) {
  return x < 0 ? math.ceil(x) : math.floor(x);
};
math.trunc = math['trunc'];

var math_abs = math.abs;
var math_cos = math.cos;
var math_sin = math.sin;
var math_tan = math.tan;
var math_acos = math.acos;
var math_asin = math.asin;
var math_atan = math.atan;
var math_atan2 = math.atan2;
var math_exp = math.exp;
var math_log = math.log;
var math_sqrt = math.sqrt;
var math_ceil = math.ceil;
var math_floor = math.floor;
var math_pow = math.pow;
var math_imul = math.imul;
var math_fround = math.fround;
var math_round = math.round;
var math_min = math.min;
var math_clz32 = math.clz32;
var math_trunc = math.trunc;

// a counter of dependencies for calling run(). if we need to
// do asynchronous work before running, increment this and
// decrement it. incrementing must happen in a place like
// pre_run_additions (used by emcc to add file preloading).
// note that you can add dependencies in prerun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var rundependencies = 0;
var rundependencywatcher = null;
var dependenciesfulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getuniquerundependency(id) {
  return id;
}

function addrundependency(id) {
  rundependencies++;
  if (module['monitorrundependencies']) {
    module['monitorrundependencies'](rundependencies);
  }
}
module["addrundependency"] = addrundependency;

function removerundependency(id) {
  rundependencies--;
  if (module['monitorrundependencies']) {
    module['monitorrundependencies'](rundependencies);
  }
  if (rundependencies == 0) {
    if (rundependencywatcher !== null) {
      clearinterval(rundependencywatcher);
      rundependencywatcher = null;
    }
    if (dependenciesfulfilled) {
      var callback = dependenciesfulfilled;
      dependenciesfulfilled = null;
      callback(); // can add another dependenciesfulfilled
    }
  }
}
module["removerundependency"] = removerundependency;

module["preloadedimages"] = {}; // maps url to image data
module["preloadedaudios"] = {}; // maps url to audio data



var memoryinitializer = null;





function integratewasmjs(module) {
  // wasm.js has several methods for creating the compiled code module here:
  //  * 'native-wasm' : use native webassembly support in the browser
  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret
  //  * 'interpret-binary': load binary wasm and interpret
  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret
  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)
  // the method can be set at compile time (binaryen_method), or runtime by setting module['wasmjsmethod'].
  // the method can be a comma-separated list, in which case, we will try the
  // options one by one. some of them can fail gracefully, and then we can try
  // the next.

  // inputs

  var method = module['wasmjsmethod'] || 'native-wasm';
  module['wasmjsmethod'] = method;

  var wasmtextfile = module['wasmtextfile'] || 'build.wast';
  var wasmbinaryfile = module['wasmbinaryfile'] || 'build.wasm';
  var asmjscodefile = module['asmjscodefile'] || 'build.asm.js';

  // utilities

  var wasmpagesize = 64*1024;

  var asm2wasmimports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
      return x % y;
    },
    "f64-to-int": function(x) {
      return x | 0;
    },
    "i32s-div": function(x, y) {
      return ((x | 0) / (y | 0)) | 0;
    },
    "i32u-div": function(x, y) {
      return ((x >>> 0) / (y >>> 0)) >>> 0;
    },
    "i32s-rem": function(x, y) {
      return ((x | 0) % (y | 0)) | 0;
    },
    "i32u-rem": function(x, y) {
      return ((x >>> 0) % (y >>> 0)) >>> 0;
    },
    "debugger": function() {
      debugger;
    },
  };

  var info = {
    'global': null,
    'env': null,
    'asm2wasm': asm2wasmimports,
    'parent': module // module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.
  };

  var exports = null;

  function lookupimport(mod, base) {
    var lookup = info;
    if (mod.indexof('.') < 0) {
      lookup = (lookup || {})[mod];
    } else {
      var parts = mod.split('.');
      lookup = (lookup || {})[parts[0]];
      lookup = (lookup || {})[parts[1]];
    }
    if (base) {
      lookup = (lookup || {})[base];
    }
    if (lookup === undefined) {
      abort('bad lookupimport to (' + mod + ').' + base);
    }
    return lookup;
  }

  function mergememory(newbuffer) {
    // the wasm instance creates its memory. but static init code might have written to
    // buffer already, including the mem init file, and we must copy it over in a proper merge.
    // todo: avoid this copy, by avoiding such static init writes
    // todo: in shorter term, just copy up to the last static init write
    var oldbuffer = module['buffer'];
    if (newbuffer.bytelength < oldbuffer.bytelength) {
      module['printerr']('the new buffer in mergememory is smaller than the previous one. in native wasm, we should grow memory here');
    }
    var oldview = new int8array(oldbuffer);
    var newview = new int8array(newbuffer);

    // if we have a mem init file, do not trample it
    if (!memoryinitializer) {
      oldview.set(newview.subarray(module['static_base'], module['static_base'] + module['static_bump']), module['static_base']);
    }

    newview.set(oldview);
    updateglobalbuffer(newbuffer);
    updateglobalbufferviews();
  }

  var wasmtypes = {
    none: 0,
    i32: 1,
    i64: 2,
    f32: 3,
    f64: 4
  };

  function fiximports(imports) {
    if (!0) return imports;
    var ret = {};
    for (var i in imports) {
      var fixed = i;
      if (fixed[0] == '_') fixed = fixed.substr(1);
      ret[fixed] = imports[i];
    }
    return ret;
  }

  function getbinary() {
    var binary;
    if (environment_is_web || environment_is_worker) {
      binary = module['wasmbinary'];
      assert(binary, "on the web, we need the wasm binary to be preloaded and set on module['wasmbinary']. emcc.py will do that for you when generating html (but not js)");
      binary = new uint8array(binary);
    } else {
      binary = module['readbinary'](wasmbinaryfile);
    }
    return binary;
  }

  // do-method functions

  function dojustasm(global, env, providedbuffer) {
    // if no module.asm, or it's the method handler helper (see below), then apply
    // the asmjs
    if (typeof module['asm'] !== 'function' || module['asm'] === methodhandler) {
      if (!module['asmpreload']) {
        // you can load the .asm.js file before this, to avoid this sync xhr and eval
        eval(module['read'](asmjscodefile)); // set module.asm
      } else {
        module['asm'] = module['asmpreload'];
      }
    }
    if (typeof module['asm'] !== 'function') {
      module['printerr']('asm evalling did not set the module properly');
      return false;
    }
    return module['asm'](global, env, providedbuffer);
  }

  function donativewasm(global, env, providedbuffer) {
    if (typeof webassembly !== 'object') {
      module['printerr']('no native wasm support detected');
      return false;
    }
    // prepare memory import
    if (!(module['wasmmemory'] instanceof webassembly.memory)) {
      module['printerr']('no native wasm memory in use');
      return false;
    }
    env['memory'] = module['wasmmemory'];
    // load the wasm module and create an instance of using native support in the js engine.
    info['global'] = {
      'nan': nan,
      'infinity': infinity
    };
    info['global.math'] = global.math;
    info['env'] = env;
    // handle a generated wasm instance, receiving its exports and
    // performing other necessary setup
    function receiveinstance(instance) {
      exports = instance.exports;
      if (exports.memory) mergememory(exports.memory);
      module["usingwasm"] = true;
    }
    module['printerr']('asynchronously preparing wasm');
    addrundependency('wasm-instantiate'); // we can't run yet
    webassembly.instantiate(getbinary(), info).then(function(output) {
      receiveinstance(output.instance);
      module['asm'] = exports; // swap in the exports so they can be called
      removerundependency('wasm-instantiate');
    });
    return {}; // no exports yet; we'll fill them in later
    var instance;
    try {
      instance = new webassembly.instance(new webassembly.module(getbinary()), info)
    } catch (e) {
      module['printerr']('failed to compile wasm module: ' + e);
      if (e.tostring().indexof('imported memory with incompatible size') >= 0) {
        module['printerr']('memory size incompatibility issues may be due to changing total_memory at runtime to something too large. use allow_memory_growth to allow any size memory (and also make sure not to set total_memory at runtime to something smaller than it was at compile time).');
      }
      return false;
    }
    receiveinstance(instance);
    return exports;
  }

  function dowasmpolyfill(global, env, providedbuffer, method) {
    if (typeof wasmjs !== 'function') {
      module['printerr']('wasmjs not detected - polyfill not bundled?');
      return false;
    }

    // use wasm.js to polyfill and execute code in a wasm interpreter.
    var wasmjs = wasmjs({});

    // xxx don't be confused. module here is in the outside program. wasmjs is the inner wasm-js.cpp.
    wasmjs['outside'] = module; // inside wasm-js.cpp, module['outside'] reaches the outside module.

    // information for the instance of the module.
    wasmjs['info'] = info;

    wasmjs['lookupimport'] = lookupimport;

    assert(providedbuffer === module['buffer']); // we should not even need to pass it as a 3rd arg for wasm, but that's the asm.js way.

    info.global = global;
    info.env = env;

    // polyfill interpreter expects an arraybuffer
    assert(providedbuffer === module['buffer']);
    env['memory'] = providedbuffer;
    assert(env['memory'] instanceof arraybuffer);

    wasmjs['providedtotalmemory'] = module['buffer'].bytelength;

    // prepare to generate wasm, using either asm2wasm or s-exprs
    var code;
    if (method === 'interpret-binary') {
      code = getbinary();
    } else {
      code = module['read'](method == 'interpret-asm2wasm' ? asmjscodefile : wasmtextfile);
    }
    var temp;
    if (method == 'interpret-asm2wasm') {
      temp = wasmjs['_malloc'](code.length + 1);
      wasmjs['writeasciitomemory'](code, temp);
      wasmjs['_load_asm2wasm'](temp);
    } else if (method === 'interpret-s-expr') {
      temp = wasmjs['_malloc'](code.length + 1);
      wasmjs['writeasciitomemory'](code, temp);
      wasmjs['_load_s_expr2wasm'](temp);
    } else if (method === 'interpret-binary') {
      temp = wasmjs['_malloc'](code.length);
      wasmjs['heapu8'].set(code, temp);
      wasmjs['_load_binary2wasm'](temp, code.length);
    } else {
      throw 'what? ' + method;
    }
    wasmjs['_free'](temp);

    wasmjs['_instantiate'](temp);

    if (module['newbuffer']) {
      mergememory(module['newbuffer']);
      module['newbuffer'] = null;
    }

    exports = wasmjs['asmexports'];

    return exports;
  }

  // we may have a preloaded value in module.asm, save it
  module['asmpreload'] = module['asm'];

  // memory growth integration code
  module['reallocbuffer'] = function(size) {
    size = math.ceil(size / wasmpagesize) * wasmpagesize; // round up to wasm page size
    var old = module['buffer'];
    var result = exports['__growwasmmemory'](size / wasmpagesize); // tiny wasm method that just does grow_memory
    if (module["usingwasm"]) {
      if (result !== (-1 | 0)) {
        // success in native wasm memory growth, get the buffer from the memory
        return module['buffer'] = module['wasmmemory'].buffer;
      } else {
        return null;
      }
    } else {
      // in interpreter, we replace module.buffer if we allocate
      return module['buffer'] !== old ? module['buffer'] : null; // if it was reallocated, it changed
    }
  };

  // provide an "asm.js function" for the application, called to "link" the asm.js module. we instantiate
  // the wasm module at that time, and it receives imports and provides exports and so forth, the app
  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.

  module['asm'] = function(global, env, providedbuffer) {
    global = fiximports(global);
    env = fiximports(env);

    // import table
    if (!env['table']) {
      var table_size = module['wasmtablesize'];
      if (table_size === undefined) table_size = 1024; // works in binaryen interpreter at least
      var max_table_size = module['wasmmaxtablesize'];
      if (typeof webassembly === 'object' && typeof webassembly.table === 'function') {
        if (max_table_size !== undefined) {
          env['table'] = new webassembly.table({ initial: table_size, maximum: max_table_size, element: 'anyfunc' });
        } else {
          env['table'] = new webassembly.table({ initial: table_size, element: 'anyfunc' });
        }
      } else {
        env['table'] = new array(table_size); // works in binaryen interpreter at least
      }
      module['wasmtable'] = env['table'];
    }

    if (!env['memorybase']) {
      env['memorybase'] = module['static_base']; // tell the memory segments where to place themselves
    }
    if (!env['tablebase']) {
      env['tablebase'] = 0; // table starts at 0 by default, in dynamic linking this will change
    }

    // try the methods. each should return the exports if it succeeded

    var exports;
    var methods = method.split(',');

    for (var i = 0; i < methods.length; i++) {
      var curr = methods[i];

      module['printerr']('trying binaryen method: ' + curr);

      if (curr === 'native-wasm') {
        if (exports = donativewasm(global, env, providedbuffer)) break;
      } else if (curr === 'asmjs') {
        if (exports = dojustasm(global, env, providedbuffer)) break;
      } else if (curr === 'interpret-asm2wasm' || curr === 'interpret-s-expr' || curr === 'interpret-binary') {
        if (exports = dowasmpolyfill(global, env, providedbuffer, curr)) break;
      } else {
        throw 'bad method: ' + curr;
      }
    }

    if (!exports) throw 'no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/webassembly#binaryen-methods';

    module['printerr']('binaryen method succeeded.');

    return exports;
  };

  var methodhandler = module['asm']; // note our method handler, as we may modify module['asm'] later
}

integratewasmjs(module);

// === body ===

var asm_consts = [function($0, $1) { { module.printerr('bad name in getprocaddress: ' + [pointer_stringify($0), pointer_stringify($1)]); } }];

function _emscripten_asm_const_iii(code, a0, a1) {
 return asm_consts[code](a0, a1);
}



static_base = 1024;

statictop = runtime.alignmemory(static_base, 16) + 1609424;
  /* global initializers */  __atinit__.push({ func: function() { __global__sub_i_runtime_video_0_cpp() } }, { func: function() { ___cxx_global_var_init_13() } }, { func: function() { __global__sub_i_swcollision_cpp() } }, { func: function() { __global__sub_i_swintercollision_cpp() } }, { func: function() { __global__sub_i_swselfcollision_cpp() } }, { func: function() { __global__sub_i_swsolverkernel_cpp() } }, { func: function() { __global__sub_i_runtime_cloth_0_cpp() } }, { func: function() { __global__sub_i_glslgpuprogramgles_cpp() } }, { func: function() { __global__sub_i_spriterendererjobs_cpp() } }, { func: function() { __global__sub_i_runtime_2d_spriteatlas_0_cpp() } }, { func: function() { ___cxx_global_var_init_5_1260() } }, { func: function() { __global__sub_i_runtime_assetbundles_1_cpp() } }, { func: function() { __global__sub_i_runtime_baseclasses_2_cpp() } }, { func: function() { ___cxx_global_var_init_74() } }, { func: function() { ___cxx_global_var_init_75() } }, { func: function() { __global__sub_i_runtime_camera_0_cpp() } }, { func: function() { __global__sub_i_runtime_camera_1_cpp() } }, { func: function() { __global__sub_i_runtime_camera_3_cpp() } }, { func: function() { __global__sub_i_runtime_camera_5_cpp() } }, { func: function() { __global__sub_i_runtime_camera_6_cpp() } }, { func: function() { ___cxx_global_var_init_18() } }, { func: function() { __global__sub_i_runtime_camera_renderlayers_0_cpp() } }, { func: function() { __global__sub_i_runtime_camera_renderloops_0_cpp() } }, { func: function() { __global__sub_i_runtime_camera_renderloops_1_cpp() } }, { func: function() { __global__sub_i_runtime_core_callbacks_0_cpp() } }, { func: function() { __global__sub_i_runtime_geometry_0_cpp() } }, { func: function() { __global__sub_i_runtime_graphics_6_cpp() } }, { func: function() { __global__sub_i_runtime_graphics_7_cpp() } }, { func: function() { __global__sub_i_runtime_graphics_billboard_0_cpp() } }, { func: function() { __global__sub_i_runtime_graphics_mesh_0_cpp() } }, { func: function() { __global__sub_i_runtime_graphics_mesh_2_cpp() } }, { func: function() { __global__sub_i_runtime_input_0_cpp() } }, { func: function() { __global__sub_i_runtime_math_random_0_cpp() } }, { func: function() { __global__sub_i_runtime_misc_0_cpp() } }, { func: function() { ___cxx_global_var_init_66() } }, { func: function() { __global__sub_i_runtime_scenemanager_0_cpp() } }, { func: function() { __global__sub_i_runtime_shaders_0_cpp() } }, { func: function() { __global__sub_i_runtime_shaders_shaderimpl_0_cpp() } }, { func: function() { __global__sub_i_runtime_utilities_0_cpp() } }, { func: function() { __global__sub_i_runtime_utilities_4_cpp() } }, { func: function() { __global__sub_i_runtime_utilities_6_cpp() } }, { func: function() { __global__sub_i_modules_profiler_public_0_cpp() } }, { func: function() { __global__sub_i_modules_profiler_runtime_0_cpp() } }, { func: function() { __global__sub_i_runtime_gfxdevice_1_cpp() } }, { func: function() { __global__sub_i_runtime_gfxdevice_2_cpp() } }, { func: function() { __global__sub_i_runtime_scripting_0_cpp() } }, { func: function() { __global__sub_i_runtime_scripting_2_cpp() } }, { func: function() { __global__sub_i_platformdependent_webgl_source_0_cpp() } }, { func: function() { __global__sub_i_platformdependent_webgl_source_1_cpp() } }, { func: function() { ___cxx_global_var_init_7_2511() } }, { func: function() { __global__sub_i_runtime_imgui_0_cpp() } }, { func: function() { __global__sub_i_runtime_particlesystem_modules_3_cpp() } }, { func: function() { __global__sub_i_runtime_particlesystem_modules_5_cpp() } }, { func: function() { __global__sub_i_pxsfluiddynamics_cpp() } }, { func: function() { __global__sub_i_cmeventprofiler_cpp() } }, { func: function() { __global__sub_i_runtime_dynamics_0_cpp() } }, { func: function() { __global__sub_i_runtime_dynamics_2_cpp() } }, { func: function() { ___cxx_global_var_init_128() } }, { func: function() { __global__sub_i_modules_terrain_public_0_cpp() } }, { func: function() { __global__sub_i_modules_terrain_public_1_cpp() } }, { func: function() { __global__sub_i_modules_terrain_public_2_cpp() } }, { func: function() { __global__sub_i_modules_terrain_vr_0_cpp() } }, { func: function() { __global__sub_i_modules_tilemap_0_cpp() } }, { func: function() { __global__sub_i_modules_tilemap_public_0_cpp() } }, { func: function() { __global__sub_i_runtime_ui_0_cpp() } }, { func: function() { __global__sub_i_umbra_cpp() } }, { func: function() { __global__sub_i_unityadssettings_cpp() } }, { func: function() { __global__sub_i_runtime_vr_1_cpp() } }, { func: function() { __global__sub_i_artifacts_generated_webgl_modules_vr_0_cpp() } }, { func: function() { __global__sub_i_class_cpp() } }, { func: function() { __global__sub_i_metadatacache_cpp() } }, { func: function() { __global__sub_i_runtime_cpp() } }, { func: function() { __global__sub_i_file_cpp() } }, { func: function() { __global__sub_i_reflection_cpp() } }, { func: function() { __global__sub_i_arraymetadata_cpp() } }, { func: function() { __global__sub_i_thread_cpp() } }, { func: function() { __global__sub_i_assembly_cpp() } }, { func: function() { __global__sub_i_rcw_cpp() } }, { func: function() { __global__sub_i_image_cpp() } }, { func: function() { __global__sub_i_genericmetadata_cpp() } }, { func: function() { __global__sub_i_gchandle_cpp() } }, { func: function() { __global__sub_i_socket_cpp() } }, { func: function() { __global__sub_i_garbagecollector_cpp() } }, { func: function() { __global__sub_i_stacktrace_cpp() } }, { func: function() { __global__sub_i_appdomain_cpp() } }, { func: function() { __global__sub_i_console_cpp() } }, { func: function() { __global__sub_i_thread_cpp_41939() } }, { func: function() { __global__sub_i_libraryloader_cpp() } }, { func: function() { __global__sub_i_threadimpl_cpp() } }, { func: function() { __global__sub_i_genericmethod_cpp() } }, { func: function() { __global__sub_i_string_cpp() } }, { func: function() { __global__sub_i_interlocked_cpp() } }, { func: function() { __global__sub_i_assembly_cpp_42452() } }, { func: function() { __global__sub_i_memorymappedfile_cpp() } }, { func: function() { __global__sub_i_runtime_cpp_42981() } }, { func: function() { __global__sub_i_il2cppcoderegistration_cpp() } }, { func: function() { __global__sub_i_environment_cpp() } }, { func: function() { __global__sub_i_nativedelegatemethodcache_cpp() } }, { func: function() { __global__sub_i_error_cpp() } }, { func: function() { __global__sub_i_path_cpp() } });
  

memoryinitializer = module["wasmjsmethod"].indexof("asmjs") >= 0 || module["wasmjsmethod"].indexof("interpret-asm2wasm") >= 0 ? "build.js.mem" : null;




var static_bump = 1609424;
module["static_base"] = static_base;
module["static_bump"] = static_bump;

/* no memory initializer */
var tempdoubleptr = statictop; statictop += 16;

function copytempfloat(ptr) { // functions, because inlining this code increases code size too much

  heap8[tempdoubleptr] = heap8[ptr];

  heap8[tempdoubleptr+1] = heap8[ptr+1];

  heap8[tempdoubleptr+2] = heap8[ptr+2];

  heap8[tempdoubleptr+3] = heap8[ptr+3];

}

function copytempdouble(ptr) {

  heap8[tempdoubleptr] = heap8[ptr];

  heap8[tempdoubleptr+1] = heap8[ptr+1];

  heap8[tempdoubleptr+2] = heap8[ptr+2];

  heap8[tempdoubleptr+3] = heap8[ptr+3];

  heap8[tempdoubleptr+4] = heap8[ptr+4];

  heap8[tempdoubleptr+5] = heap8[ptr+5];

  heap8[tempdoubleptr+6] = heap8[ptr+6];

  heap8[tempdoubleptr+7] = heap8[ptr+7];

}

// {{pre_library}}


  
  var gl={counter:1,lasterror:0,buffers:[],mappedbuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:[],currentcontext:null,offscreencanvases:{},timerqueriesext:[],queries:[],samplers:[],transformfeedbacks:[],syncs:[],bytesizebytyperoot:5120,bytesizebytype:[1,1,2,2,4,4,4,2,3,4,8],programinfos:{},stringcache:{},stringicache:{},packalignment:4,unpackalignment:4,init:function () {
        gl.minitempbuffer = new float32array(gl.mini_temp_buffer_size);
        for (var i = 0; i < gl.mini_temp_buffer_size; i++) {
          gl.minitempbufferviews[i] = gl.minitempbuffer.subarray(0, i+1);
        }
      },recorderror:function recorderror(errorcode) {
        if (!gl.lasterror) {
          gl.lasterror = errorcode;
        }
      },getnewid:function (table) {
        var ret = gl.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },mini_temp_buffer_size:256,minitempbuffer:null,minitempbufferviews:[0],getsource:function (shader, count, string, length) {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var frag;
          if (length) {
            var len = heap32[(((length)+(i*4))>>2)];
            if (len < 0) {
              frag = pointer_stringify(heap32[(((string)+(i*4))>>2)]);
            } else {
              frag = pointer_stringify(heap32[(((string)+(i*4))>>2)], len);
            }
          } else {
            frag = pointer_stringify(heap32[(((string)+(i*4))>>2)]);
          }
          source += frag;
        }
        return source;
      },createcontext:function (canvas, webglcontextattributes) {
        if (typeof webglcontextattributes['majorversion'] === 'undefined' && typeof webglcontextattributes['minorversion'] === 'undefined') {
          webglcontextattributes['majorversion'] = 2;
          webglcontextattributes['minorversion'] = 0;
        }
        var ctx;
        var errorinfo = '?';
        function oncontextcreationerror(event) {
          errorinfo = event.statusmessage || errorinfo;
        }
        try {
          canvas.addeventlistener('webglcontextcreationerror', oncontextcreationerror, false);
          try {
            if (webglcontextattributes['majorversion'] == 1 && webglcontextattributes['minorversion'] == 0) {
              ctx = canvas.getcontext("webgl", webglcontextattributes) || canvas.getcontext("experimental-webgl", webglcontextattributes);
            } else if (webglcontextattributes['majorversion'] == 2 && webglcontextattributes['minorversion'] == 0) {
              ctx = canvas.getcontext("webgl2", webglcontextattributes) || canvas.getcontext("experimental-webgl2", webglcontextattributes);
            } else {
              throw 'unsupported webgl context version ' + majorversion + '.' + minorversion + '!'
            }
          } finally {
            canvas.removeeventlistener('webglcontextcreationerror', oncontextcreationerror, false);
          }
          if (!ctx) throw ':(';
        } catch (e) {
          module.print('could not create canvas: ' + [errorinfo, e, json.stringify(webglcontextattributes)]);
          return 0;
        }
        // possible gl_debug entry point: ctx = wrapdebuggl(ctx);
  
        if (!ctx) return 0;
        return gl.registercontext(ctx, webglcontextattributes);
      },registercontext:function (ctx, webglcontextattributes) {
        var handle = gl.getnewid(gl.contexts);
        var context = {
          handle: handle,
          attributes: webglcontextattributes,
          version: webglcontextattributes['majorversion'],
          glctx: ctx
        };
        // store the created context object so that we can access the context given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.glctxobject = context;
        gl.contexts[handle] = context;
        if (typeof webglcontextattributes['enableextensionsbydefault'] === 'undefined' || webglcontextattributes['enableextensionsbydefault']) {
          gl.initextensions(context);
        }
        return handle;
      },makecontextcurrent:function (contexthandle) {
        var context = gl.contexts[contexthandle];
        if (!context) return false;
        glctx = module.ctx = context.glctx; // active webgl context object.
        gl.currentcontext = context; // active emscripten gl layer context object.
        return true;
      },getcontext:function (contexthandle) {
        return gl.contexts[contexthandle];
      },deletecontext:function (contexthandle) {
        if (gl.currentcontext === gl.contexts[contexthandle]) gl.currentcontext = null;
        if (typeof jsevents === 'object') jsevents.removeallhandlersontarget(gl.contexts[contexthandle].glctx.canvas); // release all js event handlers on the dom element that the gl context is associated with since the context is now deleted.
        if (gl.contexts[contexthandle] && gl.contexts[contexthandle].glctx.canvas) gl.contexts[contexthandle].glctx.canvas.glctxobject = undefined; // make sure the canvas object no longer refers to the context object so there are no gc surprises.
        gl.contexts[contexthandle] = null;
      },initextensions:function (context) {
        // if this function is called without a specific context object, init the extensions of the currently active context.
        if (!context) context = gl.currentcontext;
  
        if (context.initextensionsdone) return;
        context.initextensionsdone = true;
  
        var glctx = context.glctx;
  
        context.maxvertexattribs = glctx.getparameter(glctx.max_vertex_attribs);
  
        // detect the presence of a few extensions manually, this gl interop layer itself will need to know if they exist. 
  
        if (context.version < 2) {
          // extension available from firefox 26 and google chrome 30
          var instancedarraysext = glctx.getextension('angle_instanced_arrays');
          if (instancedarraysext) {
            glctx['vertexattribdivisor'] = function(index, divisor) { instancedarraysext['vertexattribdivisorangle'](index, divisor); };
            glctx['drawarraysinstanced'] = function(mode, first, count, primcount) { instancedarraysext['drawarraysinstancedangle'](mode, first, count, primcount); };
            glctx['drawelementsinstanced'] = function(mode, count, type, indices, primcount) { instancedarraysext['drawelementsinstancedangle'](mode, count, type, indices, primcount); };
          }
  
          // extension available from firefox 25 and webkit
          var vaoext = glctx.getextension('oes_vertex_array_object');
          if (vaoext) {
            glctx['createvertexarray'] = function() { return vaoext['createvertexarrayoes'](); };
            glctx['deletevertexarray'] = function(vao) { vaoext['deletevertexarrayoes'](vao); };
            glctx['bindvertexarray'] = function(vao) { vaoext['bindvertexarrayoes'](vao); };
            glctx['isvertexarray'] = function(vao) { return vaoext['isvertexarrayoes'](vao); };
          }
  
          var drawbuffersext = glctx.getextension('webgl_draw_buffers');
          if (drawbuffersext) {
            glctx['drawbuffers'] = function(n, bufs) { drawbuffersext['drawbufferswebgl'](n, bufs); };
          }
        }
  
        glctx.disjointtimerqueryext = glctx.getextension("ext_disjoint_timer_query");
  
        // these are the 'safe' feature-enabling extensions that don't add any performance impact related to e.g. debugging, and
        // should be enabled by default so that client gles2/gl code will not need to go through extra hoops to get its stuff working.
        // as new extensions are ratified at http://www.khronos.org/registry/webgl/extensions/ , feel free to add your new extensions
        // here, as long as they don't produce a performance impact for users that might not be using those extensions.
        // e.g. debugging-related extensions should probably be off by default.
        var automaticallyenabledextensions = [ "oes_texture_float", "oes_texture_half_float", "oes_standard_derivatives",
                                               "oes_vertex_array_object", "webgl_compressed_texture_s3tc", "webgl_depth_texture",
                                               "oes_element_index_uint", "ext_texture_filter_anisotropic", "angle_instanced_arrays",
                                               "oes_texture_float_linear", "oes_texture_half_float_linear", "webgl_compressed_texture_atc",
                                               "webgl_compressed_texture_pvrtc", "ext_color_buffer_half_float", "webgl_color_buffer_float",
                                               "ext_frag_depth", "ext_srgb", "webgl_draw_buffers", "webgl_shared_resources",
                                               "ext_shader_texture_lod", "ext_color_buffer_float"];
  
        function shouldenableautomatically(extension) {
          var ret = false;
          automaticallyenabledextensions.foreach(function(include) {
            if (ext.indexof(include) != -1) {
              ret = true;
            }
          });
          return ret;
        }
  
        var exts = glctx.getsupportedextensions();
        if (exts && exts.length > 0) {
          glctx.getsupportedextensions().foreach(function(ext) {
            if (automaticallyenabledextensions.indexof(ext) != -1) {
              glctx.getextension(ext); // calling .getextension enables that extension permanently, no need to store the return value to be enabled.
            }
          });
        }
      },populateuniformtable:function (program) {
        var p = gl.programs[program];
        gl.programinfos[program] = {
          uniforms: {},
          maxuniformlength: 0, // this is eagerly computed below, since we already enumerate all uniforms anyway.
          maxattributelength: -1, // this is lazily computed and cached, computed when/if first asked, "-1" meaning not computed yet.
          maxuniformblocknamelength: -1 // lazily computed as well
        };
  
        var ptable = gl.programinfos[program];
        var utable = ptable.uniforms;
        // a program's uniform table maps the string name of an uniform to an integer location of that uniform.
        // the global gl.uniforms map maps integer locations to webgluniformlocations.
        var numuniforms = glctx.getprogramparameter(p, glctx.active_uniforms);
        for (var i = 0; i < numuniforms; ++i) {
          var u = glctx.getactiveuniform(p, i);
  
          var name = u.name;
          ptable.maxuniformlength = math.max(ptable.maxuniformlength, name.length+1);
  
          // strip off any trailing array specifier we might have got, e.g. "[0]".
          if (name.indexof(']', name.length-1) !== -1) {
            var ls = name.lastindexof('[');
            name = name.slice(0, ls);
          }
  
          // optimize memory usage slightly: if we have an array of uniforms, e.g. 'vec3 colors[3];', then 
          // only store the string 'colors' in utable, and 'colors[0]', 'colors[1]' and 'colors[2]' will be parsed as 'colors'+i.
          // note that for the gl.uniforms table, we still need to fetch the all webgluniformlocations for all the indices.
          var loc = glctx.getuniformlocation(p, name);
          if (loc != null)
          {
            var id = gl.getnewid(gl.uniforms);
            utable[name] = [u.size, id];
            gl.uniforms[id] = loc;
  
            for (var j = 1; j < u.size; ++j) {
              var n = name + '['+j+']';
              loc = glctx.getuniformlocation(p, n);
              id = gl.getnewid(gl.uniforms);
  
              gl.uniforms[id] = loc;
            }
          }
        }
      }};function _emscripten_glstencilmaskseparate(x0, x1) { glctx['stencilmaskseparate'](x0, x1) }

   
  module["_pthread_mutex_lock"] = _pthread_mutex_lock;

  
  
  function _free() {
  }
  module["_free"] = _free;function ___cxa_free_exception(ptr) {
      try {
        return _free(ptr);
      } catch(e) { // xxx fixme
      }
    }
  
  var exceptions={last:0,caught:[],infos:{},deadjust:function (adjusted) {
        if (!adjusted || exceptions.infos[adjusted]) return adjusted;
        for (var ptr in exceptions.infos) {
          var info = exceptions.infos[ptr];
          if (info.adjusted === adjusted) {
            return ptr;
          }
        }
        return adjusted;
      },addref:function (ptr) {
        if (!ptr) return;
        var info = exceptions.infos[ptr];
        info.refcount++;
      },decref:function (ptr) {
        if (!ptr) return;
        var info = exceptions.infos[ptr];
        assert(info.refcount > 0);
        info.refcount--;
        // a rethrown exception can reach refcount 0; it must not be discarded
        // its next handler will clear the rethrown flag and addref it, prior to
        // final decref and destruction here
        if (info.refcount === 0 && !info.rethrown) {
          if (info.destructor) {
            module['dyncall_vi'](info.destructor, ptr);
          }
          delete exceptions.infos[ptr];
          ___cxa_free_exception(ptr);
        }
      },clearref:function (ptr) {
        if (!ptr) return;
        var info = exceptions.infos[ptr];
        info.refcount = 0;
      }};function ___cxa_end_catch() {
      // clear state flag.
      asm['setthrew'](0);
      // call destructor if one is registered then clear it.
      var ptr = exceptions.caught.pop();
      if (ptr) {
        exceptions.decref(exceptions.deadjust(ptr));
        exceptions.last = 0; // xxx in decref?
      }
    }

  function _emscripten_glstencilfunc(x0, x1, x2) { glctx['stencilfunc'](x0, x1, x2) }

  function _glframebufferrenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
      glctx.framebufferrenderbuffer(target, attachment, renderbuffertarget,
                                         gl.renderbuffers[renderbuffer]);
    }

  function _emscripten_glvertexpointer(){ throw 'legacy gl function (glvertexpointer) called. if you want legacy gl emulation, you need to compile with -s legacy_gl_emulation=1 to enable legacy gl emulation.'; }

  function _emscripten_gluniform3iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 3;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform3iv(location, value);
    }

  function _glcompressedtexsubimage3d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data) {
      var heapview;
      if (data) {
        heapview = heapu8.subarray((data),(data+imagesize));
      } else {
        heapview = null;
      }
      glctx['compressedtexsubimage2d'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, heapview);
    }

  var _llvm_pow_f32=math_pow;

  function _glbindsampler(unit, sampler) {
      glctx['bindsampler'](unit, sampler ? gl.samplers[sampler] : null);
    }

  function _glprogramparameteri(program, pname, value) {
      gl.recorderror(0x0500/*gl_invalid_enum*/);
    }

  function _emscripten_gltexparameterf(x0, x1, x2) { glctx['texparameterf'](x0, x1, x2) }

  
  var jsevents={keyevent:0,mouseevent:0,wheelevent:0,uievent:0,focusevent:0,deviceorientationevent:0,devicemotionevent:0,fullscreenchangeevent:0,pointerlockchangeevent:0,visibilitychangeevent:0,touchevent:0,lastgamepadstate:null,lastgamepadstateframe:null,previousfullscreenelement:null,previousscreenx:null,previousscreeny:null,removeeventlistenersregistered:false,registerremoveeventlisteners:function () {
        if (!jsevents.removeeventlistenersregistered) {
        __atexit__.push(function() {
            for(var i = jsevents.eventhandlers.length-1; i >= 0; --i) {
              jsevents._removehandler(i);
            }
           });
          jsevents.removeeventlistenersregistered = true;
        }
      },findeventtarget:function (target) {
        if (target) {
          if (typeof target == "number") {
            target = pointer_stringify(target);
          }
          if (target == '#window') return window;
          else if (target == '#document') return document;
          else if (target == '#screen') return window.screen;
          else if (target == '#canvas') return module['canvas'];
  
          if (typeof target == 'string') return document.getelementbyid(target);
          else return target;
        } else {
          // the sensible target varies between events, but use window as the default
          // since dom events mostly can default to that. specific callback registrations
          // override their own defaults.
          return window;
        }
      },deferredcalls:[],defercall:function (targetfunction, precedence, argslist) {
        function arrayshaveequalcontent(arra, arrb) {
          if (arra.length != arrb.length) return false;
  
          for(var i in arra) {
            if (arra[i] != arrb[i]) return false;
          }
          return true;
        }
        // test if the given call was already queued, and if so, don't add it again.
        for(var i in jsevents.deferredcalls) {
          var call = jsevents.deferredcalls[i];
          if (call.targetfunction == targetfunction && arrayshaveequalcontent(call.argslist, argslist)) {
            return;
          }
        }
        jsevents.deferredcalls.push({
          targetfunction: targetfunction,
          precedence: precedence,
          argslist: argslist
        });
  
        jsevents.deferredcalls.sort(function(x,y) { return x.precedence < y.precedence; });
      },removedeferredcalls:function (targetfunction) {
        for(var i = 0; i < jsevents.deferredcalls.length; ++i) {
          if (jsevents.deferredcalls[i].targetfunction == targetfunction) {
            jsevents.deferredcalls.splice(i, 1);
            --i;
          }
        }
      },canperformeventhandlerrequests:function () {
        return jsevents.ineventhandler && jsevents.currenteventhandler.allowsdeferredcalls;
      },rundeferredcalls:function () {
        if (!jsevents.canperformeventhandlerrequests()) {
          return;
        }
        for(var i = 0; i < jsevents.deferredcalls.length; ++i) {
          var call = jsevents.deferredcalls[i];
          jsevents.deferredcalls.splice(i, 1);
          --i;
          call.targetfunction.apply(this, call.argslist);
        }
      },ineventhandler:0,currenteventhandler:null,eventhandlers:[],isinternetexplorer:function () { return navigator.useragent.indexof('msie') !== -1 || navigator.appversion.indexof('trident/') > 0; },removeallhandlersontarget:function (target, eventtypestring) {
        for(var i = 0; i < jsevents.eventhandlers.length; ++i) {
          if (jsevents.eventhandlers[i].target == target && 
            (!eventtypestring || eventtypestring == jsevents.eventhandlers[i].eventtypestring)) {
             jsevents._removehandler(i--);
           }
        }
      },_removehandler:function (i) {
        var h = jsevents.eventhandlers[i];
        h.target.removeeventlistener(h.eventtypestring, h.eventlistenerfunc, h.usecapture);
        jsevents.eventhandlers.splice(i, 1);
      },registerorremovehandler:function (eventhandler) {
        var jseventhandler = function jseventhandler(event) {
          // increment nesting count for the event handler.
          ++jsevents.ineventhandler;
          jsevents.currenteventhandler = eventhandler;
          // process any old deferred calls the user has placed.
          jsevents.rundeferredcalls();
          // process the actual event, calls back to user c code handler.
          eventhandler.handlerfunc(event);
          // process any new deferred calls that were placed right now from this event handler.
          jsevents.rundeferredcalls();
          // out of event handler - restore nesting count.
          --jsevents.ineventhandler;
        }
        
        if (eventhandler.callbackfunc) {
          eventhandler.eventlistenerfunc = jseventhandler;
          eventhandler.target.addeventlistener(eventhandler.eventtypestring, jseventhandler, eventhandler.usecapture);
          jsevents.eventhandlers.push(eventhandler);
          jsevents.registerremoveeventlisteners();
        } else {
          for(var i = 0; i < jsevents.eventhandlers.length; ++i) {
            if (jsevents.eventhandlers[i].target == eventhandler.target
             && jsevents.eventhandlers[i].eventtypestring == eventhandler.eventtypestring) {
               jsevents._removehandler(i--);
             }
          }
        }
      },registerkeyeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.keyevent) {
          jsevents.keyevent = _malloc( 164 );
        }
        var handlerfunc = function(event) {
          var e = event || window.event;
          stringtoutf8(e.key ? e.key : "", jsevents.keyevent + 0, 32);
          stringtoutf8(e.code ? e.code : "", jsevents.keyevent + 32, 32);
          heap32[(((jsevents.keyevent)+(64))>>2)]=e.location;
          heap32[(((jsevents.keyevent)+(68))>>2)]=e.ctrlkey;
          heap32[(((jsevents.keyevent)+(72))>>2)]=e.shiftkey;
          heap32[(((jsevents.keyevent)+(76))>>2)]=e.altkey;
          heap32[(((jsevents.keyevent)+(80))>>2)]=e.metakey;
          heap32[(((jsevents.keyevent)+(84))>>2)]=e.repeat;
          stringtoutf8(e.locale ? e.locale : "", jsevents.keyevent + 88, 32);
          stringtoutf8(e.char ? e.char : "", jsevents.keyevent + 120, 32);
          heap32[(((jsevents.keyevent)+(152))>>2)]=e.charcode;
          heap32[(((jsevents.keyevent)+(156))>>2)]=e.keycode;
          heap32[(((jsevents.keyevent)+(160))>>2)]=e.which;
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.keyevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: jsevents.isinternetexplorer() ? false : true, // msie doesn't allow fullscreen and pointerlock requests from key handlers, others do.
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },getboundingclientrectorzeros:function (target) {
        return target.getboundingclientrect ? target.getboundingclientrect() : { left: 0, top: 0 };
      },fillmouseeventdata:function (eventstruct, e, target) {
        heapf64[((eventstruct)>>3)]=jsevents.tick();
        heap32[(((eventstruct)+(8))>>2)]=e.screenx;
        heap32[(((eventstruct)+(12))>>2)]=e.screeny;
        heap32[(((eventstruct)+(16))>>2)]=e.clientx;
        heap32[(((eventstruct)+(20))>>2)]=e.clienty;
        heap32[(((eventstruct)+(24))>>2)]=e.ctrlkey;
        heap32[(((eventstruct)+(28))>>2)]=e.shiftkey;
        heap32[(((eventstruct)+(32))>>2)]=e.altkey;
        heap32[(((eventstruct)+(36))>>2)]=e.metakey;
        heap16[(((eventstruct)+(40))>>1)]=e.button;
        heap16[(((eventstruct)+(42))>>1)]=e.buttons;
        heap32[(((eventstruct)+(44))>>2)]=e["movementx"] || e["mozmovementx"] || e["webkitmovementx"] || (e.screenx-jsevents.previousscreenx);
        heap32[(((eventstruct)+(48))>>2)]=e["movementy"] || e["mozmovementy"] || e["webkitmovementy"] || (e.screeny-jsevents.previousscreeny);
  
        if (module['canvas']) {
          var rect = module['canvas'].getboundingclientrect();
          heap32[(((eventstruct)+(60))>>2)]=e.clientx - rect.left;
          heap32[(((eventstruct)+(64))>>2)]=e.clienty - rect.top;
        } else { // canvas is not initialized, return 0.
          heap32[(((eventstruct)+(60))>>2)]=0;
          heap32[(((eventstruct)+(64))>>2)]=0;
        }
        if (target) {
          var rect = jsevents.getboundingclientrectorzeros(target);
          heap32[(((eventstruct)+(52))>>2)]=e.clientx - rect.left;
          heap32[(((eventstruct)+(56))>>2)]=e.clienty - rect.top;        
        } else { // no specific target passed, return 0.
          heap32[(((eventstruct)+(52))>>2)]=0;
          heap32[(((eventstruct)+(56))>>2)]=0;
        }
        jsevents.previousscreenx = e.screenx;
        jsevents.previousscreeny = e.screeny;
      },registermouseeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.mouseevent) {
          jsevents.mouseevent = _malloc( 72 );
        }
        target = jsevents.findeventtarget(target);
        var handlerfunc = function(event) {
          var e = event || window.event;
          jsevents.fillmouseeventdata(jsevents.mouseevent, e, target);
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.mouseevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: eventtypestring != 'mousemove' && eventtypestring != 'mouseenter' && eventtypestring != 'mouseleave', // mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        // in ie, mousedown events don't either allow deferred calls to be run!
        if (jsevents.isinternetexplorer() && eventtypestring == 'mousedown') eventhandler.allowsdeferredcalls = false;
        jsevents.registerorremovehandler(eventhandler);
      },registerwheeleventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.wheelevent) {
          jsevents.wheelevent = _malloc( 104 );
        }
        target = jsevents.findeventtarget(target);
        // the dom level 3 events spec event 'wheel'
        var wheelhandlerfunc = function(event) {
          var e = event || window.event;
          jsevents.fillmouseeventdata(jsevents.wheelevent, e, target);
          heapf64[(((jsevents.wheelevent)+(72))>>3)]=e["deltax"];
          heapf64[(((jsevents.wheelevent)+(80))>>3)]=e["deltay"];
          heapf64[(((jsevents.wheelevent)+(88))>>3)]=e["deltaz"];
          heap32[(((jsevents.wheelevent)+(96))>>2)]=e["deltamode"];
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.wheelevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
        // the 'mousewheel' event as implemented in safari 6.0.5
        var mousewheelhandlerfunc = function(event) {
          var e = event || window.event;
          jsevents.fillmouseeventdata(jsevents.wheelevent, e, target);
          heapf64[(((jsevents.wheelevent)+(72))>>3)]=e["wheeldeltax"] || 0;
          heapf64[(((jsevents.wheelevent)+(80))>>3)]=-(e["wheeldeltay"] ? e["wheeldeltay"] : e["wheeldelta"]) /* 1. invert to unify direction with the dom level 3 wheel event. 2. msie does not provide wheeldeltay, so wheeldelta is used as a fallback. */;
          heapf64[(((jsevents.wheelevent)+(88))>>3)]=0 /* not available */;
          heap32[(((jsevents.wheelevent)+(96))>>2)]=0 /* dom_delta_pixel */;
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.wheelevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: true,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: (eventtypestring == 'wheel') ? wheelhandlerfunc : mousewheelhandlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },pagescrollpos:function () {
        if (window.pagexoffset > 0 || window.pageyoffset > 0) {
          return [window.pagexoffset, window.pageyoffset];
        }
        if (typeof document.documentelement.scrollleft !== 'undefined' || typeof document.documentelement.scrolltop !== 'undefined') {
          return [document.documentelement.scrollleft, document.documentelement.scrolltop];
        }
        return [document.body.scrollleft|0, document.body.scrolltop|0];
      },registeruieventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.uievent) {
          jsevents.uievent = _malloc( 36 );
        }
  
        if (eventtypestring == "scroll" && !target) {
          target = document; // by default read scroll events on document rather than window.
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
          if (e.target != target) {
            // never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
            // was targeted. otherwise e.g. if app logs a message in response to a page scroll, the emscripten log
            // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
            // causing a new scroll, etc..
            return;
          }
          var scrollpos = jsevents.pagescrollpos();
          heap32[((jsevents.uievent)>>2)]=e.detail;
          heap32[(((jsevents.uievent)+(4))>>2)]=document.body.clientwidth;
          heap32[(((jsevents.uievent)+(8))>>2)]=document.body.clientheight;
          heap32[(((jsevents.uievent)+(12))>>2)]=window.innerwidth;
          heap32[(((jsevents.uievent)+(16))>>2)]=window.innerheight;
          heap32[(((jsevents.uievent)+(20))>>2)]=window.outerwidth;
          heap32[(((jsevents.uievent)+(24))>>2)]=window.outerheight;
          heap32[(((jsevents.uievent)+(28))>>2)]=scrollpos[0];
          heap32[(((jsevents.uievent)+(32))>>2)]=scrollpos[1];
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.uievent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false, // neither scroll or resize events allow running requests inside them.
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },getnodenamefortarget:function (target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == window.screen) return '#screen';
        return (target && target.nodename) ? target.nodename : '';
      },registerfocuseventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.focusevent) {
          jsevents.focusevent = _malloc( 256 );
        }
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          var nodename = jsevents.getnodenamefortarget(e.target);
          var id = e.target.id ? e.target.id : '';
          stringtoutf8(nodename, jsevents.focusevent + 0, 128);
          stringtoutf8(id, jsevents.focusevent + 128, 128);
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.focusevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },tick:function () {
        if (window['performance'] && window['performance']['now']) return window['performance']['now']();
        else return date.now();
      },registerdeviceorientationeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.deviceorientationevent) {
          jsevents.deviceorientationevent = _malloc( 40 );
        }
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          heapf64[((jsevents.deviceorientationevent)>>3)]=jsevents.tick();
          heapf64[(((jsevents.deviceorientationevent)+(8))>>3)]=e.alpha;
          heapf64[(((jsevents.deviceorientationevent)+(16))>>3)]=e.beta;
          heapf64[(((jsevents.deviceorientationevent)+(24))>>3)]=e.gamma;
          heap32[(((jsevents.deviceorientationevent)+(32))>>2)]=e.absolute;
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.deviceorientationevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },registerdevicemotioneventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.devicemotionevent) {
          jsevents.devicemotionevent = _malloc( 80 );
        }
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          heapf64[((jsevents.deviceorientationevent)>>3)]=jsevents.tick();
          heapf64[(((jsevents.devicemotionevent)+(8))>>3)]=e.acceleration.x;
          heapf64[(((jsevents.devicemotionevent)+(16))>>3)]=e.acceleration.y;
          heapf64[(((jsevents.devicemotionevent)+(24))>>3)]=e.acceleration.z;
          heapf64[(((jsevents.devicemotionevent)+(32))>>3)]=e.accelerationincludinggravity.x;
          heapf64[(((jsevents.devicemotionevent)+(40))>>3)]=e.accelerationincludinggravity.y;
          heapf64[(((jsevents.devicemotionevent)+(48))>>3)]=e.accelerationincludinggravity.z;
          heapf64[(((jsevents.devicemotionevent)+(56))>>3)]=e.rotationrate.alpha;
          heapf64[(((jsevents.devicemotionevent)+(64))>>3)]=e.rotationrate.beta;
          heapf64[(((jsevents.devicemotionevent)+(72))>>3)]=e.rotationrate.gamma;
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.devicemotionevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },screenorientation:function () {
        if (!window.screen) return undefined;
        return window.screen.orientation || window.screen.mozorientation || window.screen.webkitorientation || window.screen.msorientation;
      },fillorientationchangeeventdata:function (eventstruct, e) {
        var orientations  = ["portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary"];
        var orientations2 = ["portrait",         "portrait",           "landscape",         "landscape"];
  
        var orientationstring = jsevents.screenorientation();
        var orientation = orientations.indexof(orientationstring);
        if (orientation == -1) {
          orientation = orientations2.indexof(orientationstring);
        }
  
        heap32[((eventstruct)>>2)]=1 << orientation;
        heap32[(((eventstruct)+(4))>>2)]=window.orientation;
      },registerorientationchangeeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.orientationchangeevent) {
          jsevents.orientationchangeevent = _malloc( 8 );
        }
  
        if (!target) {
          target = window.screen; // orientation events need to be captured from 'window.screen' instead of 'window'
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillorientationchangeeventdata(jsevents.orientationchangeevent, e);
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.orientationchangeevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        if (eventtypestring == "orientationchange" && window.screen.mozorientation !== undefined) {
          eventtypestring = "mozorientationchange";
        }
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },fullscreenenabled:function () {
        return document.fullscreenenabled || document.mozfullscreenenabled || document.webkitfullscreenenabled || document.msfullscreenenabled;
      },fillfullscreenchangeeventdata:function (eventstruct, e) {
        var fullscreenelement = document.fullscreenelement || document.mozfullscreenelement || document.webkitfullscreenelement || document.msfullscreenelement;
        var isfullscreen = !!fullscreenelement;
        heap32[((eventstruct)>>2)]=isfullscreen;
        heap32[(((eventstruct)+(4))>>2)]=jsevents.fullscreenenabled();
        // if transitioning to fullscreen, report info about the element that is now fullscreen.
        // if transitioning to windowed mode, report info about the element that just was fullscreen.
        var reportedelement = isfullscreen ? fullscreenelement : jsevents.previousfullscreenelement;
        var nodename = jsevents.getnodenamefortarget(reportedelement);
        var id = (reportedelement && reportedelement.id) ? reportedelement.id : '';
        stringtoutf8(nodename, eventstruct + 8, 128);
        stringtoutf8(id, eventstruct + 136, 128);
        heap32[(((eventstruct)+(264))>>2)]=reportedelement ? reportedelement.clientwidth : 0;
        heap32[(((eventstruct)+(268))>>2)]=reportedelement ? reportedelement.clientheight : 0;
        heap32[(((eventstruct)+(272))>>2)]=screen.width;
        heap32[(((eventstruct)+(276))>>2)]=screen.height;
        if (isfullscreen) {
          jsevents.previousfullscreenelement = fullscreenelement;
        }
      },registerfullscreenchangeeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.fullscreenchangeevent) {
          jsevents.fullscreenchangeevent = _malloc( 280 );
        }
  
        if (!target) {
          target = document; // fullscreen change events need to be captured from 'document' by default instead of 'window'
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillfullscreenchangeeventdata(jsevents.fullscreenchangeevent, e);
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.fullscreenchangeevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },resizecanvasforfullscreen:function (target, strategy) {
        var restoreoldstyle = __registerrestoreoldstyle(target);
        var csswidth = strategy.softfullscreen ? window.innerwidth : screen.width;
        var cssheight = strategy.softfullscreen ? window.innerheight : screen.height;
        var rect = target.getboundingclientrect();
        var windowedcsswidth = rect.right - rect.left;
        var windowedcssheight = rect.bottom - rect.top;
        var windowedrttwidth = target.width;
        var windowedrttheight = target.height;
  
        if (strategy.scalemode == 3) {
          __setletterbox(target, (cssheight - windowedcssheight) / 2, (csswidth - windowedcsswidth) / 2);
          csswidth = windowedcsswidth;
          cssheight = windowedcssheight;
        } else if (strategy.scalemode == 2) {
          if (csswidth*windowedrttheight < windowedrttwidth*cssheight) {
            var desiredcssheight = windowedrttheight * csswidth / windowedrttwidth;
            __setletterbox(target, (cssheight - desiredcssheight) / 2, 0);
            cssheight = desiredcssheight;
          } else {
            var desiredcsswidth = windowedrttwidth * cssheight / windowedrttheight;
            __setletterbox(target, 0, (csswidth - desiredcsswidth) / 2);
            csswidth = desiredcsswidth;
          }
        }
  
        // if we are adding padding, must choose a background color or otherwise chrome will give the
        // padding a default white color. do it only if user has not customized their own background color.
        if (!target.style.backgroundcolor) target.style.backgroundcolor = 'black';
        // ie11 does the same, but requires the color to be set in the document body.
        if (!document.body.style.backgroundcolor) document.body.style.backgroundcolor = 'black'; // ie11
        // firefox always shows black letterboxes independent of style color.
  
        target.style.width = csswidth + 'px';
        target.style.height = cssheight + 'px';
  
        if (strategy.filteringmode == 1) {
          target.style.imagerendering = 'optimizespeed';
          target.style.imagerendering = '-moz-crisp-edges';
          target.style.imagerendering = '-o-crisp-edges';
          target.style.imagerendering = '-webkit-optimize-contrast';
          target.style.imagerendering = 'optimize-contrast';
          target.style.imagerendering = 'crisp-edges';
          target.style.imagerendering = 'pixelated';
        }
  
        var dpiscale = (strategy.canvasresolutionscalemode == 2) ? window.devicepixelratio : 1;
        if (strategy.canvasresolutionscalemode != 0) {
          target.width = csswidth * dpiscale;
          target.height = cssheight * dpiscale;
          if (target.glctxobject) target.glctxobject.glctx.viewport(0, 0, target.width, target.height);
        }
        return restoreoldstyle;
      },requestfullscreen:function (target, strategy) {
        // emscripten_fullscreen_scale_default + emscripten_fullscreen_canvas_scale_none is a mode where no extra logic is performed to the dom elements.
        if (strategy.scalemode != 0 || strategy.canvasresolutionscalemode != 0) {
          jsevents.resizecanvasforfullscreen(target, strategy);
        }
  
        if (target.requestfullscreen) {
          target.requestfullscreen();
        } else if (target.msrequestfullscreen) {
          target.msrequestfullscreen();
        } else if (target.mozrequestfullscreen) {
          target.mozrequestfullscreen();
        } else if (target.mozrequestfullscreen) {
          target.mozrequestfullscreen();
        } else if (target.webkitrequestfullscreen) {
          target.webkitrequestfullscreen(element.allow_keyboard_input);
        } else {
          if (typeof jsevents.fullscreenenabled() === 'undefined') {
            return -1;
          } else {
            return -3;
          }
        }
  
        if (strategy.canvasresizedcallback) {
          module['dyncall_iiii'](strategy.canvasresizedcallback, 37, 0, strategy.canvasresizedcallbackuserdata);
        }
  
        return 0;
      },fillpointerlockchangeeventdata:function (eventstruct, e) {
        var pointerlockelement = document.pointerlockelement || document.mozpointerlockelement || document.webkitpointerlockelement || document.mspointerlockelement;
        var ispointerlocked = !!pointerlockelement;
        heap32[((eventstruct)>>2)]=ispointerlocked;
        var nodename = jsevents.getnodenamefortarget(pointerlockelement);
        var id = (pointerlockelement && pointerlockelement.id) ? pointerlockelement.id : '';
        stringtoutf8(nodename, eventstruct + 4, 128);
        stringtoutf8(id, eventstruct + 132, 128);
      },registerpointerlockchangeeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.pointerlockchangeevent) {
          jsevents.pointerlockchangeevent = _malloc( 260 );
        }
  
        if (!target) {
          target = document; // pointer lock change events need to be captured from 'document' by default instead of 'window'
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillpointerlockchangeeventdata(jsevents.pointerlockchangeevent, e);
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.pointerlockchangeevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },registerpointerlockerroreventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!target) {
          target = document; // pointer lock events need to be captured from 'document' by default instead of 'window'
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, 0, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },requestpointerlock:function (target) {
        if (target.requestpointerlock) {
          target.requestpointerlock();
        } else if (target.mozrequestpointerlock) {
          target.mozrequestpointerlock();
        } else if (target.webkitrequestpointerlock) {
          target.webkitrequestpointerlock();
        } else if (target.msrequestpointerlock) {
          target.msrequestpointerlock();
        } else {
          // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
          // or if the whole browser just doesn't support the feature.
          if (document.body.requestpointerlock || document.body.mozrequestpointerlock || document.body.webkitrequestpointerlock || document.body.msrequestpointerlock) {
            return -3;
          } else {
            return -1;
          }
        }
        return 0;
      },fillvisibilitychangeeventdata:function (eventstruct, e) {
        var visibilitystates = [ "hidden", "visible", "prerender", "unloaded" ];
        var visibilitystate = visibilitystates.indexof(document.visibilitystate);
  
        heap32[((eventstruct)>>2)]=document.hidden;
        heap32[(((eventstruct)+(4))>>2)]=visibilitystate;
      },registervisibilitychangeeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.visibilitychangeevent) {
          jsevents.visibilitychangeevent = _malloc( 8 );
        }
  
        if (!target) {
          target = document; // visibility change events need to be captured from 'document' by default instead of 'window'
        } else {
          target = jsevents.findeventtarget(target);
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillvisibilitychangeeventdata(jsevents.visibilitychangeevent, e);
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.visibilitychangeevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },registertoucheventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.touchevent) {
          jsevents.touchevent = _malloc( 1684 );
        }
  
        target = jsevents.findeventtarget(target);
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          var touches = {};
          for(var i = 0; i < e.touches.length; ++i) {
            var touch = e.touches[i];
            touches[touch.identifier] = touch;
          }
          for(var i = 0; i < e.changedtouches.length; ++i) {
            var touch = e.changedtouches[i];
            touches[touch.identifier] = touch;
            touch.changed = true;
          }
          for(var i = 0; i < e.targettouches.length; ++i) {
            var touch = e.targettouches[i];
            touches[touch.identifier].ontarget = true;
          }
          
          var ptr = jsevents.touchevent;
          heap32[(((ptr)+(4))>>2)]=e.ctrlkey;
          heap32[(((ptr)+(8))>>2)]=e.shiftkey;
          heap32[(((ptr)+(12))>>2)]=e.altkey;
          heap32[(((ptr)+(16))>>2)]=e.metakey;
          ptr += 20; // advance to the start of the touch array.
          var canvasrect = module['canvas'] ? module['canvas'].getboundingclientrect() : undefined;
          var targetrect = jsevents.getboundingclientrectorzeros(target);
          var numtouches = 0;
          for(var i in touches) {
            var t = touches[i];
            heap32[((ptr)>>2)]=t.identifier;
            heap32[(((ptr)+(4))>>2)]=t.screenx;
            heap32[(((ptr)+(8))>>2)]=t.screeny;
            heap32[(((ptr)+(12))>>2)]=t.clientx;
            heap32[(((ptr)+(16))>>2)]=t.clienty;
            heap32[(((ptr)+(20))>>2)]=t.pagex;
            heap32[(((ptr)+(24))>>2)]=t.pagey;
            heap32[(((ptr)+(28))>>2)]=t.changed;
            heap32[(((ptr)+(32))>>2)]=t.ontarget;
            if (canvasrect) {
              heap32[(((ptr)+(44))>>2)]=t.clientx - canvasrect.left;
              heap32[(((ptr)+(48))>>2)]=t.clienty - canvasrect.top;
            } else {
              heap32[(((ptr)+(44))>>2)]=0;
              heap32[(((ptr)+(48))>>2)]=0;            
            }
            heap32[(((ptr)+(36))>>2)]=t.clientx - targetrect.left;
            heap32[(((ptr)+(40))>>2)]=t.clienty - targetrect.top;
            
            ptr += 52;
  
            if (++numtouches >= 32) {
              break;
            }
          }
          heap32[((jsevents.touchevent)>>2)]=numtouches;
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.touchevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: target,
          allowsdeferredcalls: false, // xxx currently disabled, see bug https://bugzilla.mozilla.org/show_bug.cgi?id=966493
          // once the above bug is resolved, enable the following condition if possible:
          // allowsdeferredcalls: eventtypestring == 'touchstart',
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },fillgamepadeventdata:function (eventstruct, e) {
        heapf64[((eventstruct)>>3)]=e.timestamp;
        for(var i = 0; i < e.axes.length; ++i) {
          heapf64[(((eventstruct+i*8)+(16))>>3)]=e.axes[i];
        }
        for(var i = 0; i < e.buttons.length; ++i) {
          if (typeof(e.buttons[i]) === 'object') {
            heapf64[(((eventstruct+i*8)+(528))>>3)]=e.buttons[i].value;
          } else {
            heapf64[(((eventstruct+i*8)+(528))>>3)]=e.buttons[i];
          }
        }
        for(var i = 0; i < e.buttons.length; ++i) {
          if (typeof(e.buttons[i]) === 'object') {
            heap32[(((eventstruct+i*4)+(1040))>>2)]=e.buttons[i].pressed;
          } else {
            heap32[(((eventstruct+i*4)+(1040))>>2)]=e.buttons[i] == 1.0;
          }
        }
        heap32[(((eventstruct)+(1296))>>2)]=e.connected;
        heap32[(((eventstruct)+(1300))>>2)]=e.index;
        heap32[(((eventstruct)+(8))>>2)]=e.axes.length;
        heap32[(((eventstruct)+(12))>>2)]=e.buttons.length;
        stringtoutf8(e.id, eventstruct + 1304, 64);
        stringtoutf8(e.mapping, eventstruct + 1368, 64);
      },registergamepadeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.gamepadevent) {
          jsevents.gamepadevent = _malloc( 1432 );
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillgamepadeventdata(jsevents.gamepadevent, e.gamepad);
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.gamepadevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: true,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },registerbeforeunloadeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          var confirmationmessage = module['dyncall_iiii'](callbackfunc, eventtypeid, 0, userdata);
          
          if (confirmationmessage) {
            confirmationmessage = pointer_stringify(confirmationmessage);
          }
          if (confirmationmessage) {
            e.preventdefault();
            e.returnvalue = confirmationmessage;
            return confirmationmessage;
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },battery:function () { return navigator.battery || navigator.mozbattery || navigator.webkitbattery; },fillbatteryeventdata:function (eventstruct, e) {
        heapf64[((eventstruct)>>3)]=e.chargingtime;
        heapf64[(((eventstruct)+(8))>>3)]=e.dischargingtime;
        heapf64[(((eventstruct)+(16))>>3)]=e.level;
        heap32[(((eventstruct)+(24))>>2)]=e.charging;
      },registerbatteryeventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!jsevents.batteryevent) {
          jsevents.batteryevent = _malloc( 32 );
        }
  
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          jsevents.fillbatteryeventdata(jsevents.batteryevent, jsevents.battery());
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, jsevents.batteryevent, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      },registerwebgleventcallback:function (target, userdata, usecapture, callbackfunc, eventtypeid, eventtypestring) {
        if (!target) {
          target = module['canvas'];
        }
        var handlerfunc = function(event) {
          var e = event || window.event;
  
          var shouldcancel = module['dyncall_iiii'](callbackfunc, eventtypeid, 0, userdata);
          if (shouldcancel) {
            e.preventdefault();
          }
        };
  
        var eventhandler = {
          target: jsevents.findeventtarget(target),
          allowsdeferredcalls: false,
          eventtypestring: eventtypestring,
          callbackfunc: callbackfunc,
          handlerfunc: handlerfunc,
          usecapture: usecapture
        };
        jsevents.registerorremovehandler(eventhandler);
      }};function _emscripten_webgl_destroy_context(contexthandle) {
      gl.deletecontext(contexthandle);
    }

  
  function emscriptenwebglgetindexed(target, index, data, type) {
      if (!data) {
        // gles2 specification does not specify how to behave if data is a null pointer. since calling this function does not make sense
        // if data == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      var result = glctx['getindexedparameter'](target, index);
      var ret;
      switch (typeof result) {
        case 'boolean':
          ret = result ? 1 : 0;
          break;
        case 'number':
          ret = result;
          break;
        case 'object':
          if (result === null) {
            switch (target) {
              case 0x8c8f: // transform_feedback_buffer_binding
              case 0x8a28: // uniform_buffer_binding
                ret = 0;
                break;
              default: {
                gl.recorderror(0x0500); // gl_invalid_enum
                return;
              }
            }
          } else if (result instanceof webglbuffer) {
            ret = result.name | 0;
          } else {
            gl.recorderror(0x0500); // gl_invalid_enum
            return;
          }
          break;
        default:
          gl.recorderror(0x0500); // gl_invalid_enum
          return;
      }
  
      switch (type) {
        case 'integer64': (tempi64 = [ret>>>0,(tempdouble=ret,(+(math_abs(tempdouble))) >= 1.0 ? (tempdouble > 0.0 ? ((math_min((+(math_floor((tempdouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(math_ceil((tempdouble - +(((~~(tempdouble)))>>>0))/4294967296.0)))))>>>0) : 0)],heap32[((data)>>2)]=tempi64[0],heap32[(((data)+(4))>>2)]=tempi64[1]);    break;
        case 'integer': heap32[((data)>>2)]=ret;    break;
        case 'float':   heapf32[((data)>>2)]=ret;  break;
        case 'boolean': heap8[((data)>>0)]=ret ? 1 : 0; break;
        default: throw 'internal emscriptenwebglgetindexed() error, bad type: ' + type;
      }
    }function _glgetintegeri_v(target, index, data) {
      emscriptenwebglgetindexed(target, index, data, 'integer');
    }

  function _emscripten_gltexparameteri(x0, x1, x2) { glctx['texparameteri'](x0, x1, x2) }

  function _glcompileshader(shader) {
      glctx.compileshader(gl.shaders[shader]);
    }

  
  var ___tm_current=statictop; statictop += 48;;
  
  
  var ___tm_timezone=allocate(intarrayfromstring("gmt"), "i8", alloc_static);
  
  
  var _tzname=statictop; statictop += 16;;
  
  var _daylight=statictop; statictop += 16;;
  
  var _timezone=statictop; statictop += 16;;function _tzset() {
      // todo: use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      heap32[((_timezone)>>2)]=-(new date()).gettimezoneoffset() * 60;
  
      var winter = new date(2000, 0, 1);
      var summer = new date(2000, 6, 1);
      heap32[((_daylight)>>2)]=number(winter.gettimezoneoffset() != summer.gettimezoneoffset());
  
      function extractzone(date) {
        var match = date.totimestring().match(/\(([a-za-z ]+)\)$/);
        return match ? match[1] : "gmt";
      };
      var wintername = extractzone(winter);
      var summername = extractzone(summer);
      var winternameptr = allocate(intarrayfromstring(wintername), 'i8', alloc_normal);
      var summernameptr = allocate(intarrayfromstring(summername), 'i8', alloc_normal);
      if (summer.gettimezoneoffset() < winter.gettimezoneoffset()) {
        // northern hemisphere
        heap32[((_tzname)>>2)]=winternameptr;
        heap32[(((_tzname)+(4))>>2)]=summernameptr;
      } else {
        heap32[((_tzname)>>2)]=summernameptr;
        heap32[(((_tzname)+(4))>>2)]=winternameptr;
      }
    }function _localtime_r(time, tmptr) {
      _tzset();
      var date = new date(heap32[((time)>>2)]*1000);
      heap32[((tmptr)>>2)]=date.getseconds();
      heap32[(((tmptr)+(4))>>2)]=date.getminutes();
      heap32[(((tmptr)+(8))>>2)]=date.gethours();
      heap32[(((tmptr)+(12))>>2)]=date.getdate();
      heap32[(((tmptr)+(16))>>2)]=date.getmonth();
      heap32[(((tmptr)+(20))>>2)]=date.getfullyear()-1900;
      heap32[(((tmptr)+(24))>>2)]=date.getday();
  
      var start = new date(date.getfullyear(), 0, 1);
      var yday = ((date.gettime() - start.gettime()) / (1000 * 60 * 60 * 24))|0;
      heap32[(((tmptr)+(28))>>2)]=yday;
      heap32[(((tmptr)+(36))>>2)]=-(date.gettimezoneoffset() * 60);
  
      // dst is in december in south
      var summeroffset = new date(2000, 6, 1).gettimezoneoffset();
      var winteroffset = start.gettimezoneoffset();
      var dst = (date.gettimezoneoffset() == math.min(winteroffset, summeroffset))|0;
      heap32[(((tmptr)+(32))>>2)]=dst;
  
      var zoneptr = heap32[(((_tzname)+(dst ? runtime.quantum_size : 0))>>2)];
      heap32[(((tmptr)+(40))>>2)]=zoneptr;
  
      return tmptr;
    }function _localtime(time) {
      return _localtime_r(time, ___tm_current);
    }

  function _emscripten_glfrustum() {
  module['printerr']('missing function: emscripten_glfrustum'); abort(-1);
  }

  function _emscripten_glgettexparameterfv(target, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heapf32[((params)>>2)]=glctx.gettexparameter(target, pname);
    }

  function _emscripten_glbindrenderbuffer(target, renderbuffer) {
      glctx.bindrenderbuffer(target, renderbuffer ? gl.renderbuffers[renderbuffer] : null);
    }

  function _glvertexattribipointer(index, size, type, stride, ptr) {
      var cb = gl.currentcontext.clientbuffers[index];
      if (!gl.currarraybuffer) {
        cb.size = size;
        cb.type = type;
        cb.normalized = false;
        cb.stride = stride;
        cb.ptr = ptr;
        cb.clientside = true;
        return;
      }
      cb.clientside = false;
      glctx.vertexattribipointer(index, size, type, stride, ptr);
    }

  
  function __emscripten_sample_gamepad_data() {
      // produce a new gamepad api sample if we are ticking a new game frame, or if not using emscripten_set_main_loop() at all to drive animation.
      if (browser.mainloop.currentframenumber !== jsevents.lastgamepadstateframe || !browser.mainloop.currentframenumber) {
        jsevents.lastgamepadstate = navigator.getgamepads ? navigator.getgamepads() : (navigator.webkitgetgamepads ? navigator.webkitgetgamepads : null);
        jsevents.lastgamepadstateframe = browser.mainloop.currentframenumber;
      }
    }function _emscripten_get_gamepad_status(index, gamepadstate) {
      __emscripten_sample_gamepad_data();
      if (!jsevents.lastgamepadstate) return -1;
  
      // invalid_param is returned on a gamepad index that never was there.
      if (index < 0 || index >= jsevents.lastgamepadstate.length) return -5;
  
      // no_data is returned on a gamepad index that was removed.
      // for previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
      // this is because gamepads must keep their original position in the array.
      // for example, removing the first of two gamepads produces [null/undefined/false, gamepad].
      if (!jsevents.lastgamepadstate[index]) return -7;
  
      jsevents.fillgamepadeventdata(gamepadstate, jsevents.lastgamepadstate[index]);
      return 0;
    }

  
  
  var errno_codes={eperm:1,enoent:2,esrch:3,eintr:4,eio:5,enxio:6,e2big:7,enoexec:8,ebadf:9,echild:10,eagain:11,ewouldblock:11,enomem:12,eacces:13,efault:14,enotblk:15,ebusy:16,eexist:17,exdev:18,enodev:19,enotdir:20,eisdir:21,einval:22,enfile:23,emfile:24,enotty:25,etxtbsy:26,efbig:27,enospc:28,espipe:29,erofs:30,emlink:31,epipe:32,edom:33,erange:34,enomsg:42,eidrm:43,echrng:44,el2nsync:45,el3hlt:46,el3rst:47,elnrng:48,eunatch:49,enocsi:50,el2hlt:51,edeadlk:35,enolck:37,ebade:52,ebadr:53,exfull:54,enoano:55,ebadrqc:56,ebadslt:57,edeadlock:35,ebfont:59,enostr:60,enodata:61,etime:62,enosr:63,enonet:64,enopkg:65,eremote:66,enolink:67,eadv:68,esrmnt:69,ecomm:70,eproto:71,emultihop:72,edotdot:73,ebadmsg:74,enotuniq:76,ebadfd:77,eremchg:78,elibacc:79,elibbad:80,elibscn:81,elibmax:82,elibexec:83,enosys:38,enotempty:39,enametoolong:36,eloop:40,eopnotsupp:95,epfnosupport:96,econnreset:104,enobufs:105,eafnosupport:97,eprototype:91,enotsock:88,enoprotoopt:92,eshutdown:108,econnrefused:111,eaddrinuse:98,econnaborted:103,enetunreach:101,enetdown:100,etimedout:110,ehostdown:112,ehostunreach:113,einprogress:115,ealready:114,edestaddrreq:89,emsgsize:90,eprotonosupport:93,esocktnosupport:94,eaddrnotavail:99,enetreset:102,eisconn:106,enotconn:107,etoomanyrefs:109,eusers:87,edquot:122,estale:116,enotsup:95,enomedium:123,eilseq:84,eoverflow:75,ecanceled:125,enotrecoverable:131,eownerdead:130,estrpipe:86};
  
  var errno_messages={0:"success",1:"not super-user",2:"no such file or directory",3:"no such process",4:"interrupted system call",5:"i/o error",6:"no such device or address",7:"arg list too long",8:"exec format error",9:"bad file number",10:"no children",11:"no more processes",12:"not enough core",13:"permission denied",14:"bad address",15:"block device required",16:"mount device busy",17:"file exists",18:"cross-device link",19:"no such device",20:"not a directory",21:"is a directory",22:"invalid argument",23:"too many open files in system",24:"too many open files",25:"not a typewriter",26:"text file busy",27:"file too large",28:"no space left on device",29:"illegal seek",30:"read only file system",31:"too many links",32:"broken pipe",33:"math arg out of domain of func",34:"math result not representable",35:"file locking deadlock error",36:"file or path name too long",37:"no record locks available",38:"function not implemented",39:"directory not empty",40:"too many symbolic links",42:"no message of desired type",43:"identifier removed",44:"channel number out of range",45:"level 2 not synchronized",46:"level 3 halted",47:"level 3 reset",48:"link number out of range",49:"protocol driver not attached",50:"no csi structure available",51:"level 2 halted",52:"invalid exchange",53:"invalid request descriptor",54:"exchange full",55:"no anode",56:"invalid request code",57:"invalid slot",59:"bad font file fmt",60:"device not a stream",61:"no data (for no delay io)",62:"timer expired",63:"out of streams resources",64:"machine is not on the network",65:"package not installed",66:"the object is remote",67:"the link has been severed",68:"advertise error",69:"srmount error",70:"communication error on send",71:"protocol error",72:"multihop attempted",73:"cross mount point (not really error)",74:"trying to read unreadable message",75:"value too large for defined data type",76:"given log. name not unique",77:"f.d. invalid for this operation",78:"remote address changed",79:"can   access a needed shared lib",80:"accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"attempting to link in too many libs",83:"attempting to exec a shared library",84:"illegal byte sequence",86:"streams pipe error",87:"too many users",88:"socket operation on non-socket",89:"destination address required",90:"message too long",91:"protocol wrong type for socket",92:"protocol not available",93:"unknown protocol",94:"socket type not supported",95:"not supported",96:"protocol family not supported",97:"address family not supported by protocol family",98:"address already in use",99:"address not available",100:"network interface is not configured",101:"network is unreachable",102:"connection reset by network",103:"connection aborted",104:"connection reset by peer",105:"no buffer space available",106:"socket is already connected",107:"socket is not connected",108:"can't send after socket shutdown",109:"too many references",110:"connection timed out",111:"connection refused",112:"host is down",113:"host is unreachable",114:"socket already connected",115:"connection already in progress",116:"stale file handle",122:"quota exceeded",123:"no medium (in tape drive)",125:"operation canceled",130:"previous owner died",131:"state not recoverable"};
  
  function ___seterrno(value) {
      if (module['___errno_location']) heap32[((module['___errno_location']())>>2)]=value;
      return value;
    }
  
  var path={splitpath:function (filename) {
        var splitpathre = /^(\/?|)([\s\s]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitpathre.exec(filename).slice(1);
      },normalizearray:function (parts, allowaboveroot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowaboveroot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isabsolute = path.charat(0) === '/',
            trailingslash = path.substr(-1) === '/';
        // normalize the path
        path = path.normalizearray(path.split('/').filter(function(p) {
          return !!p;
        }), !isabsolute).join('/');
        if (!path && !isabsolute) {
          path = '.';
        }
        if (path && trailingslash) {
          path += '/';
        }
        return (isabsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = path.splitpath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // no dirname whatsoever
          return '.';
        }
        if (dir) {
          // it has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // emscripten return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastslash = path.lastindexof('/');
        if (lastslash === -1) return path;
        return path.substr(lastslash+1);
      },extname:function (path) {
        return path.splitpath(path)[3];
      },join:function () {
        var paths = array.prototype.slice.call(arguments, 0);
        return path.normalize(paths.join('/'));
      },join2:function (l, r) {
        return path.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedpath = '',
          resolvedabsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedabsolute; i--) {
          var path = (i >= 0) ? arguments[i] : fs.cwd();
          // skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new typeerror('arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedpath = path + '/' + resolvedpath;
          resolvedabsolute = path.charat(0) === '/';
        }
        // at this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedpath = path.normalizearray(resolvedpath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedabsolute).join('/');
        return ((resolvedabsolute ? '/' : '') + resolvedpath) || '.';
      },relative:function (from, to) {
        from = path.resolve(from).substr(1);
        to = path.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromparts = trim(from.split('/'));
        var toparts = trim(to.split('/'));
        var length = math.min(fromparts.length, toparts.length);
        var samepartslength = length;
        for (var i = 0; i < length; i++) {
          if (fromparts[i] !== toparts[i]) {
            samepartslength = i;
            break;
          }
        }
        var outputparts = [];
        for (var i = samepartslength; i < fromparts.length; i++) {
          outputparts.push('..');
        }
        outputparts = outputparts.concat(toparts.slice(samepartslength));
        return outputparts.join('/');
      }};
  
  var tty={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (environment_is_node) {
        //   // currently, fs.init does not distinguish if process.stdin is a file or tty
        //   // device, it always assumes it's a tty device. because of this, we're forcing
        //   // process.stdin to utf8 encoding to at least make stdin reading compatible
        //   // with text files until fs.init can be refactored.
        //   process['stdin']['setencoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (environment_is_node) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a readreq operation
        //   // inolen: i thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readstart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        tty.ttys[dev] = { input: [], output: [], ops: ops };
        fs.registerdevice(dev, tty.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = tty.ttys[stream.node.rdev];
          if (!tty) {
            throw new fs.errnoerror(errno_codes.enodev);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function (stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new fs.errnoerror(errno_codes.enxio);
          }
          var bytesread = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new fs.errnoerror(errno_codes.eio);
            }
            if (result === undefined && bytesread === 0) {
              throw new fs.errnoerror(errno_codes.eagain);
            }
            if (result === null || result === undefined) break;
            bytesread++;
            buffer[offset+i] = result;
          }
          if (bytesread) {
            stream.node.timestamp = date.now();
          }
          return bytesread;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new fs.errnoerror(errno_codes.enxio);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new fs.errnoerror(errno_codes.eio);
            }
          }
          if (length) {
            stream.node.timestamp = date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (environment_is_node) {
              // we will read data by chunks of bufsize
              var bufsize = 256;
              var buf = new buffer(bufsize);
              var bytesread = 0;
  
              var isposixplatform = (process.platform != 'win32'); // node doesn't offer a direct check, so test by exclusion
  
              var fd = process.stdin.fd;
              if (isposixplatform) {
                // linux and mac cannot use process.stdin.fd (which isn't set up as sync)
                var usingdevice = false;
                try {
                  fd = fs.opensync('/dev/stdin', 'r');
                  usingdevice = true;
                } catch (e) {}
              }
  
              try {
                bytesread = fs.readsync(fd, buf, 0, bufsize, null);
              } catch(e) {
                // cross-platform differences: on windows, reading eof throws an exception, but on other oses,
                // reading eof returns 0. uniformize behavior by treating the eof exception to return 0.
                if (e.tostring().indexof('eof') != -1) bytesread = 0;
                else throw e;
              }
  
              if (usingdevice) { fs.closesync(fd); }
              if (bytesread > 0) {
                result = buf.slice(0, bytesread).tostring('utf-8');
              } else {
                result = null;
              }
  
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // browser.
              result = window.prompt('input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intarrayfromstring(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            module['print'](utf8arraytostring(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            module['print'](utf8arraytostring(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            module['printerr'](utf8arraytostring(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            module['printerr'](utf8arraytostring(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var memfs={ops_table:null,mount:function (mount) {
        return memfs.createnode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createnode:function (parent, name, mode, dev) {
        if (fs.isblkdev(mode) || fs.isfifo(mode)) {
          // no supported
          throw new fs.errnoerror(errno_codes.eperm);
        }
        if (!memfs.ops_table) {
          memfs.ops_table = {
            dir: {
              node: {
                getattr: memfs.node_ops.getattr,
                setattr: memfs.node_ops.setattr,
                lookup: memfs.node_ops.lookup,
                mknod: memfs.node_ops.mknod,
                rename: memfs.node_ops.rename,
                unlink: memfs.node_ops.unlink,
                rmdir: memfs.node_ops.rmdir,
                readdir: memfs.node_ops.readdir,
                symlink: memfs.node_ops.symlink
              },
              stream: {
                llseek: memfs.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: memfs.node_ops.getattr,
                setattr: memfs.node_ops.setattr
              },
              stream: {
                llseek: memfs.stream_ops.llseek,
                read: memfs.stream_ops.read,
                write: memfs.stream_ops.write,
                allocate: memfs.stream_ops.allocate,
                mmap: memfs.stream_ops.mmap,
                msync: memfs.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: memfs.node_ops.getattr,
                setattr: memfs.node_ops.setattr,
                readlink: memfs.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: memfs.node_ops.getattr,
                setattr: memfs.node_ops.setattr
              },
              stream: fs.chrdev_stream_ops
            }
          };
        }
        var node = fs.createnode(parent, name, mode, dev);
        if (fs.isdir(node.mode)) {
          node.node_ops = memfs.ops_table.dir.node;
          node.stream_ops = memfs.ops_table.dir.stream;
          node.contents = {};
        } else if (fs.isfile(node.mode)) {
          node.node_ops = memfs.ops_table.file.node;
          node.stream_ops = memfs.ops_table.file.stream;
          node.usedbytes = 0; // the actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // when the byte data of the file is populated, this will point to either a typed array, or a normal js array. typed arrays are preferred
          // for performance, and used by default. however, typed arrays are not resizable like normal js arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (fs.islink(node.mode)) {
          node.node_ops = memfs.ops_table.link.node;
          node.stream_ops = memfs.ops_table.link.stream;
        } else if (fs.ischrdev(node.mode)) {
          node.node_ops = memfs.ops_table.chrdev.node;
          node.stream_ops = memfs.ops_table.chrdev.stream;
        }
        node.timestamp = date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getfiledataasregulararray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedbytes; ++i) arr.push(node.contents[i]);
          return arr; // returns a copy of the original data.
        }
        return node.contents; // no-op, the file contents are already in a js array. return as-is.
      },getfiledataastypedarray:function (node) {
        if (!node.contents) return new uint8array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedbytes); // make sure to not return excess unused bytes.
        return new uint8array(node.contents);
      },expandfilestorage:function (node, newcapacity) {
        // if we are asked to expand the size of a file that already exists, revert to using a standard js array to store the file
        // instead of a typed array. this makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newcapacity > node.contents.length) {
          node.contents = memfs.getfiledataasregulararray(node);
          node.usedbytes = node.contents.length; // we might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }
  
        if (!node.contents || node.contents.subarray) { // keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevcapacity = node.contents ? node.contents.length : 0;
          if (prevcapacity >= newcapacity) return; // no need to expand, the storage was already large enough.
          // don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // for small filesizes (<1mb), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var capacity_doubling_max = 1024 * 1024;
          newcapacity = math.max(newcapacity, (prevcapacity * (prevcapacity < capacity_doubling_max ? 2.0 : 1.125)) | 0);
          if (prevcapacity != 0) newcapacity = math.max(newcapacity, 256); // at minimum allocate 256b for each file when expanding.
          var oldcontents = node.contents;
          node.contents = new uint8array(newcapacity); // allocate new storage.
          if (node.usedbytes > 0) node.contents.set(oldcontents.subarray(0, node.usedbytes), 0); // copy old data over to the new storage.
          return;
        }
        // not using a typed array to back the file storage. use a standard js array instead.
        if (!node.contents && newcapacity > 0) node.contents = [];
        while (node.contents.length < newcapacity) node.contents.push(0);
      },resizefilestorage:function (node, newsize) {
        if (node.usedbytes == newsize) return;
        if (newsize == 0) {
          node.contents = null; // fully decommit when requesting a resize to zero.
          node.usedbytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // resize a typed array if that is being used as the backing store.
          var oldcontents = node.contents;
          node.contents = new uint8array(new arraybuffer(newsize)); // allocate new storage.
          if (oldcontents) {
            node.contents.set(oldcontents.subarray(0, math.min(newsize, node.usedbytes))); // copy old data over to the new storage.
          }
          node.usedbytes = newsize;
          return;
        }
        // backing with a js array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newsize) node.contents.length = newsize;
        else while (node.contents.length < newsize) node.contents.push(0);
        node.usedbytes = newsize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = fs.ischrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (fs.isdir(node.mode)) {
            attr.size = 4096;
          } else if (fs.isfile(node.mode)) {
            attr.size = node.usedbytes;
          } else if (fs.islink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new date(node.timestamp);
          attr.mtime = new date(node.timestamp);
          attr.ctime = new date(node.timestamp);
          // note: in our implementation, st_blocks = math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            memfs.resizefilestorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw fs.genericerrors[errno_codes.enoent];
        },mknod:function (parent, name, mode, dev) {
          return memfs.createnode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (fs.isdir(old_node.mode)) {
            var new_node;
            try {
              new_node = fs.lookupnode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new fs.errnoerror(errno_codes.enotempty);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = fs.lookupnode(parent, name);
          for (var i in node.contents) {
            throw new fs.errnoerror(errno_codes.enotempty);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasownproperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = memfs.createnode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!fs.islink(node.mode)) {
            throw new fs.errnoerror(errno_codes.einval);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedbytes) return 0;
          var size = math.min(stream.node.usedbytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canown) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // this write is from a typed array to a typed array?
            if (canown) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedbytes = length;
              return length;
            } else if (node.usedbytes === 0 && position === 0) { // if this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new uint8array(buffer.subarray(offset, offset + length));
              node.usedbytes = length;
              return length;
            } else if (position + length <= node.usedbytes) { // writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          memfs.expandfilestorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // or fall back to manual write if not.
            }
          }
          node.usedbytes = math.max(node.usedbytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // seek_cur.
            position += stream.position;
          } else if (whence === 2) {  // seek_end.
            if (fs.isfile(stream.node.mode)) {
              position += stream.node.usedbytes;
            }
          }
          if (position < 0) {
            throw new fs.errnoerror(errno_codes.einval);
          }
          return position;
        },allocate:function (stream, offset, length) {
          memfs.expandfilestorage(stream.node, offset + length);
          stream.node.usedbytes = math.max(stream.node.usedbytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!fs.isfile(stream.node.mode)) {
            throw new fs.errnoerror(errno_codes.enodev);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // only make a new copy when map_private is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // we can't emulate map_shared when the file is not backed by the buffer
            // we're mapping to (e.g. the heap buffer).
            allocated = false;
            ptr = contents.byteoffset;
          } else {
            // try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedbytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new fs.errnoerror(errno_codes.enomem);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function (stream, buffer, offset, length, mmapflags) {
          if (!fs.isfile(stream.node.mode)) {
            throw new fs.errnoerror(errno_codes.enodev);
          }
          if (mmapflags & 2) {
            // map_private calls need not to be synced back to underlying fs
            return 0;
          }
  
          var byteswritten = memfs.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if byteswritten and length are the same?
          return 0;
        }}};
  
  var idbfs={dbs:{},indexeddb:function () {
        return module.indexeddb;
      },db_version:21,db_store_name:"file_data",mount:function (mount) {
        // reuse all of the core memfs functionality
        return memfs.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        idbfs.getlocalset(mount, function(err, local) {
          if (err) return callback(err);
  
          idbfs.getremoteset(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            idbfs.reconcile(src, dst, callback);
          });
        });
      },getdb:function (name, callback) {
        // check the cache first
        var db = idbfs.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = idbfs.indexeddb().open(name, idbfs.db_version);
        } catch (e) {
          return callback(e);
        }
        if (!req) {
          return callback("unable to connect to indexeddb");
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
  
          var filestore;
  
          if (db.objectstorenames.contains(idbfs.db_store_name)) {
            filestore = transaction.objectstore(idbfs.db_store_name);
          } else {
            filestore = db.createobjectstore(idbfs.db_store_name);
          }
  
          if (!filestore.indexnames.contains('timestamp')) {
            filestore.createindex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function() {
          db = req.result;
  
          // add to the cache
          idbfs.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function(e) {
          callback(this.error);
          e.preventdefault();
        };
      },getlocalset:function (mount, callback) {
        var entries = {};
  
        function isrealdir(p) {
          return p !== '.' && p !== '..';
        };
        function toabsolute(root) {
          return function(p) {
            return path.join2(root, p);
          }
        };
  
        var check = fs.readdir(mount.mountpoint).filter(isrealdir).map(toabsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = fs.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (fs.isdir(stat.mode)) {
            check.push.apply(check, fs.readdir(path).filter(isrealdir).map(toabsolute(path)));
          }
  
          entries[path] = { timestamp: stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getremoteset:function (mount, callback) {
        var entries = {};
  
        idbfs.getdb(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([idbfs.db_store_name], 'readonly');
          transaction.onerror = function(e) {
            callback(this.error);
            e.preventdefault();
          };
  
          var store = transaction.objectstore(idbfs.db_store_name);
          var index = store.index('timestamp');
  
          index.openkeycursor().onsuccess = function(event) {
            var cursor = event.target.result;
  
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }
  
            entries[cursor.primarykey] = { timestamp: cursor.key };
  
            cursor.continue();
          };
        });
      },loadlocalentry:function (path, callback) {
        var stat, node;
  
        try {
          var lookup = fs.lookuppath(path);
          node = lookup.node;
          stat = fs.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (fs.isdir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (fs.isfile(stat.mode)) {
          // performance consideration: storing a normal javascript array to a indexeddb is much slower than storing a typed array.
          // therefore always convert the file contents to a typed array first before writing the data to indexeddb.
          node.contents = memfs.getfiledataastypedarray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new error('node type not supported'));
        }
      },storelocalentry:function (path, entry, callback) {
        try {
          if (fs.isdir(entry.mode)) {
            fs.mkdir(path, entry.mode);
          } else if (fs.isfile(entry.mode)) {
            fs.writefile(path, entry.contents, { encoding: 'binary', canown: true });
          } else {
            return callback(new error('node type not supported'));
          }
  
          fs.chmod(path, entry.mode);
          fs.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removelocalentry:function (path, callback) {
        try {
          var lookup = fs.lookuppath(path);
          var stat = fs.stat(path);
  
          if (fs.isdir(stat.mode)) {
            fs.rmdir(path);
          } else if (fs.isfile(stat.mode)) {
            fs.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadremoteentry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventdefault();
        };
      },storeremoteentry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventdefault();
        };
      },removeremoteentry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventdefault();
        };
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = [];
        object.keys(src.entries).foreach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        object.keys(dst.entries).foreach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([idbfs.db_store_name], 'readwrite');
        var store = transaction.objectstore(idbfs.db_store_name);
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        transaction.onerror = function(e) {
          done(this.error);
          e.preventdefault();
        };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().foreach(function (path) {
          if (dst.type === 'local') {
            idbfs.loadremoteentry(store, path, function (err, entry) {
              if (err) return done(err);
              idbfs.storelocalentry(path, entry, done);
            });
          } else {
            idbfs.loadlocalentry(path, function (err, entry) {
              if (err) return done(err);
              idbfs.storeremoteentry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().foreach(function(path) {
          if (dst.type === 'local') {
            idbfs.removelocalentry(path, done);
          } else {
            idbfs.removeremoteentry(store, path, done);
          }
        });
      }};
  
  var nodefs={iswindows:false,staticinit:function () {
        nodefs.iswindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(environment_is_node);
        return nodefs.createnode(null, '/', nodefs.getmode(mount.opts.root), 0);
      },createnode:function (parent, name, mode, dev) {
        if (!fs.isdir(mode) && !fs.isfile(mode) && !fs.islink(mode)) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        var node = fs.createnode(parent, name, mode);
        node.node_ops = nodefs.node_ops;
        node.stream_ops = nodefs.stream_ops;
        return node;
      },getmode:function (path) {
        var stat;
        try {
          stat = fs.lstatsync(path);
          if (nodefs.iswindows) {
            // on windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new fs.errnoerror(errno_codes[e.code]);
        }
        return stat.mode;
      },realpath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return path.join.apply(null, parts);
      },flagstopermissionstringmap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagstopermissionstring:function (flags) {
        flags &= ~0x200000 /*o_path*/; // ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x800 /*o_nonblock*/; // ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x8000 /*o_largefile*/; // ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x80000 /*o_cloexec*/; // some applications may pass it; it makes no sense for a single process.
        if (flags in nodefs.flagstopermissionstringmap) {
          return nodefs.flagstopermissionstringmap[flags];
        } else {
          throw new fs.errnoerror(errno_codes.einval);
        }
      },node_ops:{getattr:function (node) {
          var path = nodefs.realpath(node);
          var stat;
          try {
            stat = fs.lstatsync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on windows. fake them with default blksize of 4096.
          // see http://support.microsoft.com/kb/140365
          if (nodefs.iswindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (nodefs.iswindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = nodefs.realpath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodsync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new date(attr.timestamp);
              fs.utimessync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncatesync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },lookup:function (parent, name) {
          var path = path.join2(nodefs.realpath(parent), name);
          var mode = nodefs.getmode(path);
          return nodefs.createnode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = nodefs.createnode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = nodefs.realpath(node);
          try {
            if (fs.isdir(node.mode)) {
              fs.mkdirsync(path, node.mode);
            } else {
              fs.writefilesync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
          return node;
        },rename:function (oldnode, newdir, newname) {
          var oldpath = nodefs.realpath(oldnode);
          var newpath = path.join2(nodefs.realpath(newdir), newname);
          try {
            fs.renamesync(oldpath, newpath);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },unlink:function (parent, name) {
          var path = path.join2(nodefs.realpath(parent), name);
          try {
            fs.unlinksync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = path.join2(nodefs.realpath(parent), name);
          try {
            fs.rmdirsync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },readdir:function (node) {
          var path = nodefs.realpath(node);
          try {
            return fs.readdirsync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },symlink:function (parent, newname, oldpath) {
          var newpath = path.join2(nodefs.realpath(parent), newname);
          try {
            fs.symlinksync(oldpath, newpath);
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },readlink:function (node) {
          var path = nodefs.realpath(node);
          try {
            path = fs.readlinksync(path);
            path = nodejs_path.relative(nodejs_path.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = nodefs.realpath(stream.node);
          try {
            if (fs.isfile(stream.node.mode)) {
              stream.nfd = fs.opensync(path, nodefs.flagstopermissionstring(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },close:function (stream) {
          try {
            if (fs.isfile(stream.node.mode) && stream.nfd) {
              fs.closesync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new fs.errnoerror(errno_codes[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // fixme this is terrible.
          var nbuffer = new buffer(length);
          var res;
          try {
            res = fs.readsync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new fs.errnoerror(errno_codes[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // fixme this is terrible.
          var nbuffer = new buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writesync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new fs.errnoerror(errno_codes[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // seek_cur.
            position += stream.position;
          } else if (whence === 2) {  // seek_end.
            if (fs.isfile(stream.node.mode)) {
              try {
                var stat = fs.fstatsync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new fs.errnoerror(errno_codes[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new fs.errnoerror(errno_codes.einval);
          }
  
          return position;
        }}};
  
  var workerfs={dir_mode:16895,file_mode:33279,reader:null,mount:function (mount) {
        assert(environment_is_worker);
        if (!workerfs.reader) workerfs.reader = new filereadersync();
        var root = workerfs.createnode(null, '/', workerfs.dir_mode, 0);
        var createdparents = {};
        function ensureparent(path) {
          // return the parent node, creating subdirs as necessary
          var parts = path.split('/');
          var parent = root;
          for (var i = 0; i < parts.length-1; i++) {
            var curr = parts.slice(0, i+1).join('/');
            // issue 4254: using curr as a node name will prevent the node
            // from being found in fs.nametable when fs.open is called on
            // a path which holds a child of this node,
            // given that all fs functions assume node names
            // are just their corresponding parts within their given path,
            // rather than incremental aggregates which include their parent's
            // directories.
            if (!createdparents[curr]) {
              createdparents[curr] = workerfs.createnode(parent, parts[i], workerfs.dir_mode, 0);
            }
            parent = createdparents[curr];
          }
          return parent;
        }
        function base(path) {
          var parts = path.split('/');
          return parts[parts.length-1];
        }
        // we also accept filelist here, by using array.prototype
        array.prototype.foreach.call(mount.opts["files"] || [], function(file) {
          workerfs.createnode(ensureparent(file.name), base(file.name), workerfs.file_mode, 0, file, file.lastmodifieddate);
        });
        (mount.opts["blobs"] || []).foreach(function(obj) {
          workerfs.createnode(ensureparent(obj["name"]), base(obj["name"]), workerfs.file_mode, 0, obj["data"]);
        });
        (mount.opts["packages"] || []).foreach(function(pack) {
          pack['metadata'].files.foreach(function(file) {
            var name = file.filename.substr(1); // remove initial slash
            workerfs.createnode(ensureparent(name), base(name), workerfs.file_mode, 0, pack['blob'].slice(file.start, file.end));
          });
        });
        return root;
      },createnode:function (parent, name, mode, dev, contents, mtime) {
        var node = fs.createnode(parent, name, mode);
        node.mode = mode;
        node.node_ops = workerfs.node_ops;
        node.stream_ops = workerfs.stream_ops;
        node.timestamp = (mtime || new date).gettime();
        assert(workerfs.file_mode !== workerfs.dir_mode);
        if (mode === workerfs.file_mode) {
          node.size = contents.size;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },node_ops:{getattr:function (node) {
          return {
            dev: 1,
            ino: undefined,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: undefined,
            size: node.size,
            atime: new date(node.timestamp),
            mtime: new date(node.timestamp),
            ctime: new date(node.timestamp),
            blksize: 4096,
            blocks: math.ceil(node.size / 4096),
          };
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
        },lookup:function (parent, name) {
          throw new fs.errnoerror(errno_codes.enoent);
        },mknod:function (parent, name, mode, dev) {
          throw new fs.errnoerror(errno_codes.eperm);
        },rename:function (oldnode, newdir, newname) {
          throw new fs.errnoerror(errno_codes.eperm);
        },unlink:function (parent, name) {
          throw new fs.errnoerror(errno_codes.eperm);
        },rmdir:function (parent, name) {
          throw new fs.errnoerror(errno_codes.eperm);
        },readdir:function (node) {
          throw new fs.errnoerror(errno_codes.eperm);
        },symlink:function (parent, newname, oldpath) {
          throw new fs.errnoerror(errno_codes.eperm);
        },readlink:function (node) {
          throw new fs.errnoerror(errno_codes.eperm);
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          if (position >= stream.node.size) return 0;
          var chunk = stream.node.contents.slice(position, position + length);
          var ab = workerfs.reader.readasarraybuffer(chunk);
          buffer.set(new uint8array(ab), offset);
          return chunk.size;
        },write:function (stream, buffer, offset, length, position) {
          throw new fs.errnoerror(errno_codes.eio);
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // seek_cur.
            position += stream.position;
          } else if (whence === 2) {  // seek_end.
            if (fs.isfile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new fs.errnoerror(errno_codes.einval);
          }
          return position;
        }}};
  
  var _stdin=statictop; statictop += 16;;
  
  var _stdout=statictop; statictop += 16;;
  
  var _stderr=statictop; statictop += 16;;var fs={root:null,mounts:[],devices:[null],streams:[],nextinode:1,nametable:null,currentpath:"/",initialized:false,ignorepermissions:true,trackingdelegate:{},tracking:{openflags:{read:1,write:2}},errnoerror:null,genericerrors:{},filesystems:null,syncfsrequests:0,handlefserror:function (e) {
        if (!(e instanceof fs.errnoerror)) throw e + ' : ' + stacktrace();
        return ___seterrno(e.errno);
      },lookuppath:function (path, opts) {
        path = path.resolve(fs.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new fs.errnoerror(errno_codes.eloop);
        }
  
        // split the path
        var parts = path.normalizearray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = fs.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = fs.lookupnode(current, parts[i]);
          current_path = path.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (fs.ismountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookuppath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (fs.islink(current.mode)) {
              var link = fs.readlink(current_path);
              current_path = path.resolve(path.dirname(current_path), link);
  
              var lookup = fs.lookuppath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (symloop_max).
                throw new fs.errnoerror(errno_codes.eloop);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getpath:function (node) {
        var path;
        while (true) {
          if (fs.isroot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashname:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charcodeat(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % fs.nametable.length;
      },hashaddnode:function (node) {
        var hash = fs.hashname(node.parent.id, node.name);
        node.name_next = fs.nametable[hash];
        fs.nametable[hash] = node;
      },hashremovenode:function (node) {
        var hash = fs.hashname(node.parent.id, node.name);
        if (fs.nametable[hash] === node) {
          fs.nametable[hash] = node.name_next;
        } else {
          var current = fs.nametable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupnode:function (parent, name) {
        var err = fs.maylookup(parent);
        if (err) {
          throw new fs.errnoerror(err, parent);
        }
        var hash = fs.hashname(parent.id, name);
        for (var node = fs.nametable[hash]; node; node = node.name_next) {
          var nodename = node.name;
          if (node.parent.id === parent.id && nodename === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the vfs
        return fs.lookup(parent, name);
      },createnode:function (parent, name, mode, rdev) {
        if (!fs.fsnode) {
          fs.fsnode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = fs.nextinode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
  
          fs.fsnode.prototype = {};
  
          // compatibility
          var readmode = 292 | 73;
          var writemode = 146;
  
          // note we must use object.defineproperties instead of individual calls to
          // object.defineproperty in order to make closure compiler happy
          object.defineproperties(fs.fsnode.prototype, {
            read: {
              get: function() { return (this.mode & readmode) === readmode; },
              set: function(val) { val ? this.mode |= readmode : this.mode &= ~readmode; }
            },
            write: {
              get: function() { return (this.mode & writemode) === writemode; },
              set: function(val) { val ? this.mode |= writemode : this.mode &= ~writemode; }
            },
            isfolder: {
              get: function() { return fs.isdir(this.mode); }
            },
            isdevice: {
              get: function() { return fs.ischrdev(this.mode); }
            }
          });
        }
  
        var node = new fs.fsnode(parent, name, mode, rdev);
  
        fs.hashaddnode(node);
  
        return node;
      },destroynode:function (node) {
        fs.hashremovenode(node);
      },isroot:function (node) {
        return node === node.parent;
      },ismountpoint:function (node) {
        return !!node.mounted;
      },isfile:function (mode) {
        return (mode & 61440) === 32768;
      },isdir:function (mode) {
        return (mode & 61440) === 16384;
      },islink:function (mode) {
        return (mode & 61440) === 40960;
      },ischrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isblkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isfifo:function (mode) {
        return (mode & 61440) === 4096;
      },issocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagmodes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modestringtoflags:function (str) {
        var flags = fs.flagmodes[str];
        if (typeof flags === 'undefined') {
          throw new error('unknown file open mode: ' + str);
        }
        return flags;
      },flagstopermissionstring:function (flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodepermissions:function (node, perms) {
        if (fs.ignorepermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexof('r') !== -1 && !(node.mode & 292)) {
          return errno_codes.eacces;
        } else if (perms.indexof('w') !== -1 && !(node.mode & 146)) {
          return errno_codes.eacces;
        } else if (perms.indexof('x') !== -1 && !(node.mode & 73)) {
          return errno_codes.eacces;
        }
        return 0;
      },maylookup:function (dir) {
        var err = fs.nodepermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return errno_codes.eacces;
        return 0;
      },maycreate:function (dir, name) {
        try {
          var node = fs.lookupnode(dir, name);
          return errno_codes.eexist;
        } catch (e) {
        }
        return fs.nodepermissions(dir, 'wx');
      },maydelete:function (dir, name, isdir) {
        var node;
        try {
          node = fs.lookupnode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = fs.nodepermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!fs.isdir(node.mode)) {
            return errno_codes.enotdir;
          }
          if (fs.isroot(node) || fs.getpath(node) === fs.cwd()) {
            return errno_codes.ebusy;
          }
        } else {
          if (fs.isdir(node.mode)) {
            return errno_codes.eisdir;
          }
        }
        return 0;
      },mayopen:function (node, flags) {
        if (!node) {
          return errno_codes.enoent;
        }
        if (fs.islink(node.mode)) {
          return errno_codes.eloop;
        } else if (fs.isdir(node.mode)) {
          if (fs.flagstopermissionstring(flags) !== 'r' || // opening for write
              (flags & 512)) { // todo: check for o_search? (== search for dir only)
            return errno_codes.eisdir;
          }
        }
        return fs.nodepermissions(node, fs.flagstopermissionstring(flags));
      },max_open_fds:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || fs.max_open_fds;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!fs.streams[fd]) {
            return fd;
          }
        }
        throw new fs.errnoerror(errno_codes.emfile);
      },getstream:function (fd) {
        return fs.streams[fd];
      },createstream:function (stream, fd_start, fd_end) {
        if (!fs.fsstream) {
          fs.fsstream = function(){};
          fs.fsstream.prototype = {};
          // compatibility
          object.defineproperties(fs.fsstream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isread: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            iswrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isappend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of fsstream
        var newstream = new fs.fsstream();
        for (var p in stream) {
          newstream[p] = stream[p];
        }
        stream = newstream;
        var fd = fs.nextfd(fd_start, fd_end);
        stream.fd = fd;
        fs.streams[fd] = stream;
        return stream;
      },closestream:function (fd) {
        fs.streams[fd] = null;
      },chrdev_stream_ops:{open:function (stream) {
          var device = fs.getdevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new fs.errnoerror(errno_codes.espipe);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerdevice:function (dev, ops) {
        fs.devices[dev] = { stream_ops: ops };
      },getdevice:function (dev) {
        return fs.devices[dev];
      },getmounts:function (mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        fs.syncfsrequests++;
  
        if (fs.syncfsrequests > 1) {
          console.log('warning: ' + fs.syncfsrequests + ' fs.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = fs.getmounts(fs.root.mount);
        var completed = 0;
  
        function docallback(err) {
          assert(fs.syncfsrequests > 0);
          fs.syncfsrequests--;
          return callback(err);
        }
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return docallback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            docallback(null);
          }
        };
  
        // sync all mounts
        mounts.foreach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && fs.root) {
          throw new fs.errnoerror(errno_codes.ebusy);
        } else if (!root && !pseudo) {
          var lookup = fs.lookuppath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (fs.ismountpoint(node)) {
            throw new fs.errnoerror(errno_codes.ebusy);
          }
  
          if (!fs.isdir(node.mode)) {
            throw new fs.errnoerror(errno_codes.enotdir);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountroot = type.mount(mount);
        mountroot.mount = mount;
        mount.root = mountroot;
  
        if (root) {
          fs.root = mountroot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountroot;
      },unmount:function (mountpoint) {
        var lookup = fs.lookuppath(mountpoint, { follow_mount: false });
  
        if (!fs.ismountpoint(lookup.node)) {
          throw new fs.errnoerror(errno_codes.einval);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = fs.getmounts(mount);
  
        object.keys(fs.nametable).foreach(function (hash) {
          var current = fs.nametable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexof(current.mount) !== -1) {
              fs.destroynode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexof(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = fs.lookuppath(path, { parent: true });
        var parent = lookup.node;
        var name = path.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new fs.errnoerror(errno_codes.einval);
        }
        var err = fs.maycreate(parent, name);
        if (err) {
          throw new fs.errnoerror(err);
        }
        if (!parent.node_ops.mknod) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return fs.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return fs.mknod(path, mode, 0);
      },mkdirtree:function (path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            fs.mkdir(d, mode);
          } catch(e) {
            if (e.errno != errno_codes.eexist) throw e;
          }
        }
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return fs.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!path.resolve(oldpath)) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        var lookup = fs.lookuppath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        var newname = path.basename(newpath);
        var err = fs.maycreate(parent, newname);
        if (err) {
          throw new fs.errnoerror(err);
        }
        if (!parent.node_ops.symlink) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = path.dirname(old_path);
        var new_dirname = path.dirname(new_path);
        var old_name = path.basename(old_path);
        var new_name = path.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = fs.lookuppath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = fs.lookuppath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new fs.errnoerror(errno_codes.ebusy);
        }
        if (!old_dir || !new_dir) throw new fs.errnoerror(errno_codes.enoent);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new fs.errnoerror(errno_codes.exdev);
        }
        // source must exist
        var old_node = fs.lookupnode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = path.relative(old_path, new_dirname);
        if (relative.charat(0) !== '.') {
          throw new fs.errnoerror(errno_codes.einval);
        }
        // new path should not be an ancestor of the old path
        relative = path.relative(new_path, old_dirname);
        if (relative.charat(0) !== '.') {
          throw new fs.errnoerror(errno_codes.enotempty);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = fs.lookupnode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = fs.isdir(old_node.mode);
        var err = fs.maydelete(old_dir, old_name, isdir);
        if (err) {
          throw new fs.errnoerror(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          fs.maydelete(new_dir, new_name, isdir) :
          fs.maycreate(new_dir, new_name);
        if (err) {
          throw new fs.errnoerror(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        if (fs.ismountpoint(old_node) || (new_node && fs.ismountpoint(new_node))) {
          throw new fs.errnoerror(errno_codes.ebusy);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = fs.nodepermissions(old_dir, 'w');
          if (err) {
            throw new fs.errnoerror(err);
          }
        }
        try {
          if (fs.trackingdelegate['willmovepath']) {
            fs.trackingdelegate['willmovepath'](old_path, new_path);
          }
        } catch(e) {
          console.log("fs.trackingdelegate['willmovepath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        fs.hashremovenode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          fs.hashaddnode(old_node);
        }
        try {
          if (fs.trackingdelegate['onmovepath']) fs.trackingdelegate['onmovepath'](old_path, new_path);
        } catch(e) {
          console.log("fs.trackingdelegate['onmovepath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = fs.lookuppath(path, { parent: true });
        var parent = lookup.node;
        var name = path.basename(path);
        var node = fs.lookupnode(parent, name);
        var err = fs.maydelete(parent, name, true);
        if (err) {
          throw new fs.errnoerror(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        if (fs.ismountpoint(node)) {
          throw new fs.errnoerror(errno_codes.ebusy);
        }
        try {
          if (fs.trackingdelegate['willdeletepath']) {
            fs.trackingdelegate['willdeletepath'](path);
          }
        } catch(e) {
          console.log("fs.trackingdelegate['willdeletepath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        fs.destroynode(node);
        try {
          if (fs.trackingdelegate['ondeletepath']) fs.trackingdelegate['ondeletepath'](path);
        } catch(e) {
          console.log("fs.trackingdelegate['ondeletepath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = fs.lookuppath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new fs.errnoerror(errno_codes.enotdir);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = fs.lookuppath(path, { parent: true });
        var parent = lookup.node;
        var name = path.basename(path);
        var node = fs.lookupnode(parent, name);
        var err = fs.maydelete(parent, name, false);
        if (err) {
          // according to posix, we should map eisdir to eperm, but
          // we instead do what linux does (and we must, as we use
          // the musl linux libc).
          throw new fs.errnoerror(err);
        }
        if (!parent.node_ops.unlink) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        if (fs.ismountpoint(node)) {
          throw new fs.errnoerror(errno_codes.ebusy);
        }
        try {
          if (fs.trackingdelegate['willdeletepath']) {
            fs.trackingdelegate['willdeletepath'](path);
          }
        } catch(e) {
          console.log("fs.trackingdelegate['willdeletepath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        fs.destroynode(node);
        try {
          if (fs.trackingdelegate['ondeletepath']) fs.trackingdelegate['ondeletepath'](path);
        } catch(e) {
          console.log("fs.trackingdelegate['ondeletepath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = fs.lookuppath(path);
        var link = lookup.node;
        if (!link) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        if (!link.node_ops.readlink) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        return path.resolve(fs.getpath(link.parent), link.node_ops.readlink(link));
      },stat:function (path, dontfollow) {
        var lookup = fs.lookuppath(path, { follow: !dontfollow });
        var node = lookup.node;
        if (!node) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        if (!node.node_ops.getattr) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return fs.stat(path, true);
      },chmod:function (path, mode, dontfollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = fs.lookuppath(path, { follow: !dontfollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: date.now()
        });
      },lchmod:function (path, mode) {
        fs.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = fs.getstream(fd);
        if (!stream) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        fs.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontfollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = fs.lookuppath(path, { follow: !dontfollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        node.node_ops.setattr(node, {
          timestamp: date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        fs.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = fs.getstream(fd);
        if (!stream) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        fs.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = fs.lookuppath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new fs.errnoerror(errno_codes.eperm);
        }
        if (fs.isdir(node.mode)) {
          throw new fs.errnoerror(errno_codes.eisdir);
        }
        if (!fs.isfile(node.mode)) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        var err = fs.nodepermissions(node, 'w');
        if (err) {
          throw new fs.errnoerror(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = fs.getstream(fd);
        if (!stream) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        fs.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = fs.lookuppath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        flags = typeof flags === 'string' ? fs.modestringtoflags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = path.normalize(path);
          try {
            var lookup = fs.lookuppath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if o_creat and o_excl are set, error out if the node already exists
            if ((flags & 128)) {
              throw new fs.errnoerror(errno_codes.eexist);
            }
          } else {
            // node doesn't exist, try to create it
            node = fs.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        // can't truncate a device
        if (fs.ischrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !fs.isdir(node.mode)) {
          throw new fs.errnoerror(errno_codes.enotdir);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = fs.mayopen(node, flags);
          if (err) {
            throw new fs.errnoerror(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          fs.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = fs.createstream({
          node: node,
          path: fs.getpath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (module['logreadfiles'] && !(flags & 1)) {
          if (!fs.readfiles) fs.readfiles = {};
          if (!(path in fs.readfiles)) {
            fs.readfiles[path] = 1;
            module['printerr']('read file: ' + path);
          }
        }
        try {
          if (fs.trackingdelegate['onopenfile']) {
            var trackingflags = 0;
            if ((flags & 2097155) !== 1) {
              trackingflags |= fs.tracking.openflags.read;
            }
            if ((flags & 2097155) !== 0) {
              trackingflags |= fs.tracking.openflags.write;
            }
            fs.trackingdelegate['onopenfile'](path, trackingflags);
          }
        } catch(e) {
          console.log("fs.trackingdelegate['onopenfile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          fs.closestream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new fs.errnoerror(errno_codes.espipe);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        if (fs.isdir(stream.node.mode)) {
          throw new fs.errnoerror(errno_codes.eisdir);
        }
        if (!stream.stream_ops.read) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new fs.errnoerror(errno_codes.espipe);
        }
        var bytesread = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesread;
        return bytesread;
      },write:function (stream, buffer, offset, length, position, canown) {
        if (length < 0 || position < 0) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        if (fs.isdir(stream.node.mode)) {
          throw new fs.errnoerror(errno_codes.eisdir);
        }
        if (!stream.stream_ops.write) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          fs.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new fs.errnoerror(errno_codes.espipe);
        }
        var byteswritten = stream.stream_ops.write(stream, buffer, offset, length, position, canown);
        if (!seeking) stream.position += byteswritten;
        try {
          if (stream.path && fs.trackingdelegate['onwritetofile']) fs.trackingdelegate['onwritetofile'](stream.path);
        } catch(e) {
          console.log("fs.trackingdelegate['onwritetofile']('"+path+"') threw an exception: " + e.message);
        }
        return byteswritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new fs.errnoerror(errno_codes.einval);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new fs.errnoerror(errno_codes.ebadf);
        }
        if (!fs.isfile(stream.node.mode) && !fs.isdir(node.mode)) {
          throw new fs.errnoerror(errno_codes.enodev);
        }
        if (!stream.stream_ops.allocate) {
          throw new fs.errnoerror(errno_codes.eopnotsupp);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // todo if prot is prot_write, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new fs.errnoerror(errno_codes.eacces);
        }
        if (!stream.stream_ops.mmap) {
          throw new fs.errnoerror(errno_codes.enodev);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function (stream, buffer, offset, length, mmapflags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapflags);
      },munmap:function (stream) {
        return 0;
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new fs.errnoerror(errno_codes.enotty);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readfile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new error('invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = fs.open(path, opts.flags);
        var stat = fs.stat(path);
        var length = stat.size;
        var buf = new uint8array(length);
        fs.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = utf8arraytostring(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        fs.close(stream);
        return ret;
      },writefile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new error('invalid encoding type "' + opts.encoding + '"');
        }
        var stream = fs.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var buf = new uint8array(lengthbytesutf8(data)+1);
          var actualnumbytes = stringtoutf8array(data, buf, 0, buf.length);
          fs.write(stream, buf, 0, actualnumbytes, 0, opts.canown);
        } else if (opts.encoding === 'binary') {
          fs.write(stream, data, 0, data.length, 0, opts.canown);
        }
        fs.close(stream);
      },cwd:function () {
        return fs.currentpath;
      },chdir:function (path) {
        var lookup = fs.lookuppath(path, { follow: true });
        if (lookup.node === null) {
          throw new fs.errnoerror(errno_codes.enoent);
        }
        if (!fs.isdir(lookup.node.mode)) {
          throw new fs.errnoerror(errno_codes.enotdir);
        }
        var err = fs.nodepermissions(lookup.node, 'x');
        if (err) {
          throw new fs.errnoerror(err);
        }
        fs.currentpath = lookup.path;
      },createdefaultdirectories:function () {
        fs.mkdir('/tmp');
        fs.mkdir('/home');
        fs.mkdir('/home/web_user');
      },createdefaultdevices:function () {
        // create /dev
        fs.mkdir('/dev');
        // setup /dev/null
        fs.registerdevice(fs.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        fs.mkdev('/dev/null', fs.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using module['printerr']
        // so we register a second tty just for it.
        tty.register(fs.makedev(5, 0), tty.default_tty_ops);
        tty.register(fs.makedev(6, 0), tty.default_tty1_ops);
        fs.mkdev('/dev/tty', fs.makedev(5, 0));
        fs.mkdev('/dev/tty1', fs.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randombuffer = new uint8array(1);
          random_device = function() { crypto.getrandomvalues(randombuffer); return randombuffer[0]; };
        } else if (environment_is_node) {
          // for nodejs
          random_device = function() { return require('crypto').randombytes(1)[0]; };
        } else {
          // default for es5 platforms
          random_device = function() { return (math.random()*256)|0; };
        }
        fs.createdevice('/dev', 'random', random_device);
        fs.createdevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        fs.mkdir('/dev/shm');
        fs.mkdir('/dev/shm/tmp');
      },createspecialdirectories:function () {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        fs.mkdir('/proc');
        fs.mkdir('/proc/self');
        fs.mkdir('/proc/self/fd');
        fs.mount({
          mount: function() {
            var node = fs.createnode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = fs.getstream(fd);
                if (!stream) throw new fs.errnoerror(errno_codes.ebadf);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createstandardstreams:function () {
        // todo deprecate the old functionality of a single
        // input / output callback and that utilizes fs.createdevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (module['stdin']) {
          fs.createdevice('/dev', 'stdin', module['stdin']);
        } else {
          fs.symlink('/dev/tty', '/dev/stdin');
        }
        if (module['stdout']) {
          fs.createdevice('/dev', 'stdout', null, module['stdout']);
        } else {
          fs.symlink('/dev/tty', '/dev/stdout');
        }
        if (module['stderr']) {
          fs.createdevice('/dev', 'stderr', null, module['stderr']);
        } else {
          fs.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = fs.open('/dev/stdin', 'r');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = fs.open('/dev/stdout', 'w');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = fs.open('/dev/stderr', 'w');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureerrnoerror:function () {
        if (fs.errnoerror) return;
        fs.errnoerror = function errnoerror(errno, node) {
          //module.printerr(stacktrace()); // useful for debugging
          this.node = node;
          this.seterrno = function(errno) {
            this.errno = errno;
            for (var key in errno_codes) {
              if (errno_codes[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.seterrno(errno);
          this.message = errno_messages[errno];
        };
        fs.errnoerror.prototype = new error();
        fs.errnoerror.prototype.constructor = fs.errnoerror;
        // some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [errno_codes.enoent].foreach(function(code) {
          fs.genericerrors[code] = new fs.errnoerror(code);
          fs.genericerrors[code].stack = '<generic error, no stack>';
        });
      },staticinit:function () {
        fs.ensureerrnoerror();
  
        fs.nametable = new array(4096);
  
        fs.mount(memfs, {}, '/');
  
        fs.createdefaultdirectories();
        fs.createdefaultdevices();
        fs.createspecialdirectories();
  
        fs.filesystems = {
          'memfs': memfs,
          'idbfs': idbfs,
          'nodefs': nodefs,
          'workerfs': workerfs,
        };
      },init:function (input, output, error) {
        assert(!fs.init.initialized, 'fs.init was previously called. if you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        fs.init.initialized = true;
  
        fs.ensureerrnoerror();
  
        // allow module.stdin etc. to provide defaults, if none explicitly passed to us here
        module['stdin'] = input || module['stdin'];
        module['stdout'] = output || module['stdout'];
        module['stderr'] = error || module['stderr'];
  
        fs.createstandardstreams();
      },quit:function () {
        fs.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < fs.streams.length; i++) {
          var stream = fs.streams[i];
          if (!stream) {
            continue;
          }
          fs.close(stream);
        }
      },getmode:function (canread, canwrite) {
        var mode = 0;
        if (canread) mode |= 292 | 73;
        if (canwrite) mode |= 146;
        return mode;
      },joinpath:function (parts, forcerelative) {
        var path = path.join.apply(null, parts);
        if (forcerelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutepath:function (relative, base) {
        return path.resolve(base, relative);
      },standardizepath:function (path) {
        return path.normalize(path);
      },findobject:function (path, dontresolvelastlink) {
        var ret = fs.analyzepath(path, dontresolvelastlink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___seterrno(ret.error);
          return null;
        }
      },analyzepath:function (path, dontresolvelastlink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = fs.lookuppath(path, { follow: !dontresolvelastlink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isroot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentexists: false, parentpath: null, parentobject: null
        };
        try {
          var lookup = fs.lookuppath(path, { parent: true });
          ret.parentexists = true;
          ret.parentpath = lookup.path;
          ret.parentobject = lookup.node;
          ret.name = path.basename(path);
          lookup = fs.lookuppath(path, { follow: !dontresolvelastlink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isroot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createfolder:function (parent, name, canread, canwrite) {
        var path = path.join2(typeof parent === 'string' ? parent : fs.getpath(parent), name);
        var mode = fs.getmode(canread, canwrite);
        return fs.mkdir(path, mode);
      },createpath:function (parent, path, canread, canwrite) {
        parent = typeof parent === 'string' ? parent : fs.getpath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = path.join2(parent, part);
          try {
            fs.mkdir(current);
          } catch (e) {
            // ignore eexist
          }
          parent = current;
        }
        return current;
      },createfile:function (parent, name, properties, canread, canwrite) {
        var path = path.join2(typeof parent === 'string' ? parent : fs.getpath(parent), name);
        var mode = fs.getmode(canread, canwrite);
        return fs.create(path, mode);
      },createdatafile:function (parent, name, data, canread, canwrite, canown) {
        var path = name ? path.join2(typeof parent === 'string' ? parent : fs.getpath(parent), name) : parent;
        var mode = fs.getmode(canread, canwrite);
        var node = fs.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charcodeat(i);
            data = arr;
          }
          // make sure we can write to the file
          fs.chmod(node, mode | 146);
          var stream = fs.open(node, 'w');
          fs.write(stream, data, 0, data.length, 0, canown);
          fs.close(stream);
          fs.chmod(node, mode);
        }
        return node;
      },createdevice:function (parent, name, input, output) {
        var path = path.join2(typeof parent === 'string' ? parent : fs.getpath(parent), name);
        var mode = fs.getmode(!!input, !!output);
        if (!fs.createdevice.major) fs.createdevice.major = 64;
        var dev = fs.makedev(fs.createdevice.major++, 0);
        // create a fake device that a set of stream ops to emulate
        // the old behavior.
        fs.registerdevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesread = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new fs.errnoerror(errno_codes.eio);
              }
              if (result === undefined && bytesread === 0) {
                throw new fs.errnoerror(errno_codes.eagain);
              }
              if (result === null || result === undefined) break;
              bytesread++;
              buffer[offset+i] = result;
            }
            if (bytesread) {
              stream.node.timestamp = date.now();
            }
            return bytesread;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new fs.errnoerror(errno_codes.eio);
              }
            }
            if (length) {
              stream.node.timestamp = date.now();
            }
            return i;
          }
        });
        return fs.mkdev(path, mode, dev);
      },createlink:function (parent, name, target, canread, canwrite) {
        var path = path.join2(typeof parent === 'string' ? parent : fs.getpath(parent), name);
        return fs.symlink(target, path);
      },forceloadfile:function (obj) {
        if (obj.isdevice || obj.isfolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof xmlhttprequest !== 'undefined') {
          throw new error("lazy loading should have been performed (contents set) in createlazyfile, but it was not. lazy loading only works in web workers. use --embed-file or --preload-file in emcc on the main thread.");
        } else if (module['read']) {
          // command-line.
          try {
            // warning: can't read binary files in v8's d8 or tracemonkey's js, as
            //          read() will try to parse utf8.
            obj.contents = intarrayfromstring(module['read'](obj.url), true);
            obj.usedbytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new error('cannot load without read() or xmlhttprequest.');
        }
        if (!success) ___seterrno(errno_codes.eio);
        return success;
      },createlazyfile:function (parent, name, url, canread, canwrite) {
        // lazy chunked uint8array (implements get and length from uint8array). actual getting is abstracted away for eventual reuse.
        function lazyuint8array() {
          this.lengthknown = false;
          this.chunks = []; // loaded chunks. index is the chunk number
        }
        lazyuint8array.prototype.get = function lazyuint8array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkoffset = idx % this.chunksize;
          var chunknum = (idx / this.chunksize)|0;
          return this.getter(chunknum)[chunkoffset];
        }
        lazyuint8array.prototype.setdatagetter = function lazyuint8array_setdatagetter(getter) {
          this.getter = getter;
        }
        lazyuint8array.prototype.cachelength = function lazyuint8array_cachelength() {
          // find length
          var xhr = new xmlhttprequest();
          xhr.open('head', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new error("couldn't load " + url + ". status: " + xhr.status);
          var datalength = number(xhr.getresponseheader("content-length"));
          var header;
          var hasbyteserving = (header = xhr.getresponseheader("accept-ranges")) && header === "bytes";
          var usesgzip = (header = xhr.getresponseheader("content-encoding")) && header === "gzip";
  
          var chunksize = 1024*1024; // chunk size in bytes
  
          if (!hasbyteserving) chunksize = datalength;
  
          // function to get a range from the remote url.
          var doxhr = (function(from, to) {
            if (from > to) throw new error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new error("only " + datalength + " bytes available! programmer error!");
  
            // todo: use mozresponsearraybuffer, responsestream, etc. if available.
            var xhr = new xmlhttprequest();
            xhr.open('get', url, false);
            if (datalength !== chunksize) xhr.setrequestheader("range", "bytes=" + from + "-" + to);
  
            // some hints to the browser that we want binary data.
            if (typeof uint8array != 'undefined') xhr.responsetype = 'arraybuffer';
            if (xhr.overridemimetype) {
              xhr.overridemimetype('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new error("couldn't load " + url + ". status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new uint8array(xhr.response || []);
            } else {
              return intarrayfromstring(xhr.responsetext || '', true);
            }
          });
          var lazyarray = this;
          lazyarray.setdatagetter(function(chunknum) {
            var start = chunknum * chunksize;
            var end = (chunknum+1) * chunksize - 1; // including this byte
            end = math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyarray.chunks[chunknum]) === "undefined") {
              lazyarray.chunks[chunknum] = doxhr(start, end);
            }
            if (typeof(lazyarray.chunks[chunknum]) === "undefined") throw new error("doxhr failed!");
            return lazyarray.chunks[chunknum];
          });
  
          if (usesgzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunksize = datalength = 1; // this will force getter(0)/doxhr do download the whole file
            datalength = this.getter(0).length;
            chunksize = datalength;
            console.log("lazyfiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunksize = chunksize;
          this.lengthknown = true;
        }
        if (typeof xmlhttprequest !== 'undefined') {
          if (!environment_is_worker) throw 'cannot do synchronous binary xhrs outside webworkers in modern browsers. use --embed-file or --preload-file in emcc';
          var lazyarray = new lazyuint8array();
          object.defineproperties(lazyarray, {
            length: {
              get: function() {
                if(!this.lengthknown) {
                  this.cachelength();
                }
                return this._length;
              }
            },
            chunksize: {
              get: function() {
                if(!this.lengthknown) {
                  this.cachelength();
                }
                return this._chunksize;
              }
            }
          });
  
          var properties = { isdevice: false, contents: lazyarray };
        } else {
          var properties = { isdevice: false, url: url };
        }
  
        var node = fs.createfile(parent, name, properties, canread, canwrite);
        // this is a total hack, but i want to get this lazy file code out of the
        // core of memfs. if we want to keep this lazy file concept i feel it should
        // be its own thin lazyfs proxying calls to memfs.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // add a function that defers querying the file size until it is asked the first time.
        object.defineproperties(node, {
          usedbytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = object.keys(node.stream_ops);
        keys.foreach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceloadlazyfile() {
            if (!fs.forceloadfile(node)) {
              throw new fs.errnoerror(errno_codes.eio);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!fs.forceloadfile(node)) {
            throw new fs.errnoerror(errno_codes.eio);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // lazyuint8array from sync binary xhr
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createpreloadedfile:function (parent, name, url, canread, canwrite, onload, onerror, dontcreatefile, canown, prefinish) {
        browser.init(); // xxx perhaps this method should move onto browser?
        // todo we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? path.resolve(path.join2(parent, name)) : parent;
        var dep = getuniquerundependency('cp ' + fullname); // might have several active requests for the same fullname
        function processdata(bytearray) {
          function finish(bytearray) {
            if (prefinish) prefinish();
            if (!dontcreatefile) {
              fs.createdatafile(parent, name, bytearray, canread, canwrite, canown);
            }
            if (onload) onload();
            removerundependency(dep);
          }
          var handled = false;
          module['preloadplugins'].foreach(function(plugin) {
            if (handled) return;
            if (plugin['canhandle'](fullname)) {
              plugin['handle'](bytearray, fullname, finish, function() {
                if (onerror) onerror();
                removerundependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(bytearray);
        }
        addrundependency(dep);
        if (typeof url == 'string') {
          browser.asyncload(url, function(bytearray) {
            processdata(bytearray);
          }, onerror);
        } else {
          processdata(url);
        }
      },indexeddb:function () {
        return module.indexeddb;
      },db_name:function () {
        return 'em_fs_' + window.location.pathname;
      },db_version:20,db_store_name:"file_data",savefilestodb:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexeddb = fs.indexeddb();
        try {
          var openrequest = indexeddb.open(fs.db_name(), fs.db_version);
        } catch (e) {
          return onerror(e);
        }
        openrequest.onupgradeneeded = function openrequest_onupgradeneeded() {
          console.log('creating db');
          var db = openrequest.result;
          db.createobjectstore(fs.db_store_name);
        };
        openrequest.onsuccess = function openrequest_onsuccess() {
          var db = openrequest.result;
          var transaction = db.transaction([fs.db_store_name], 'readwrite');
          var files = transaction.objectstore(fs.db_store_name);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.foreach(function(path) {
            var putrequest = files.put(fs.analyzepath(path).object.contents, path);
            putrequest.onsuccess = function putrequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putrequest.onerror = function putrequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openrequest.onerror = onerror;
      },loadfilesfromdb:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexeddb = fs.indexeddb();
        try {
          var openrequest = indexeddb.open(fs.db_name(), fs.db_version);
        } catch (e) {
          return onerror(e);
        }
        openrequest.onupgradeneeded = onerror; // no database to load from
        openrequest.onsuccess = function openrequest_onsuccess() {
          var db = openrequest.result;
          try {
            var transaction = db.transaction([fs.db_store_name], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectstore(fs.db_store_name);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.foreach(function(path) {
            var getrequest = files.get(path);
            getrequest.onsuccess = function getrequest_onsuccess() {
              if (fs.analyzepath(path).exists) {
                fs.unlink(path);
              }
              fs.createdatafile(path.dirname(path), path.basename(path), getrequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getrequest.onerror = function getrequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openrequest.onerror = onerror;
      }};function _utime(path, times) {
      // int utime(const char *path, const struct utimbuf *times);
      // http://pubs.opengroup.org/onlinepubs/009695399/basedefs/utime.h.html
      var time;
      if (times) {
        // note: we don't keep track of access timestamps.
        var offset = 4;
        time = heap32[(((times)+(offset))>>2)];
        time *= 1000;
      } else {
        time = date.now();
      }
      path = pointer_stringify(path);
      try {
        fs.utime(path, time, time);
        return 0;
      } catch (e) {
        fs.handlefserror(e);
        return -1;
      }
    }

  function _emscripten_glcopyteximage2d(x0, x1, x2, x3, x4, x5, x6, x7) { glctx['copyteximage2d'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _emscripten_set_devicemotion_callback(userdata, usecapture, callbackfunc) {
      jsevents.registerdevicemotioneventcallback(window, userdata, usecapture, callbackfunc, 17, "devicemotion");
      return 0;
    }

  function _js_systeminfo_hasfullscreen() 
  	{
  		return unityloader.systeminfo.hasfullscreen;
  	}

  function _emscripten_gltexparameterfv(target, pname, params) {
      var param = heapf32[((params)>>2)];
      glctx.texparameterf(target, pname, param);
    }

  function _emscripten_gldepthrangef(x0, x1) { glctx['depthrange'](x0, x1) }

  
  var syscalls={default_pollmask:5,mappings:{},umask:511,calculateat:function (dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = fs.cwd();
          } else {
            var dirstream = fs.getstream(dirfd);
            if (!dirstream) throw new fs.errnoerror(errno_codes.ebadf);
            dir = dirstream.path;
          }
          path = path.join2(dir, path);
        }
        return path;
      },dostat:function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && path.normalize(path) !== path.normalize(fs.getpath(e.node))) {
            // an error occurred while trying to look up the path; we should just report enotdir
            return -errno_codes.enotdir;
          }
          throw e;
        }
        heap32[((buf)>>2)]=stat.dev;
        heap32[(((buf)+(4))>>2)]=0;
        heap32[(((buf)+(8))>>2)]=stat.ino;
        heap32[(((buf)+(12))>>2)]=stat.mode;
        heap32[(((buf)+(16))>>2)]=stat.nlink;
        heap32[(((buf)+(20))>>2)]=stat.uid;
        heap32[(((buf)+(24))>>2)]=stat.gid;
        heap32[(((buf)+(28))>>2)]=stat.rdev;
        heap32[(((buf)+(32))>>2)]=0;
        heap32[(((buf)+(36))>>2)]=stat.size;
        heap32[(((buf)+(40))>>2)]=4096;
        heap32[(((buf)+(44))>>2)]=stat.blocks;
        heap32[(((buf)+(48))>>2)]=(stat.atime.gettime() / 1000)|0;
        heap32[(((buf)+(52))>>2)]=0;
        heap32[(((buf)+(56))>>2)]=(stat.mtime.gettime() / 1000)|0;
        heap32[(((buf)+(60))>>2)]=0;
        heap32[(((buf)+(64))>>2)]=(stat.ctime.gettime() / 1000)|0;
        heap32[(((buf)+(68))>>2)]=0;
        heap32[(((buf)+(72))>>2)]=stat.ino;
        return 0;
      },domsync:function (addr, stream, len, flags) {
        var buffer = new uint8array(heapu8.subarray(addr, addr + len));
        fs.msync(stream, buffer, 0, len, flags);
      },domkdir:function (path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = path.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        fs.mkdir(path, mode, 0);
        return 0;
      },domknod:function (path, mode, dev) {
        // we don't want this in the js api as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -errno_codes.einval;
        }
        fs.mknod(path, mode, dev);
        return 0;
      },doreadlink:function (path, buf, bufsize) {
        if (bufsize <= 0) return -errno_codes.einval;
        var ret = fs.readlink(path);
  
        var len = math.min(bufsize, lengthbytesutf8(ret));
        var endchar = heap8[buf+len];
        stringtoutf8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a c string, but does never append a null to the output buffer(!)
        // stringtoutf8() always appends a null byte, so restore the character under the null byte after the write.
        heap8[buf+len] = endchar;
  
        return len;
      },doaccess:function (path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -errno_codes.einval;
        }
        var node;
        var lookup = fs.lookuppath(path, { follow: true });
        node = lookup.node;
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed f_ok */ && fs.nodepermissions(node, perms)) {
          return -errno_codes.eacces;
        }
        return 0;
      },dodup:function (path, flags, suggestfd) {
        var suggest = fs.getstream(suggestfd);
        if (suggest) fs.close(suggest);
        return fs.open(path, flags, 0, suggestfd, suggestfd).fd;
      },doreadv:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = heap32[(((iov)+(i*8))>>2)];
          var len = heap32[(((iov)+(i*8 + 4))>>2)];
          var curr = fs.read(stream, heap8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },dowritev:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = heap32[(((iov)+(i*8))>>2)];
          var len = heap32[(((iov)+(i*8 + 4))>>2)];
          var curr = fs.write(stream, heap8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:0,get:function (varargs) {
        syscalls.varargs += 4;
        var ret = heap32[(((syscalls.varargs)-(4))>>2)];
        return ret;
      },getstr:function () {
        var ret = pointer_stringify(syscalls.get());
        return ret;
      },getstreamfromfd:function () {
        var stream = fs.getstream(syscalls.get());
        if (!stream) throw new fs.errnoerror(errno_codes.ebadf);
        return stream;
      },getsocketfromfd:function () {
        var socket = sockfs.getsocket(syscalls.get());
        if (!socket) throw new fs.errnoerror(errno_codes.ebadf);
        return socket;
      },getsocketaddress:function (allownull) {
        var addrp = syscalls.get(), addrlen = syscalls.get();
        if (allownull && addrp === 0) return null;
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new fs.errnoerror(info.errno);
        info.addr = dns.lookup_addr(info.addr) || info.addr;
        return info;
      },get64:function () {
        var low = syscalls.get(), high = syscalls.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      },getzero:function () {
        assert(syscalls.get() === 0);
      }};function ___syscall168(which, varargs) {syscalls.varargs = varargs;
  try {
   // poll
      var fds = syscalls.get(), nfds = syscalls.get(), timeout = syscalls.get();
      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = heap32[((pollfd)>>2)];
        var events = heap16[(((pollfd)+(4))>>1)];
        var mask = 32;
        var stream = fs.getstream(fd);
        if (stream) {
          mask = syscalls.default_pollmask;
          if (stream.stream_ops.poll) {
            mask = stream.stream_ops.poll(stream);
          }
        }
        mask &= events | 8 | 16;
        if (mask) nonzero++;
        heap16[(((pollfd)+(6))>>1)]=mask;
      }
      return nonzero;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _js_systeminfo_getbrowsername(buffer, buffersize) 
  	{
  		var browser = unityloader.systeminfo.browser;
  		if (buffer)
  			stringtoutf8(browser, buffer, buffersize);
  		return lengthbytesutf8(browser);
  	}

  function _emscripten_glgetobjectparameterivarb() {
  module['printerr']('missing function: emscripten_glgetobjectparameterivarb'); abort(-1);
  }

  function _glcreateshader(shadertype) {
      var id = gl.getnewid(gl.shaders);
      gl.shaders[id] = glctx.createshader(shadertype);
      return id;
    }

  function _emscripten_glbindattriblocation(program, index, name) {
      name = pointer_stringify(name);
      glctx.bindattriblocation(gl.programs[program], index, name);
    }

  function _glgenrenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var renderbuffer = glctx.createrenderbuffer();
        if (!renderbuffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((renderbuffers)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.renderbuffers);
        renderbuffer.name = id;
        gl.renderbuffers[id] = renderbuffer;
        heap32[(((renderbuffers)+(i*4))>>2)]=id;
      }
    }

  function _glcompressedteximage2d(target, level, internalformat, width, height, border, imagesize, data) {
      var heapview;
      if (data) {
        heapview = heapu8.subarray((data),(data+imagesize));
      } else {
        heapview = null;
      }
      glctx['compressedteximage2d'](target, level, internalformat, width, height, border, heapview);
    }

  function _glblendfuncseparate(x0, x1, x2, x3) { glctx['blendfuncseparate'](x0, x1, x2, x3) }

   
  module["_memset"] = _memset;

  function _gldrawbuffers(n, bufs) {
      var bufarray = [];
      for (var i = 0; i < n; i++)
        bufarray.push(heap32[(((bufs)+(i*4))>>2)]);
  
      glctx['drawbuffers'](bufarray);
    }

  function _js_systeminfo_hascursorlock() 
  	{
  		return unityloader.systeminfo.hascursorlock;
  	}


  
  var wr={requestinstances:{},nextrequestid:1};function _js_webrequest_send(request, ptr, length)
  	{
  		var http = wr.requestinstances[request];
  
  		try {
  			if (length > 0)
  				http.send(heapu8.subarray(ptr, ptr+length));
  			else
  				http.send();
  		}
  		catch(e) {
  			console.error(e.name + ": " + e.message);
  		}
  	}

  function ___lock() {}

  function _emscripten_glgetvertexattribpointerv(index, pname, pointer) {
      if (!pointer) {
        // gles2 specification does not specify how to behave if pointer is a null pointer. since calling this function does not make sense
        // if pointer == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((pointer)>>2)]=glctx.getvertexattriboffset(index, pname);
    }

  function _emscripten_glvertexattrib3f(x0, x1, x2, x3) { glctx['vertexattrib3f'](x0, x1, x2, x3) }

  function _clock() {
      if (_clock.start === undefined) _clock.start = date.now();
      return ((date.now() - _clock.start) * (1000000 / 1000))|0;
    }

  var _llvm_ctlz_i32=true;

  function _gldeleteprogram(id) {
      if (!id) return;
      var program = gl.programs[id];
      if (!program) { // gldeleteprogram actually signals an error when deleting a nonexisting object, unlike some other gl delete functions.
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      glctx.deleteprogram(program);
      program.name = 0;
      gl.programs[id] = null;
      gl.programinfos[id] = null;
    }

  function _glrenderbufferstorage(x0, x1, x2, x3) { glctx['renderbufferstorage'](x0, x1, x2, x3) }

  
  var webaudio={audioinstances:[],audiocontext:{},audiowebenabled:0};function _js_sound_setlistenerposition(x, y, z)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	webaudio.audiocontext.listener.setposition(x, y, z);
  }

  function _js_webgl_initcontextattributes(attributes) 
      {
          // we want alpha in the back buffer so that we match expected unity output.
          // but the browsers will use alpha to blend with the web page, so we have to
          // make sure we clear it before blitting.
          heap32[((attributes)>>2)]=1;
          heap32[(((attributes)+(4))>>2)]=1;
          heap32[(((attributes)+(8))>>2)]=1;
          heap32[(((attributes)+(12))>>2)]=0;
          heap32[(((attributes)+(16))>>2)]=1;
          heap32[(((attributes)+(20))>>2)]=module.webglcontextattributes.preservedrawingbuffer;
          heap32[(((attributes)+(24))>>2)]=0;
          heap32[(((attributes)+(28))>>2)]=0;
          heap32[(((attributes)+(32))>>2)]=1;
          heap32[(((attributes)+(36))>>2)]=0;
          heap32[(((attributes)+(40))>>2)]=1;
          heap32[(((attributes)+(44))>>2)]=0;
  
          return 0;
      }

  function _emscripten_set_touchstart_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registertoucheventcallback(target, userdata, usecapture, callbackfunc, 22, "touchstart");
      return 0;
    }

  function _emscripten_gldeleteshader(id) {
      if (!id) return;
      var shader = gl.shaders[id];
      if (!shader) { // gldeleteshader actually signals an error when deleting a nonexisting object, unlike some other gl delete functions.
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      glctx.deleteshader(shader);
      gl.shaders[id] = null;
    }

  function _pthread_attr_init(attr) {
      /* int pthread_attr_init(pthread_attr_t *attr); */
      //fixme: should allocate a pthread_attr_t
      return 0;
    }

  function _emscripten_gldrawarraysinstanced(mode, first, count, primcount) {
      glctx['drawarraysinstanced'](mode, first, count, primcount);
    }

  function _emscripten_gldeletebuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((buffers)+(i*4))>>2)];
        var buffer = gl.buffers[id];
  
        // from spec: "gldeletebuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        glctx.deletebuffer(buffer);
        buffer.name = 0;
        gl.buffers[id] = null;
  
        if (id == gl.currarraybuffer) gl.currarraybuffer = 0;
        if (id == gl.currelementarraybuffer) gl.currelementarraybuffer = 0;
      }
    }

  function _emscripten_gltexparameteriv(target, pname, params) {
      var param = heap32[((params)>>2)];
      glctx.texparameteri(target, pname, param);
    }

  function _emscripten_gluniformmatrix2fv(location, count, transpose, value) {
      location = gl.uniforms[location];
      var view;
      if (4*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*16)>>2);
      }
      glctx.uniformmatrix2fv(location, !!transpose, view);
    }

  function ___syscall5(which, varargs) {syscalls.varargs = varargs;
  try {
   // open
      var pathname = syscalls.getstr(), flags = syscalls.get(), mode = syscalls.get() // optional todo
      var stream = fs.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall4(which, varargs) {syscalls.varargs = varargs;
  try {
   // write
      var stream = syscalls.getstreamfromfd(), buf = syscalls.get(), count = syscalls.get();
      return fs.write(stream, heap8,buf, count);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall6(which, varargs) {syscalls.varargs = varargs;
  try {
   // close
      var stream = syscalls.getstreamfromfd();
      fs.close(stream);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _glgenvertexarrays(n, arrays) {
  
      for (var i = 0; i < n; i++) {
        var vao = glctx['createvertexarray']();
        if (!vao) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((arrays)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.vaos);
        vao.name = id;
        gl.vaos[id] = vao;
        heap32[(((arrays)+(i*4))>>2)]=id;
      }
    }

  function _gltexstorage3d(x0, x1, x2, x3, x4, x5) { glctx['texstorage3d'](x0, x1, x2, x3, x4, x5) }

  function _emscripten_glenableclientstate() {
  module['printerr']('missing function: emscripten_glenableclientstate'); abort(-1);
  }

  function _gldetachshader(program, shader) {
      glctx.detachshader(gl.programs[program],
                              gl.shaders[shader]);
    }

  function _emscripten_glstencilmask(x0) { glctx['stencilmask'](x0) }

  function _js_sound_setlistenerorientation(x, y, z, xup, yup, zup)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	// web audio uses a rhs coordinate system, unity uses lhs, causing orientations to be flipped.
  	// so we pass a negative direction here to compensate, otherwise channels will be flipped.
  	webaudio.audiocontext.listener.setorientation(-x, -y, -z, xup, yup, zup);
  }

  function _js_eval_settimeout(func, arg, millis)
  {
      module['noexitruntime'] = true;
  
      function wrapper() {
        runtime.getfuncwrapper(func, 'vi')(arg);
      }
  
  	return browser.safesettimeout(wrapper, millis);
  }

  function _js_eval_evaljs(ptr)
  {
  	var str = pointer_stringify(ptr);
  	try {
  		eval (str);
  	}
  	catch (exception)
  	{
  		console.error(exception);
  	}
  }

  function _gldeleteframebuffers(n, framebuffers) {
      for (var i = 0; i < n; ++i) {
        var id = heap32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = gl.framebuffers[id];
        if (!framebuffer) continue; // gl spec: "gldeleteframebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        glctx.deleteframebuffer(framebuffer);
        framebuffer.name = 0;
        gl.framebuffers[id] = null;
      }
    }

  function _gldrawarrays(mode, first, count) {
  
      glctx.drawarrays(mode, first, count);
  
    }

  function _emscripten_webgl_enable_extension(contexthandle, extension) {
      var context = gl.getcontext(contexthandle);
      var extstring = pointer_stringify(extension);
      if (extstring.indexof('gl_') == 0) extstring = extstring.substr(3); // allow enabling extensions both with "gl_" prefix and without.
      var ext = context.glctx.getextension(extstring);
      return ext ? 1 : 0;
    }

  function _emscripten_get_num_gamepads() {
      __emscripten_sample_gamepad_data();
      if (!jsevents.lastgamepadstate) return -1;
      return jsevents.lastgamepadstate.length;
    }

  function _emscripten_set_blur_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registerfocuseventcallback(target, userdata, usecapture, callbackfunc, 12, "blur");
      return 0;
    }

  function _mktime(tmptr) {
      _tzset();
      var date = new date(heap32[(((tmptr)+(20))>>2)] + 1900,
                          heap32[(((tmptr)+(16))>>2)],
                          heap32[(((tmptr)+(12))>>2)],
                          heap32[(((tmptr)+(8))>>2)],
                          heap32[(((tmptr)+(4))>>2)],
                          heap32[((tmptr)>>2)],
                          0);
  
      // there's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = heap32[(((tmptr)+(32))>>2)];
      var guessedoffset = date.gettimezoneoffset();
      var start = new date(date.getfullyear(), 0, 1);
      var summeroffset = new date(2000, 6, 1).gettimezoneoffset();
      var winteroffset = start.gettimezoneoffset();
      var dstoffset = math.min(winteroffset, summeroffset); // dst is in december in south
      if (dst < 0) {
        heap32[(((tmptr)+(32))>>2)]=number(dstoffset == guessedoffset);
      } else if ((dst > 0) != (dstoffset == guessedoffset)) {
        var nondstoffset = math.max(winteroffset, summeroffset);
        var trueoffset = dst > 0 ? dstoffset : nondstoffset;
        // don't try setminutes(date.getminutes() + ...) -- it's messed up.
        date.settime(date.gettime() + (trueoffset - guessedoffset)*60000);
      }
  
      heap32[(((tmptr)+(24))>>2)]=date.getday();
      var yday = ((date.gettime() - start.gettime()) / (1000 * 60 * 60 * 24))|0;
      heap32[(((tmptr)+(28))>>2)]=yday;
  
      return (date.gettime() / 1000)|0;
    }

  function _sched_yield() {
      return 0;
    }

  function _glclear(x0) { glctx['clear'](x0) }

  function _emscripten_webgl_make_context_current(contexthandle) {
      var success = gl.makecontextcurrent(contexthandle);
      return success ? 0 : -5;
    }

  function _gluniform2iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 2;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform2iv(location, value);
    }

  function _glisenabled(x0) { return glctx['isenabled'](x0) }

  function _glframebuffertexture2d(target, attachment, textarget, texture, level) {
      glctx.framebuffertexture2d(target, attachment, textarget,
                                      gl.textures[texture], level);
    }

  function _glgetframebufferattachmentparameteriv(target, attachment, pname, params) {
      var result = glctx.getframebufferattachmentparameter(target, attachment, pname);
      heap32[((params)>>2)]=result;
    }

  function _emscripten_request_pointerlock(target, deferuntilineventhandler) {
      if (!target) target = '#canvas';
      target = jsevents.findeventtarget(target);
      if (!target) return -4;
      if (!target.requestpointerlock && !target.mozrequestpointerlock && !target.webkitrequestpointerlock && !target.msrequestpointerlock) {
        return -1;
      }
  
      var canperformrequests = jsevents.canperformeventhandlerrequests();
  
      // queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canperformrequests) {
        if (deferuntilineventhandler) {
          jsevents.defercall(jsevents.requestpointerlock, 2 /* priority below fullscreen */, [target]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return jsevents.requestpointerlock(target);
    }

  function _glbindbufferbase(target, index, buffer) {
      var bufferobj = buffer ? gl.buffers[buffer] : null;
      glctx['bindbufferbase'](target, index, bufferobj);
    }

   
  module["_pthread_cond_broadcast"] = _pthread_cond_broadcast;

  function _gettimeofday(ptr) {
      var now = date.now();
      heap32[((ptr)>>2)]=(now/1000)|0; // seconds
      heap32[(((ptr)+(4))>>2)]=((now % 1000)*1000)|0; // microseconds
      return 0;
    }

  function _gltexparameteriv(target, pname, params) {
      var param = heap32[((params)>>2)];
      glctx.texparameteri(target, pname, param);
    }

  function _js_sound_setvolume(channelinstance, v)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	webaudio.audioinstances[channelinstance].gain.gain.value = v;
  }

  function _glgenframebuffers(n, ids) {
      for (var i = 0; i < n; ++i) {
        var framebuffer = glctx.createframebuffer();
        if (!framebuffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.framebuffers);
        framebuffer.name = id;
        gl.framebuffers[id] = framebuffer;
        heap32[(((ids)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_glgettexparameteriv(target, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((params)>>2)]=glctx.gettexparameter(target, pname);
    }

  function ___syscall122(which, varargs) {syscalls.varargs = varargs;
  try {
   // uname
      var buf = syscalls.get();
      if (!buf) return -errno_codes.efault
      var layout = {"sysname":0,"nodename":65,"domainname":325,"machine":260,"version":195,"release":130,"__size__":390};
      function copystring(element, value) {
        var offset = layout[element];
        writeasciitomemory(value, buf + offset);
      }
      copystring('sysname', 'emscripten');
      copystring('nodename', 'emscripten');
      copystring('release', '1.0');
      copystring('version', '#1');
      copystring('machine', 'x86-js');
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _abort() {
      module['abort']();
    }

  function _gldeletevertexarrays(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((vaos)+(i*4))>>2)];
        glctx['deletevertexarray'](gl.vaos[id]);
        gl.vaos[id] = null;
      }
    }

  function _emscripten_glsamplecoverage(value, invert) {
      glctx.samplecoverage(value, !!invert);
    }

  function _glisvertexarray(array) {
  
      var vao = gl.vaos[array];
      if (!vao) return 0;
      return glctx['isvertexarray'](vao);
    }

  function _gldisablevertexattribarray(index) {
      glctx.disablevertexattribarray(index);
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return page_size;
        case 85: return totalmemory / page_size;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 79:
          return 0;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareconcurrency'] || 1;
          return 1;
        }
      }
      ___seterrno(errno_codes.einval);
      return -1;
    }

  function _emscripten_glmatrixmode(){ throw 'legacy gl function (glmatrixmode) called. if you want legacy gl emulation, you need to compile with -s legacy_gl_emulation=1 to enable legacy gl emulation.'; }

  function _glgetuniformindices(program, uniformcount, uniformnames, uniformindices) {
      if (!uniformindices) {
        // gles2 specification does not specify how to behave if uniformindices is a null pointer. since calling this function does not make sense
        // if uniformindices == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      if (uniformcount > 0 && (uniformnames == 0 || uniformindices == 0)) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      program = gl.programs[program];
      var names = [];
      for (var i = 0; i < uniformcount; i++)
        names.push(pointer_stringify(heap32[(((uniformnames)+(i*4))>>2)]));
  
      var result = glctx['getuniformindices'](program, names);
      if (!result) return; // gl spec: if an error is generated, nothing is written out to uniformindices.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        heap32[(((uniformindices)+(i*4))>>2)]=result[i];
      }
    }

  function _js_log_dump(ptr, type)
  {
  	var str = pointer_stringify(ptr);
  	if (typeof dump == 'function')
  		dump (str);
  	switch (type)
  	{
  		case 0: //logtype_error
  		case 1: //logtype_assert
  		case 4: //logtype_exception
  			console.error (str);
  			return;
  
  		case 2: //logtype_warning
  			console.warn (str);
  			return;
  
  		case 3: //logtype_log
  		case 5: //logtype_debug
  			console.log (str);
  			return;			
  
  		default:
  			console.error ("unknown console message type!")
  			console.error (str);
  	}
  }

  function _emscripten_glpolygonoffset(x0, x1) { glctx['polygonoffset'](x0, x1) }

  function _gldisable(x0) { glctx['disable'](x0) }

  function _emscripten_glisbuffer(buffer) {
      var b = gl.buffers[buffer];
      if (!b) return 0;
      return glctx.isbuffer(b);
    }

  
  var pthread_specific={};function _pthread_getspecific(key) {
      return pthread_specific[key] || 0;
    }

  function _glenable(x0) { glctx['enable'](x0) }

  function _glgetactiveuniformsiv(program, uniformcount, uniformindices, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      if (uniformcount > 0 && uniformindices == 0) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      program = gl.programs[program];
      var ids = [];
      for (var i = 0; i < uniformcount; i++) {
        ids.push(heap32[(((uniformindices)+(i*4))>>2)]);
      }
  
      var result = glctx['getactiveuniforms'](program, ids, pname);
      if (!result) return; // gl spec: if an error is generated, nothing is written out to params.
  
      var len = result.length;
      for (var i = 0; i < len; i++) {
        heap32[(((params)+(i*4))>>2)]=result[i];
      }
    }

  
  
  function emscriptenwebglcomputeimagesize(width, height, sizeperpixel, alignment) {
      function roundedtonextmultipleof(x, y) {
        return math.floor((x + y - 1) / y) * y
      }
      var plainrowsize = width * sizeperpixel;
      var alignedrowsize = roundedtonextmultipleof(plainrowsize, alignment);
      return (height <= 0) ? 0 :
               ((height - 1) * alignedrowsize + plainrowsize);
    }function emscriptenwebglgettexpixeldata(type, format, width, height, pixels, internalformat) {
      var sizeperpixel;
      var numchannels;
      switch(format) {
        case 0x1906 /* gl_alpha */:
        case 0x1909 /* gl_luminance */:
        case 0x1902 /* gl_depth_component */:
        case 0x1903 /* gl_red */:
        case 0x8d94 /* gl_red_integer */:
          numchannels = 1;
          break;
        case 0x190a /* gl_luminance_alpha */:
        case 0x8227 /* gl_rg */:
        case 0x8228 /* gl_rg_integer*/:
          numchannels = 2;
          break;
        case 0x1907 /* gl_rgb */:
        case 0x8c40 /* gl_srgb_ext */:
        case 0x8d98 /* gl_rgb_integer */:
          numchannels = 3;
          break;
        case 0x1908 /* gl_rgba */:
        case 0x8c42 /* gl_srgb_alpha_ext */:
        case 0x8d99 /* gl_rgba_integer */:
          numchannels = 4;
          break;
        default:
          gl.recorderror(0x0500); // gl_invalid_enum
          return null;
      }
      switch (type) {
        case 0x1401 /* gl_unsigned_byte */:
        case 0x1400 /* gl_byte */:
          sizeperpixel = numchannels*1;
          break;
        case 0x1403 /* gl_unsigned_short */:
        case 0x8d61 /* gl_half_float_oes */:
        case 0x140b /* gl_half_float */:
        case 0x1402 /* gl_short */:
          sizeperpixel = numchannels*2;
          break;
        case 0x1405 /* gl_unsigned_int */:
        case 0x1406 /* gl_float */:
        case 0x1404 /* gl_int */:
          sizeperpixel = numchannels*4;
          break;
        case 0x84fa /* gl_unsigned_int_24_8_webgl/gl_unsigned_int_24_8 */:
        case 0x8c3e /* gl_unsigned_int_5_9_9_9_rev */:
        case 0x8368 /* gl_unsigned_int_2_10_10_10_rev */:
        case 0x8c3b /* gl_unsigned_int_10f_11f_11f_rev */:
        case 0x84fa /* gl_unsigned_int_24_8 */:
          sizeperpixel = 4;
          break;
        case 0x8363 /* gl_unsigned_short_5_6_5 */:
        case 0x8033 /* gl_unsigned_short_4_4_4_4 */:
        case 0x8034 /* gl_unsigned_short_5_5_5_1 */:
          sizeperpixel = 2;
          break;
        default:
          gl.recorderror(0x0500); // gl_invalid_enum
          return null;
      }
      var bytes = emscriptenwebglcomputeimagesize(width, height, sizeperpixel, gl.unpackalignment);
      switch(type) {
        case 0x1400 /* gl_byte */:
          return heap8.subarray((pixels),(pixels+bytes));
        case 0x1401 /* gl_unsigned_byte */:
          return heapu8.subarray((pixels),(pixels+bytes));
        case 0x1402 /* gl_short */:
          return heap16.subarray((pixels)>>1,(pixels+bytes)>>1);
        case 0x1404 /* gl_int */:
          return heap32.subarray((pixels)>>2,(pixels+bytes)>>2);
        case 0x1406 /* gl_float */:
          return heapf32.subarray((pixels)>>2,(pixels+bytes)>>2);
        case 0x1405 /* gl_unsigned_int */:
        case 0x84fa /* gl_unsigned_int_24_8_webgl/gl_unsigned_int_24_8 */:
        case 0x8c3e /* gl_unsigned_int_5_9_9_9_rev */:
        case 0x8368 /* gl_unsigned_int_2_10_10_10_rev */:
        case 0x8c3b /* gl_unsigned_int_10f_11f_11f_rev */:
        case 0x84fa /* gl_unsigned_int_24_8 */:
          return heapu32.subarray((pixels)>>2,(pixels+bytes)>>2);
        case 0x1403 /* gl_unsigned_short */:
        case 0x8363 /* gl_unsigned_short_5_6_5 */:
        case 0x8033 /* gl_unsigned_short_4_4_4_4 */:
        case 0x8034 /* gl_unsigned_short_5_5_5_1 */:
        case 0x8d61 /* gl_half_float_oes */:
        case 0x140b /* gl_half_float */:
          return heapu16.subarray((pixels)>>1,(pixels+bytes)>>1);
        default:
          gl.recorderror(0x0500); // gl_invalid_enum
          return null;
      }
    }function _emscripten_gltexsubimage2d(target, level, xoffset, yoffset, width, height, format, type, pixels) {
      var pixeldata = null;
      if (pixels) pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, 0);
      glctx.texsubimage2d(target, level, xoffset, yoffset, width, height, format, type, pixeldata);
    }

  function _emscripten_gluniform2f(location, v0, v1) {
      location = gl.uniforms[location];
      glctx.uniform2f(location, v0, v1);
    }

  function _glgetattriblocation(program, name) {
      program = gl.programs[program];
      name = pointer_stringify(name);
      return glctx.getattriblocation(program, name);
    }

  function _emscripten_gluniform2i(location, v0, v1) {
      location = gl.uniforms[location];
      glctx.uniform2i(location, v0, v1);
    }

  function _emscripten_gldeleterenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = gl.renderbuffers[id];
        if (!renderbuffer) continue; // gl spec: "gldeleterenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        glctx.deleterenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        gl.renderbuffers[id] = null;
      }
    }

  function ___cxa_pure_virtual() {
      abort = true;
      throw 'pure virtual function called!';
    }

  
  
  
  
  var _environ=statictop; statictop += 16;;var ___environ=_environ;function ___buildenvironment(env) {
      // warning: arbitrary limit!
      var max_env_values = 64;
      var total_env_size = 1024;
  
      // statically allocate memory for the environment.
      var poolptr;
      var envptr;
      if (!___buildenvironment.called) {
        ___buildenvironment.called = true;
        // set default values. use string keys for closure compiler compatibility.
        env['user'] = env['logname'] = 'web_user';
        env['path'] = '/';
        env['pwd'] = '/';
        env['home'] = '/home/web_user';
        env['lang'] = 'c';
        env['_'] = module['thisprogram'];
        // allocate memory.
        poolptr = allocate(total_env_size, 'i8', alloc_static);
        envptr = allocate(max_env_values * 4,
                          'i8*', alloc_static);
        heap32[((envptr)>>2)]=poolptr;
        heap32[((_environ)>>2)]=envptr;
      } else {
        envptr = heap32[((_environ)>>2)];
        poolptr = heap32[((envptr)>>2)];
      }
  
      // collect key=value lines.
      var strings = [];
      var totalsize = 0;
      for (var key in env) {
        if (typeof env[key] === 'string') {
          var line = key + '=' + env[key];
          strings.push(line);
          totalsize += line.length;
        }
      }
      if (totalsize > total_env_size) {
        throw new error('environment size exceeded total_env_size!');
      }
  
      // make new.
      var ptrsize = 4;
      for (var i = 0; i < strings.length; i++) {
        var line = strings[i];
        writeasciitomemory(line, poolptr);
        heap32[(((envptr)+(i * ptrsize))>>2)]=poolptr;
        poolptr += line.length + 1;
      }
      heap32[(((envptr)+(strings.length * ptrsize))>>2)]=0;
    }var env={};function _unsetenv(name) {
      // int unsetenv(const char *name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/unsetenv.html
      if (name === 0) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      name = pointer_stringify(name);
      if (name === '' || name.indexof('=') !== -1) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      if (env.hasownproperty(name)) {
        delete env[name];
        ___buildenvironment(env);
      }
      return 0;
    }

  function _emscripten_set_mousedown_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registermouseeventcallback(target, userdata, usecapture, callbackfunc, 5, "mousedown");
      return 0;
    }

  function _emscripten_gldepthrange(x0, x1) { glctx['depthrange'](x0, x1) }

  function _emscripten_set_fullscreenchange_callback(target, userdata, usecapture, callbackfunc) {
      if (typeof jsevents.fullscreenenabled() === 'undefined') return -1;
      if (!target) target = document;
      else {
        target = jsevents.findeventtarget(target);
        if (!target) return -4;
      }
      jsevents.registerfullscreenchangeeventcallback(target, userdata, usecapture, callbackfunc, 19, "fullscreenchange");
      jsevents.registerfullscreenchangeeventcallback(target, userdata, usecapture, callbackfunc, 19, "mozfullscreenchange");
      jsevents.registerfullscreenchangeeventcallback(target, userdata, usecapture, callbackfunc, 19, "webkitfullscreenchange");
      jsevents.registerfullscreenchangeeventcallback(target, userdata, usecapture, callbackfunc, 19, "msfullscreenchange");
      return 0;
    }

  function _glpolygonoffset(x0, x1) { glctx['polygonoffset'](x0, x1) }

  function _js_webrequest_setprogresshandler(request, arg, onprogress)
  	{
  		var http = wr.requestinstances[request];
  
  		http.onprogress = function http_onprogress(e) {
  			if (onprogress)
  			{
  				if (e.lengthcomputable)
  					runtime.dyncall('viii', onprogress, [arg, e.loaded, e.total]);
  			}
  		};
  	}

  function _emscripten_glgetshaderprecisionformat(shadertype, precisiontype, range, precision) {
      var result = glctx.getshaderprecisionformat(shadertype, precisiontype);
      heap32[((range)>>2)]=result.rangemin;
      heap32[(((range)+(4))>>2)]=result.rangemax;
      heap32[((precision)>>2)]=result.precision;
    }

  function _emscripten_set_wheel_callback(target, userdata, usecapture, callbackfunc) {
      target = jsevents.findeventtarget(target);
      if (typeof target.onwheel !== 'undefined') {
        jsevents.registerwheeleventcallback(target, userdata, usecapture, callbackfunc, 9, "wheel");
        return 0;
      } else if (typeof target.onmousewheel !== 'undefined') {
        jsevents.registerwheeleventcallback(target, userdata, usecapture, callbackfunc, 9, "mousewheel");
        return 0;
      } else {
        return -1;
      }
    }

  function _gldrawelementsinstanced(mode, count, type, indices, primcount) {
      glctx['drawelementsinstanced'](mode, count, type, indices, primcount);
    }

  function _emscripten_glbindprogramarb() {
  module['printerr']('missing function: emscripten_glbindprogramarb'); abort(-1);
  }

  function _emscripten_glvertexattrib3fv(index, v) {
      var view = gl.minitempbufferviews[2];
      view[0] = heapf32[v >> 2];
      view[1] = heapf32[v + 4 >> 2];
      view[2] = heapf32[v + 8 >> 2];
      glctx.vertexattrib3fv(index, view);
    }

  function _glflush() { glctx['flush']() }

  function _glgetrenderbufferparameteriv(target, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((params)>>2)]=glctx.getrenderbufferparameter(target, pname);
    }

  function _emscripten_glisframebuffer(framebuffer) {
      var fb = gl.framebuffers[framebuffer];
      if (!fb) return 0;
      return glctx.isframebuffer(fb);
    }

  function ___syscall193(which, varargs) {syscalls.varargs = varargs;
  try {
   // truncate64
      var path = syscalls.getstr(), zero = syscalls.getzero(), length = syscalls.get64();
      fs.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall192(which, varargs) {syscalls.varargs = varargs;
  try {
   // mmap2
      var addr = syscalls.get(), len = syscalls.get(), prot = syscalls.get(), flags = syscalls.get(), fd = syscalls.get(), off = syscalls.get()
      off <<= 12; // undo pgoffset
      var ptr;
      var allocated = false;
      if (fd === -1) {
        ptr = _memalign(page_size, len);
        if (!ptr) return -errno_codes.enomem;
        _memset(ptr, 0, len);
        allocated = true;
      } else {
        var info = fs.getstream(fd);
        if (!info) return -errno_codes.ebadf;
        var res = fs.mmap(info, heapu8, addr, len, off, prot, flags);
        ptr = res.ptr;
        allocated = res.allocated;
      }
      syscalls.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, flags: flags };
      return ptr;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall195(which, varargs) {syscalls.varargs = varargs;
  try {
   // sys_stat64
      var path = syscalls.getstr(), buf = syscalls.get();
      return syscalls.dostat(fs.stat, path, buf);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall194(which, varargs) {syscalls.varargs = varargs;
  try {
   // ftruncate64
      var fd = syscalls.get(), zero = syscalls.getzero(), length = syscalls.get64();
      fs.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall197(which, varargs) {syscalls.varargs = varargs;
  try {
   // sys_fstat64
      var stream = syscalls.getstreamfromfd(), buf = syscalls.get();
      return syscalls.dostat(fs.stat, stream.path, buf);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall196(which, varargs) {syscalls.varargs = varargs;
  try {
   // sys_lstat64
      var path = syscalls.getstr(), buf = syscalls.get();
      return syscalls.dostat(fs.lstat, path, buf);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  
  function ___syscall202(which, varargs) {syscalls.varargs = varargs;
  try {
   // getgid32
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }function ___syscall199() {
  return ___syscall202.apply(null, arguments)
  }

  function _emscripten_glrotatef() {
  module['printerr']('missing function: emscripten_glrotatef'); abort(-1);
  }

  function _glfencesync(condition, flags) {
      var sync = glctx.fencesync(condition, flags);
      if (sync) {
        var id = gl.getnewid(gl.syncs);
        sync.name = id;
        gl.syncs[id] = sync;
        return id;
      } else {
        return 0; // failed to create a sync object
      }
    }

  function _glblendequationseparate(x0, x1) { glctx['blendequationseparate'](x0, x1) }

  function _emscripten_glgetactiveuniform(program, index, bufsize, length, size, type, name) {
      program = gl.programs[program];
      var info = glctx.getactiveuniform(program, index);
      if (!info) return; // if an error occurs, nothing will be written to length, size, type and name.
  
      if (bufsize > 0 && name) {
        var numbyteswrittenexclnull = stringtoutf8(info.name, name, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
  
      if (size) heap32[((size)>>2)]=info.size;
      if (type) heap32[((type)>>2)]=info.type;
    }

  function _emscripten_set_focus_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registerfocuseventcallback(target, userdata, usecapture, callbackfunc, 13, "focus");
      return 0;
    }

  function _emscripten_glgetshaderinfolog(shader, maxlength, length, infolog) {
      var log = glctx.getshaderinfolog(gl.shaders[shader]);
      if (log === null) log = '(unknown error)';
      if (maxlength > 0 && infolog) {
        var numbyteswrittenexclnull = stringtoutf8(log, infolog, maxlength);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _emscripten_set_mouseup_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registermouseeventcallback(target, userdata, usecapture, callbackfunc, 6, "mouseup");
      return 0;
    }

  function _emscripten_glstencilopseparate(x0, x1, x2, x3) { glctx['stencilopseparate'](x0, x1, x2, x3) }

  function _emscripten_glcompressedtexsubimage2d(target, level, xoffset, yoffset, width, height, format, imagesize, data) {
      var heapview;
      if (data) {
        heapview = heapu8.subarray((data),(data+imagesize));
      } else {
        heapview = null;
      }
      glctx['compressedtexsubimage2d'](target, level, xoffset, yoffset, width, height, format, heapview);
    }

  function _showbanner(gamekey,userid)
  	{
  	  if (typeof gdsdk !== "undefined")
  	  {	  
  		gdsdk.showbanner(); 
  	  }
  	}

  function _glstencilfuncseparate(x0, x1, x2, x3) { glctx['stencilfuncseparate'](x0, x1, x2, x3) }

  function _glgensamplers(n, samplers) {
      for (var i = 0; i < n; i++) {
        var sampler = glctx['createsampler']();
        if (!sampler) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((samplers)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.samplers);
        sampler.name = id;
        gl.samplers[id] = sampler;
        heap32[(((samplers)+(i*4))>>2)]=id;
      }
    }

  function _pthread_cleanup_push(routine, arg) {
      __atexit__.push(function() { module['dyncall_vi'](routine, arg) })
      _pthread_cleanup_push.level = __atexit__.length;
    }

  function _emscripten_glisenabled(x0) { return glctx['isenabled'](x0) }

  function _gluniform4iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 4;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform4iv(location, value);
    }

  function _glclearstencil(x0) { glctx['clearstencil'](x0) }

  function _js_sound_setposition(channelinstance, x, y, z)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	webaudio.audioinstances[channelinstance].panner.setposition(x, y, z);
  }

  function _emscripten_glcleardepthf(x0) { glctx['cleardepth'](x0) }

  function _emscripten_glvertexattrib4f(x0, x1, x2, x3, x4) { glctx['vertexattrib4f'](x0, x1, x2, x3, x4) }

  function ___cxa_rethrow() {
      var ptr = exceptions.caught.pop();
      if (!exceptions.infos[ptr].rethrown) {
        // only pop if the corresponding push was through rethrow_primary_exception
        exceptions.caught.push(ptr)
        exceptions.infos[ptr].rethrown = true;
      }
      exceptions.last = ptr;
      throw ptr;
    }

  function _emscripten_glclear(x0) { glctx['clear'](x0) }

  
  function _emscripten_get_now() { abort() }
  
  function _emscripten_get_now_is_monotonic() {
      // return whether emscripten_get_now is guaranteed monotonic; the date.now
      // implementation is not :(
      return environment_is_node || (typeof datenow !== 'undefined') ||
          ((environment_is_web || environment_is_worker) && self['performance'] && self['performance']['now']);
    }function _clock_gettime(clk_id, tp) {
      // int clock_gettime(clockid_t clk_id, struct timespec *tp);
      var now;
      if (clk_id === 0) {
        now = date.now();
      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {
        now = _emscripten_get_now();
      } else {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      heap32[((tp)>>2)]=(now/1000)|0; // seconds
      heap32[(((tp)+(4))>>2)]=((now % 1000)*1000*1000)|0; // nanoseconds
      return 0;
    }

  function _gldeleterenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((renderbuffers)+(i*4))>>2)];
        var renderbuffer = gl.renderbuffers[id];
        if (!renderbuffer) continue; // gl spec: "gldeleterenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
        glctx.deleterenderbuffer(renderbuffer);
        renderbuffer.name = 0;
        gl.renderbuffers[id] = null;
      }
    }

  function _glgetprogramiv(program, pname, p) {
      if (!p) {
        // gles2 specification does not specify how to behave if p is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
  
      if (program >= gl.counter) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
  
      var ptable = gl.programinfos[program];
      if (!ptable) {
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        return;
      }
  
      if (pname == 0x8b84) { // gl_info_log_length
        var log = glctx.getprograminfolog(gl.programs[program]);
        if (log === null) log = '(unknown error)';
        heap32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8b87 /* gl_active_uniform_max_length */) {
        heap32[((p)>>2)]=ptable.maxuniformlength;
      } else if (pname == 0x8b8a /* gl_active_attribute_max_length */) {
        if (ptable.maxattributelength == -1) {
          var program = gl.programs[program];
          var numattribs = glctx.getprogramparameter(program, glctx.active_attributes);
          ptable.maxattributelength = 0; // spec says if there are no active attribs, 0 must be returned.
          for (var i = 0; i < numattribs; ++i) {
            var activeattrib = glctx.getactiveattrib(program, i);
            ptable.maxattributelength = math.max(ptable.maxattributelength, activeattrib.name.length+1);
          }
        }
        heap32[((p)>>2)]=ptable.maxattributelength;
      } else if (pname == 0x8a35 /* gl_active_uniform_block_max_name_length */) {
        if (ptable.maxuniformblocknamelength == -1) {
          var program = gl.programs[program];
          var numblocks = glctx.getprogramparameter(program, glctx.active_uniform_blocks);
          ptable.maxuniformblocknamelength = 0;
          for (var i = 0; i < numblocks; ++i) {
            var activeblockname = glctx.getactiveuniformblockname(program, i);
            ptable.maxuniformblocknamelength = math.max(ptable.maxuniformblocknamelength, activeblockname.length+1);
          }
        }
        heap32[((p)>>2)]=ptable.maxuniformblocknamelength;
      } else {
        heap32[((p)>>2)]=glctx.getprogramparameter(gl.programs[program], pname);
      }
    }

  function _glvertexattribpointer(index, size, type, normalized, stride, ptr) {
      glctx.vertexattribpointer(index, size, type, !!normalized, stride, ptr);
    }

  function _pthread_cond_signal() { return 0; }

  function _glframebuffertexturelayer(target, attachment, texture, level, layer) {
      glctx.framebuffertexturelayer(target, attachment, gl.textures[texture], level, layer);
    }

  function _emscripten_glgetattachedshaders(program, maxcount, count, shaders) {
      var result = glctx.getattachedshaders(gl.programs[program]);
      var len = result.length;
      if (len > maxcount) {
        len = maxcount;
      }
      heap32[((count)>>2)]=len;
      for (var i = 0; i < len; ++i) {
        var id = gl.shaders.indexof(result[i]);
        heap32[(((shaders)+(i*4))>>2)]=id;
      }
    }

  function _flock(fd, operation) {
      // int flock(int fd, int operation);
      // pretend to succeed
      return 0;
    }

  function _emscripten_glfrontface(x0) { glctx['frontface'](x0) }

  function _emscripten_glactivetexture(x0) { glctx['activetexture'](x0) }

  function _gltexstorage2d(x0, x1, x2, x3, x4) { glctx['texstorage2d'](x0, x1, x2, x3, x4) }

  function _emscripten_glgetinfologarb() {
  module['printerr']('missing function: emscripten_glgetinfologarb'); abort(-1);
  }

  function _pthread_key_delete(key) {
      if (key in pthread_specific) {
        delete pthread_specific[key];
        return 0;
      }
      return errno_codes.einval;
    }

  function _glgenqueries(n, ids) {
      for (var i = 0; i < n; i++) {
        var query = glctx['createquery']();
        if (!query) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.queries);
        query.name = id;
        gl.queries[id] = query;
        heap32[(((ids)+(i*4))>>2)]=id;
      }
    }

  
  
  var browser={mainloop:{scheduler:null,method:"",currentlyrunningmainloop:0,func:null,arg:0,timingmode:0,timingvalue:0,currentframenumber:0,queue:[],pause:function () {
          browser.mainloop.scheduler = null;
          browser.mainloop.currentlyrunningmainloop++; // incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function () {
          browser.mainloop.currentlyrunningmainloop++;
          var timingmode = browser.mainloop.timingmode;
          var timingvalue = browser.mainloop.timingvalue;
          var func = browser.mainloop.func;
          browser.mainloop.func = null;
          _emscripten_set_main_loop(func, 0, false, browser.mainloop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);
          _emscripten_set_main_loop_timing(timingmode, timingvalue);
          browser.mainloop.scheduler();
        },updatestatus:function () {
          if (module['setstatus']) {
            var message = module['statusmessage'] || 'please wait...';
            var remaining = browser.mainloop.remainingblockers;
            var expected = browser.mainloop.expectedblockers;
            if (remaining) {
              if (remaining < expected) {
                module['setstatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                module['setstatus'](message);
              }
            } else {
              module['setstatus']('');
            }
          }
        },runiter:function (func) {
          if (abort) return;
          if (module['premainloop']) {
            var preret = module['premainloop']();
            if (preret === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof exitstatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) module.printerr('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (module['postmainloop']) module['postmainloop']();
        }},isfullscreen:false,pointerlock:false,modulecontextcreatedcallbacks:[],workers:[],init:function () {
        if (!module["preloadplugins"]) module["preloadplugins"] = []; // needs to exist even in workers
  
        if (browser.initted) return;
        browser.initted = true;
  
        try {
          new blob();
          browser.hasblobconstructor = true;
        } catch(e) {
          browser.hasblobconstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        browser.blobbuilder = typeof mozblobbuilder != "undefined" ? mozblobbuilder : (typeof webkitblobbuilder != "undefined" ? webkitblobbuilder : (!browser.hasblobconstructor ? console.log("warning: no blobbuilder") : null));
        browser.urlobject = typeof window != "undefined" ? (window.url ? window.url : window.webkiturl) : undefined;
        if (!module.noimagedecoding && typeof browser.urlobject === 'undefined') {
          console.log("warning: browser does not support creating object urls. built-in browser image decoding will not be available.");
          module.noimagedecoding = true;
        }
  
        // support for plugins that can process preloaded files. you can add more of these to
        // your app by creating and appending to module.preloadplugins.
        //
        // each plugin is asked if it can handle a file based on the file's name. if it can,
        // it is given the file's raw data. when it is done, it calls a callback with the file's
        // (possibly modified) data. for example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an image element, etc.).
  
        var imageplugin = {};
        imageplugin['canhandle'] = function imageplugin_canhandle(name) {
          return !module.noimagedecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imageplugin['handle'] = function imageplugin_handle(bytearray, name, onload, onerror) {
          var b = null;
          if (browser.hasblobconstructor) {
            try {
              b = new blob([bytearray], { type: browser.getmimetype(name) });
              if (b.size !== bytearray.length) { // safari bug #118630
                // safari's blob can only take an arraybuffer
                b = new blob([(new uint8array(bytearray)).buffer], { type: browser.getmimetype(name) });
              }
            } catch(e) {
              runtime.warnonce('blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new browser.blobbuilder();
            bb.append((new uint8array(bytearray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getblob();
          }
          var url = browser.urlobject.createobjecturl(b);
          var img = new image();
          img.onload = function img_onload() {
            assert(img.complete, 'image ' + name + ' could not be decoded');
            var canvas = document.createelement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getcontext('2d');
            ctx.drawimage(img, 0, 0);
            module["preloadedimages"][name] = canvas;
            browser.urlobject.revokeobjecturl(url);
            if (onload) onload(bytearray);
          };
          img.onerror = function img_onerror(event) {
            console.log('image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        module['preloadplugins'].push(imageplugin);
  
        var audioplugin = {};
        audioplugin['canhandle'] = function audioplugin_canhandle(name) {
          return !module.noaudiodecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioplugin['handle'] = function audioplugin_handle(bytearray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            module["preloadedaudios"][name] = audio;
            if (onload) onload(bytearray);
          }
          function fail() {
            if (done) return;
            done = true;
            module["preloadedaudios"][name] = new audio(); // empty shim
            if (onerror) onerror();
          }
          if (browser.hasblobconstructor) {
            try {
              var b = new blob([bytearray], { type: browser.getmimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = browser.urlobject.createobjecturl(b); // xxx we never revoke this!
            var audio = new audio();
            audio.addeventlistener('canplaythrough', function() { finish(audio) }, false); // use addeventlistener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var base = 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789+/';
                var pad = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += base[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += base[(leftchar&3) << 4];
                  ret += pad + pad;
                } else if (leftbits == 4) {
                  ret += base[(leftchar&0xf) << 2];
                  ret += pad;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(bytearray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            browser.safesettimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        module['preloadplugins'].push(audioplugin);
  
        // canvas event setup
  
        var canvas = module['canvas'];
        function pointerlockchange() {
          browser.pointerlock = document['pointerlockelement'] === canvas ||
                                document['mozpointerlockelement'] === canvas ||
                                document['webkitpointerlockelement'] === canvas ||
                                document['mspointerlockelement'] === canvas;
        }
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedaspectratio' on module
          // module['forcedaspectratio'] = 4 / 3;
          
          canvas.requestpointerlock = canvas['requestpointerlock'] ||
                                      canvas['mozrequestpointerlock'] ||
                                      canvas['webkitrequestpointerlock'] ||
                                      canvas['msrequestpointerlock'] ||
                                      function(){};
          canvas.exitpointerlock = document['exitpointerlock'] ||
                                   document['mozexitpointerlock'] ||
                                   document['webkitexitpointerlock'] ||
                                   document['msexitpointerlock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitpointerlock = canvas.exitpointerlock.bind(document);
  
  
          document.addeventlistener('pointerlockchange', pointerlockchange, false);
          document.addeventlistener('mozpointerlockchange', pointerlockchange, false);
          document.addeventlistener('webkitpointerlockchange', pointerlockchange, false);
          document.addeventlistener('mspointerlockchange', pointerlockchange, false);
  
          if (module['elementpointerlock']) {
            canvas.addeventlistener("click", function(ev) {
              if (!browser.pointerlock && canvas.requestpointerlock) {
                canvas.requestpointerlock();
                ev.preventdefault();
              }
            }, false);
          }
        }
      },createcontext:function (canvas, usewebgl, setinmodule, webglcontextattributes) {
        if (usewebgl && module.ctx && canvas == module.canvas) return module.ctx; // no need to recreate gl context if it's already been created for this canvas.
  
        var ctx;
        var contexthandle;
        if (usewebgl) {
          // for gles2/desktop gl compatibility, adjust a few defaults to be different to webgl defaults, so that they align better with the desktop defaults.
          var contextattributes = {
            antialias: false,
            alpha: false
          };
  
          if (webglcontextattributes) {
            for (var attribute in webglcontextattributes) {
              contextattributes[attribute] = webglcontextattributes[attribute];
            }
          }
  
          contexthandle = gl.createcontext(canvas, contextattributes);
          if (contexthandle) {
            ctx = gl.getcontext(contexthandle).glctx;
          }
        } else {
          ctx = canvas.getcontext('2d');
        }
  
        if (!ctx) return null;
  
        if (setinmodule) {
          if (!usewebgl) assert(typeof glctx === 'undefined', 'cannot set in module if glctx is used, but we are a non-gl context that would replace it');
  
          module.ctx = ctx;
          if (usewebgl) gl.makecontextcurrent(contexthandle);
          module.usewebgl = usewebgl;
          browser.modulecontextcreatedcallbacks.foreach(function(callback) { callback() });
          browser.init();
        }
        return ctx;
      },destroycontext:function (canvas, usewebgl, setinmodule) {},fullscreenhandlersinstalled:false,lockpointer:undefined,resizecanvas:undefined,requestfullscreen:function (lockpointer, resizecanvas, vrdevice) {
        browser.lockpointer = lockpointer;
        browser.resizecanvas = resizecanvas;
        browser.vrdevice = vrdevice;
        if (typeof browser.lockpointer === 'undefined') browser.lockpointer = true;
        if (typeof browser.resizecanvas === 'undefined') browser.resizecanvas = false;
        if (typeof browser.vrdevice === 'undefined') browser.vrdevice = null;
  
        var canvas = module['canvas'];
        function fullscreenchange() {
          browser.isfullscreen = false;
          var canvascontainer = canvas.parentnode;
          if ((document['fullscreenelement'] || document['mozfullscreenelement'] ||
               document['msfullscreenelement'] || document['webkitfullscreenelement'] ||
               document['webkitcurrentfullscreenelement']) === canvascontainer) {
            canvas.exitfullscreen = document['exitfullscreen'] ||
                                    document['cancelfullscreen'] ||
                                    document['mozcancelfullscreen'] ||
                                    document['msexitfullscreen'] ||
                                    document['webkitcancelfullscreen'] ||
                                    function() {};
            canvas.exitfullscreen = canvas.exitfullscreen.bind(document);
            if (browser.lockpointer) canvas.requestpointerlock();
            browser.isfullscreen = true;
            if (browser.resizecanvas) browser.setfullscreencanvassize();
          } else {
            
            // remove the full screen specific parent of the canvas again to restore the html structure from before going full screen
            canvascontainer.parentnode.insertbefore(canvas, canvascontainer);
            canvascontainer.parentnode.removechild(canvascontainer);
            
            if (browser.resizecanvas) browser.setwindowedcanvassize();
          }
          if (module['onfullscreen']) module['onfullscreen'](browser.isfullscreen);
          if (module['onfullscreen']) module['onfullscreen'](browser.isfullscreen);
          browser.updatecanvasdimensions(canvas);
        }
  
        if (!browser.fullscreenhandlersinstalled) {
          browser.fullscreenhandlersinstalled = true;
          document.addeventlistener('fullscreenchange', fullscreenchange, false);
          document.addeventlistener('mozfullscreenchange', fullscreenchange, false);
          document.addeventlistener('webkitfullscreenchange', fullscreenchange, false);
          document.addeventlistener('msfullscreenchange', fullscreenchange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvascontainer = document.createelement("div");
        canvas.parentnode.insertbefore(canvascontainer, canvas);
        canvascontainer.appendchild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (firefox stretches the root to screen size)
        canvascontainer.requestfullscreen = canvascontainer['requestfullscreen'] ||
                                            canvascontainer['mozrequestfullscreen'] ||
                                            canvascontainer['msrequestfullscreen'] ||
                                           (canvascontainer['webkitrequestfullscreen'] ? function() { canvascontainer['webkitrequestfullscreen'](element['allow_keyboard_input']) } : null) ||
                                           (canvascontainer['webkitrequestfullscreen'] ? function() { canvascontainer['webkitrequestfullscreen'](element['allow_keyboard_input']) } : null);
  
        if (vrdevice) {
          canvascontainer.requestfullscreen({ vrdisplay: vrdevice });
        } else {
          canvascontainer.requestfullscreen();
        }
      },requestfullscreen:function (lockpointer, resizecanvas, vrdevice) {
          module.printerr('browser.requestfullscreen() is deprecated. please call browser.requestfullscreen instead.');
          browser.requestfullscreen = function(lockpointer, resizecanvas, vrdevice) {
            return browser.requestfullscreen(lockpointer, resizecanvas, vrdevice);
          }
          return browser.requestfullscreen(lockpointer, resizecanvas, vrdevice);
      },nextraf:0,fakerequestanimationframe:function (func) {
        // try to keep 60fps between calls to here
        var now = date.now();
        if (browser.nextraf === 0) {
          browser.nextraf = now + 1000/60;
        } else {
          while (now + 2 >= browser.nextraf) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            browser.nextraf += 1000/60;
          }
        }
        var delay = math.max(browser.nextraf - now, 0);
        settimeout(func, delay);
      },requestanimationframe:function requestanimationframe(func) {
        if (typeof window === 'undefined') { // provide fallback to settimeout if window is undefined (e.g. in node.js)
          browser.fakerequestanimationframe(func);
        } else {
          if (!window.requestanimationframe) {
            window.requestanimationframe = window['requestanimationframe'] ||
                                           window['mozrequestanimationframe'] ||
                                           window['webkitrequestanimationframe'] ||
                                           window['msrequestanimationframe'] ||
                                           window['orequestanimationframe'] ||
                                           browser.fakerequestanimationframe;
          }
          window.requestanimationframe(func);
        }
      },safecallback:function (func) {
        return function() {
          if (!abort) return func.apply(null, arguments);
        };
      },allowasynccallbacks:true,queuedasynccallbacks:[],pauseasynccallbacks:function () {
        browser.allowasynccallbacks = false;
      },resumeasynccallbacks:function () { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        browser.allowasynccallbacks = true;
        if (browser.queuedasynccallbacks.length > 0) {
          var callbacks = browser.queuedasynccallbacks;
          browser.queuedasynccallbacks = [];
          callbacks.foreach(function(func) {
            func();
          });
        }
      },saferequestanimationframe:function (func) {
        return browser.requestanimationframe(function() {
          if (abort) return;
          if (browser.allowasynccallbacks) {
            func();
          } else {
            browser.queuedasynccallbacks.push(func);
          }
        });
      },safesettimeout:function (func, timeout) {
        module['noexitruntime'] = true;
        return settimeout(function() {
          if (abort) return;
          if (browser.allowasynccallbacks) {
            func();
          } else {
            browser.queuedasynccallbacks.push(func);
          }
        }, timeout);
      },safesetinterval:function (func, timeout) {
        module['noexitruntime'] = true;
        return setinterval(function() {
          if (abort) return;
          if (browser.allowasynccallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getmimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastindexof('.')+1)];
      },getusermedia:function (func) {
        if(!window.getusermedia) {
          window.getusermedia = navigator['getusermedia'] ||
                                navigator['mozgetusermedia'];
        }
        window.getusermedia(func);
      },getmovementx:function (event) {
        return event['movementx'] ||
               event['mozmovementx'] ||
               event['webkitmovementx'] ||
               0;
      },getmovementy:function (event) {
        return event['movementy'] ||
               event['mozmovementy'] ||
               event['webkitmovementy'] ||
               0;
      },getmousewheeldelta:function (event) {
        var delta = 0;
        switch (event.type) {
          case 'dommousescroll': 
            delta = event.detail;
            break;
          case 'mousewheel': 
            delta = event.wheeldelta;
            break;
          case 'wheel': 
            delta = event['deltay'];
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mousex:0,mousey:0,mousemovementx:0,mousemovementy:0,touches:{},lasttouches:{},calculatemouseevent:function (event) { // event should be mousemove, mousedown or mouseup
        if (browser.pointerlock) {
          // when the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // workaround for firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozmovementx' in event)) {
            browser.mousemovementx = browser.mousemovementy = 0;
          } else {
            browser.mousemovementx = browser.getmovementx(event);
            browser.mousemovementy = browser.getmovementy(event);
          }
          
          // check if sdl is available
          if (typeof sdl != "undefined") {
          	browser.mousex = sdl.mousex + browser.mousemovementx;
          	browser.mousey = sdl.mousey + browser.mousemovementy;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// fixme: ideally this should be clamped against the canvas size and zero
          	browser.mousex += browser.mousemovementx;
          	browser.mousey += browser.mousemovementy;
          }        
        } else {
          // otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = module["canvas"].getboundingclientrect();
          var cw = module["canvas"].width;
          var ch = module["canvas"].height;
  
          // neither .scrollx or .pagexoffset are defined in a spec, but
          // we prefer .scrollx because it is currently in a spec draft.
          // (see: http://www.w3.org/tr/2013/wd-cssom-view-20131217/)
          var scrollx = ((typeof window.scrollx !== 'undefined') ? window.scrollx : window.pagexoffset);
          var scrolly = ((typeof window.scrolly !== 'undefined') ? window.scrolly : window.pageyoffset);
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in sdl
  
            }
            var adjustedx = touch.pagex - (scrollx + rect.left);
            var adjustedy = touch.pagey - (scrolly + rect.top);
  
            adjustedx = adjustedx * (cw / rect.width);
            adjustedy = adjustedy * (ch / rect.height);
  
            var coords = { x: adjustedx, y: adjustedy };
            
            if (event.type === 'touchstart') {
              browser.lasttouches[touch.identifier] = coords;
              browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = browser.touches[touch.identifier];
              if (!last) last = coords;
              browser.lasttouches[touch.identifier] = last;
              browser.touches[touch.identifier] = coords;
            } 
            return;
          }
  
          var x = event.pagex - (scrollx + rect.left);
          var y = event.pagey - (scrolly + rect.top);
  
          // the canvas might be css-scaled compared to its backbuffer;
          // sdl-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          browser.mousemovementx = x - browser.mousex;
          browser.mousemovementy = y - browser.mousey;
          browser.mousex = x;
          browser.mousey = y;
        }
      },asyncload:function (url, onload, onerror, norundep) {
        var dep = !norundep ? getuniquerundependency('al ' + url) : '';
        module['readasync'](url, function(arraybuffer) {
          assert(arraybuffer, 'loading data file "' + url + '" failed (no arraybuffer).');
          onload(new uint8array(arraybuffer));
          if (dep) removerundependency(dep);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'loading data file "' + url + '" failed.';
          }
        });
        if (dep) addrundependency(dep);
      },resizelisteners:[],updateresizelisteners:function () {
        var canvas = module['canvas'];
        browser.resizelisteners.foreach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setcanvassize:function (width, height, noupdates) {
        var canvas = module['canvas'];
        browser.updatecanvasdimensions(canvas, width, height);
        if (!noupdates) browser.updateresizelisteners();
      },windowedwidth:0,windowedheight:0,setfullscreencanvassize:function () {
        // check if sdl is available   
        if (typeof sdl != "undefined") {
        	var flags = heapu32[((sdl.screen+runtime.quantum_size*0)>>2)];
        	flags = flags | 0x00800000; // set sdl_fullscreen flag
        	heap32[((sdl.screen+runtime.quantum_size*0)>>2)]=flags
        }
        browser.updateresizelisteners();
      },setwindowedcanvassize:function () {
        // check if sdl is available       
        if (typeof sdl != "undefined") {
        	var flags = heapu32[((sdl.screen+runtime.quantum_size*0)>>2)];
        	flags = flags & ~0x00800000; // clear sdl_fullscreen flag
        	heap32[((sdl.screen+runtime.quantum_size*0)>>2)]=flags
        }
        browser.updateresizelisteners();
      },updatecanvasdimensions:function (canvas, wnative, hnative) {
        if (wnative && hnative) {
          canvas.widthnative = wnative;
          canvas.heightnative = hnative;
        } else {
          wnative = canvas.widthnative;
          hnative = canvas.heightnative;
        }
        var w = wnative;
        var h = hnative;
        if (module['forcedaspectratio'] && module['forcedaspectratio'] > 0) {
          if (w/h < module['forcedaspectratio']) {
            w = math.round(h * module['forcedaspectratio']);
          } else {
            h = math.round(w / module['forcedaspectratio']);
          }
        }
        if (((document['fullscreenelement'] || document['mozfullscreenelement'] ||
             document['msfullscreenelement'] || document['webkitfullscreenelement'] ||
             document['webkitcurrentfullscreenelement']) === canvas.parentnode) && (typeof screen != 'undefined')) {
           var factor = math.min(screen.width / w, screen.height / h);
           w = math.round(w * factor);
           h = math.round(h * factor);
        }
        if (browser.resizecanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeproperty( "width");
            canvas.style.removeproperty("height");
          }
        } else {
          if (canvas.width  != wnative) canvas.width  = wnative;
          if (canvas.height != hnative) canvas.height = hnative;
          if (typeof canvas.style != 'undefined') {
            if (w != wnative || h != hnative) {
              canvas.style.setproperty( "width", w + "px", "important");
              canvas.style.setproperty("height", h + "px", "important");
            } else {
              canvas.style.removeproperty( "width");
              canvas.style.removeproperty("height");
            }
          }
        }
      },wgetrequests:{},nextwgetrequesthandle:0,getnextwgetrequesthandle:function () {
        var handle = browser.nextwgetrequesthandle;
        browser.nextwgetrequesthandle++;
        return handle;
      }};function _emscripten_set_main_loop_timing(mode, value) {
      browser.mainloop.timingmode = mode;
      browser.mainloop.timingvalue = value;
  
      if (!browser.mainloop.func) {
        return 1; // return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*em_timing_settimeout*/) {
        browser.mainloop.scheduler = function browser_mainloop_scheduler_settimeout() {
          var timeuntilnexttick = math.max(0, browser.mainloop.tickstarttime + value - _emscripten_get_now())|0;
          settimeout(browser.mainloop.runner, timeuntilnexttick); // doing this each time means that on exception, we stop
        };
        browser.mainloop.method = 'timeout';
      } else if (mode == 1 /*em_timing_raf*/) {
        browser.mainloop.scheduler = function browser_mainloop_scheduler_raf() {
          browser.requestanimationframe(browser.mainloop.runner);
        };
        browser.mainloop.method = 'raf';
      } else if (mode == 2 /*em_timing_setimmediate*/) {
        if (!window['setimmediate']) {
          // emulate setimmediate. (note: not a complete polyfill, we don't emulate clearimmediate() to keep code size to minimum, since not needed)
          var setimmediates = [];
          var emscriptenmainloopmessageid = 'setimmediate';
          function browser_setimmediate_messagehandler(event) {
            if (event.source === window && event.data === emscriptenmainloopmessageid) {
              event.stoppropagation();
              setimmediates.shift()();
            }
          }
          window.addeventlistener("message", browser_setimmediate_messagehandler, true);
          window['setimmediate'] = function browser_emulated_setimmediate(func) {
            setimmediates.push(func);
            if (environment_is_worker) {
              if (module['setimmediates'] === undefined) module['setimmediates'] = [];
              module['setimmediates'].push(func);
              window.postmessage({target: emscriptenmainloopmessageid}); // in --proxy-to-worker, route the message via proxyclient.js
            } else window.postmessage(emscriptenmainloopmessageid, "*"); // on the main thread, can just send the message to itself.
          }
        }
        browser.mainloop.scheduler = function browser_mainloop_scheduler_setimmediate() {
          window['setimmediate'](browser.mainloop.runner);
        };
        browser.mainloop.method = 'immediate';
      }
      return 0;
    }function _emscripten_set_main_loop(func, fps, simulateinfiniteloop, arg, nosettiming) {
      module['noexitruntime'] = true;
  
      assert(!browser.mainloop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      browser.mainloop.func = func;
      browser.mainloop.arg = arg;
  
      var browseriterationfunc;
      if (typeof arg !== 'undefined') {
        browseriterationfunc = function() {
          module['dyncall_vi'](func, arg);
        };
      } else {
        browseriterationfunc = function() {
          module['dyncall_v'](func);
        };
      }
  
      var thismainloopid = browser.mainloop.currentlyrunningmainloop;
  
      browser.mainloop.runner = function browser_mainloop_runner() {
        if (abort) return;
        if (browser.mainloop.queue.length > 0) {
          var start = date.now();
          var blocker = browser.mainloop.queue.shift();
          blocker.func(blocker.arg);
          if (browser.mainloop.remainingblockers) {
            var remaining = browser.mainloop.remainingblockers;
            var next = remaining%1 == 0 ? remaining-1 : math.floor(remaining);
            if (blocker.counted) {
              browser.mainloop.remainingblockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              browser.mainloop.remainingblockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (date.now() - start) + ' ms'); //, left: ' + browser.mainloop.remainingblockers);
          browser.mainloop.updatestatus();
          
          // catches pause/resume main loop from blocker execution
          if (thismainloopid < browser.mainloop.currentlyrunningmainloop) return;
          
          settimeout(browser.mainloop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thismainloopid < browser.mainloop.currentlyrunningmainloop) return;
  
        // implement very basic swap interval control
        browser.mainloop.currentframenumber = browser.mainloop.currentframenumber + 1 | 0;
        if (browser.mainloop.timingmode == 1/*em_timing_raf*/ && browser.mainloop.timingvalue > 1 && browser.mainloop.currentframenumber % browser.mainloop.timingvalue != 0) {
          // not the scheduled time to render this frame - skip.
          browser.mainloop.scheduler();
          return;
        } else if (browser.mainloop.timingmode == 0/*em_timing_settimeout*/) {
          browser.mainloop.tickstarttime = _emscripten_get_now();
        }
  
        // signal gl rendering layer that processing of a new frame is about to start. this helps it optimize
        // vbo double-buffering and reduce gpu stalls.
  
  
        if (browser.mainloop.method === 'timeout' && module.ctx) {
          module.printerr('looks like you are rendering without using requestanimationframe for the main loop. you should use 0 for the frame rate in emscripten_set_main_loop in order to use requestanimationframe, as that can greatly improve your frame rates!');
          browser.mainloop.method = ''; // just warn once per call to set main loop
        }
  
        browser.mainloop.runiter(browseriterationfunc);
  
  
        // catch pauses from the main loop itself
        if (thismainloopid < browser.mainloop.currentlyrunningmainloop) return;
  
        // queue new audio data. this is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // todo: consider adding pre- and post- raf callbacks so that gl.newrenderingframestarted() and sdl.audio.queuenewaudiodata()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof sdl === 'object' && sdl.audio && sdl.audio.queuenewaudiodata) sdl.audio.queuenewaudiodata();
  
        browser.mainloop.scheduler();
      }
  
      if (!nosettiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*em_timing_settimeout*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*em_timing_raf*/, 1); // do raf by rendering each frame (no decimating)
  
        browser.mainloop.scheduler();
      }
  
      if (simulateinfiniteloop) {
        throw 'simulateinfiniteloop';
      }
    }

  function _emscripten_glrenderbufferstorage(x0, x1, x2, x3) { glctx['renderbufferstorage'](x0, x1, x2, x3) }

  function _gltexsubimage3d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data) {
      glctx['texsubimage3d'](target, level, xoffset, yoffset, zoffset, width, height, depth, format, type,
                          heapu8.subarray(data));
    }

  function ___syscall15(which, varargs) {syscalls.varargs = varargs;
  try {
   // chmod
      var path = syscalls.getstr(), mode = syscalls.get();
      fs.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _gldeletesamplers(n, samplers) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((samplers)+(i*4))>>2)];
        var sampler = gl.samplers[id];
        if (!sampler) continue;
        glctx['deletesampler'](sampler);
        sampler.name = 0;
        gl.samplers[id] = null;
      }
    }

  function ___syscall10(which, varargs) {syscalls.varargs = varargs;
  try {
   // unlink
      var path = syscalls.getstr();
      fs.unlink(path);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _glcopyteximage2d(x0, x1, x2, x3, x4, x5, x6, x7) { glctx['copyteximage2d'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _glblitframebuffer(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) { glctx['blitframebuffer'](x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) }

  function _llvm_trap() {
      abort('trap!');
    }

  function _emscripten_glisprogram(program) {
      var program = gl.programs[program];
      if (!program) return 0;
      return glctx.isprogram(program);
    }

  
  function __zst18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__zst18uncaught_exceptionv.uncaught_exception;
    }function ___cxa_begin_catch(ptr) {
      var info = exceptions.infos[ptr];
      if (info && !info.caught) {
        info.caught = true;
        __zst18uncaught_exceptionv.uncaught_exception--;
      }
      if (info) info.rethrown = false;
      exceptions.caught.push(ptr);
      exceptions.addref(exceptions.deadjust(ptr));
      return ptr;
    }

  function _js_webrequest_create(url, method)
  	{
  		var http = new xmlhttprequest();
  		var _url = pointer_stringify(url);
  		var _method = pointer_stringify(method);
  		http.open(_method, _url, true);
  		http.responsetype = 'arraybuffer';
  		wr.requestinstances[wr.nextrequestid] = http;
  		return wr.nextrequestid++;
  	}

  function _js_sound_setlooppoints(channelinstance, loopstart, loopend)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  	var channel = webaudio.audioinstances[channelinstance];
  	channel.source.loopstart = loopstart;
  	channel.source.loopend = loopend;
  }

  function _emscripten_glgetshaderiv(shader, pname, p) {
      if (!p) {
        // gles2 specification does not specify how to behave if p is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      if (pname == 0x8b84) { // gl_info_log_length
        var log = glctx.getshaderinfolog(gl.shaders[shader]);
        if (log === null) log = '(unknown error)';
        heap32[((p)>>2)]=log.length + 1;
      } else {
        heap32[((p)>>2)]=glctx.getshaderparameter(gl.shaders[shader], pname);
      }
    }

  function _emscripten_gluniformmatrix3fv(location, count, transpose, value) {
      location = gl.uniforms[location];
      var view;
      if (9*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[9*count-1];
        for (var i = 0; i < 9*count; i += 9) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
          view[i+4] = heapf32[(((value)+(4*i+16))>>2)];
          view[i+5] = heapf32[(((value)+(4*i+20))>>2)];
          view[i+6] = heapf32[(((value)+(4*i+24))>>2)];
          view[i+7] = heapf32[(((value)+(4*i+28))>>2)];
          view[i+8] = heapf32[(((value)+(4*i+32))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*36)>>2);
      }
      glctx.uniformmatrix3fv(location, !!transpose, view);
    }

  
  var __currentfullscreenstrategy={};function _emscripten_exit_fullscreen() {
      if (typeof jsevents.fullscreenenabled() === 'undefined') return -1;
      // make sure no queued up calls will fire after this.
      jsevents.removedeferredcalls(jsevents.requestfullscreen);
  
      if (document.exitfullscreen) {
        document.exitfullscreen();
      } else if (document.msexitfullscreen) {
        document.msexitfullscreen();
      } else if (document.mozcancelfullscreen) {
        document.mozcancelfullscreen();
      } else if (document.webkitexitfullscreen) {
        document.webkitexitfullscreen();
      } else {
        return -1;
      }
  
      if (__currentfullscreenstrategy.canvasresizedcallback) {
        module['dyncall_iiii'](__currentfullscreenstrategy.canvasresizedcallback, 37, 0, __currentfullscreenstrategy.canvasresizedcallbackuserdata);
      }
  
      return 0;
    }

  function _gluniform4uiv(location, count, value) {
      location = gl.uniforms[location];
      count *= 4;
      value = heapu32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform4uiv(location, value);
    }

  function _emscripten_glgenframebuffers(n, ids) {
      for (var i = 0; i < n; ++i) {
        var framebuffer = glctx.createframebuffer();
        if (!framebuffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.framebuffers);
        framebuffer.name = id;
        gl.framebuffers[id] = framebuffer;
        heap32[(((ids)+(i*4))>>2)]=id;
      }
    }

  function _js_sound_play(bufferinstance, channelinstance, offset, delay)
  {
  	// stop sound which is playing in the channel currently.
  	_js_sound_stop (channelinstance, 0);
  
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	var sound = webaudio.audioinstances[bufferinstance];
  	var channel = webaudio.audioinstances[channelinstance];
  
  	if (sound.buffer) {
  		try {
  			channel.playbuffer (webaudio.audiocontext.currenttime + delay, sound.buffer, offset);
  		}
  		catch(e) {
  			// need to catch exception, otherwise execution will stop on safari if audio output is missing/broken
  			console.error("playbuffer error. exception: " + e);
  		}
  	}
  	else
  		console.log ("trying to play sound which is not loaded.")
  }

  function _glgetshaderiv(shader, pname, p) {
      if (!p) {
        // gles2 specification does not specify how to behave if p is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      if (pname == 0x8b84) { // gl_info_log_length
        var log = glctx.getshaderinfolog(gl.shaders[shader]);
        if (log === null) log = '(unknown error)';
        heap32[((p)>>2)]=log.length + 1;
      } else {
        heap32[((p)>>2)]=glctx.getshaderparameter(gl.shaders[shader], pname);
      }
    }

  function _emscripten_glblendequationseparate(x0, x1) { glctx['blendequationseparate'](x0, x1) }

  
  function _emscripten_gldrawelements(mode, count, type, indices) {
  
      glctx.drawelements(mode, count, type, indices);
  
    }function _emscripten_gldrawrangeelements(mode, start, end, count, type, indices) {
      // todo: this should be a trivial pass-though function, but due to https://bugzilla.mozilla.org/show_bug.cgi?id=1202427,
      // we work around by ignoring the range.
      _emscripten_gldrawelements(mode, count, type, indices);
      glctx.drawelements(mode, count, type, indices);
    }

  function _glinvalidateframebuffer(target, numattachments, attachments) {
      var list = [];
      for (var i = 0; i < numattachments; i++)
        list.push(heap32[(((attachments)+(i*4))>>2)]);
  
      glctx['invalidateframebuffer'](target, list);
    }

  function _emscripten_glgentextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var texture = glctx.createtexture();
        if (!texture) {
          gl.recorderror(0x0502 /* gl_invalid_operation */); // gles + egl specs don't specify what should happen here, so best to issue an error and create ids with 0.
          while(i < n) heap32[(((textures)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.textures);
        texture.name = id;
        gl.textures[id] = texture;
        heap32[(((textures)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_glreleaseshadercompiler() {
      // nop (as allowed by gles 2.0 spec)
    }

  function _glcopytexsubimage2d(x0, x1, x2, x3, x4, x5, x6, x7) { glctx['copytexsubimage2d'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _js_sound_releaseinstance(instance)
  {
  	webaudio.audioinstances[instance] = null;
  }

  function _openwindow(link)
      {
      	var url = pointer_stringify(link);
          document.onmouseup = function()
          {
          	window.open(url);
          	document.onmouseup = null;
          }
      }

  function _emscripten_gldrawarrays(mode, first, count) {
  
      glctx.drawarrays(mode, first, count);
  
    }

  function _emscripten_glcleardepth(x0) { glctx['cleardepth'](x0) }

  
  var fs={numpendingsync:0,syncintervalid:0,syncinprogress:false,sync:function (onlypendingsync)
  	{
  		if (onlypendingsync) {
  			if (fs.numpendingsync == 0)
  				return;
  		}
  		else if (fs.syncinprogress) {
  			// this is to avoid indexeddb memory leak when fs.syncfs is executed before the previous one completed.
  			fs.numpendingsync++;
  			return;
  		}
  
  		fs.syncinprogress = true;
  		fs.syncfs(false, (function(err) {
  			fs.syncinprogress = false;
  		}));
  		fs.numpendingsync = 0;
  	}};function _js_filesystem_setsyncinterval(ms)
  {
  	if (!module.indexeddb)
  		return;
  
  	fs.syncintervalid = window.setinterval(function(){
  		fs.sync(true);
  	}, ms);
  }

  function _emscripten_glgetuniformlocation(program, name) {
      name = pointer_stringify(name);
  
      var arrayoffset = 0;
      // if user passed an array accessor "[index]", parse the array index off the accessor.
      if (name.indexof(']', name.length-1) !== -1) {
        var ls = name.lastindexof('[');
        var arrayindex = name.slice(ls+1, -1);
        if (arrayindex.length > 0) {
          arrayoffset = parseint(arrayindex);
          if (arrayoffset < 0) {
            return -1;
          }
        }
        name = name.slice(0, ls);
      }
  
      var ptable = gl.programinfos[program];
      if (!ptable) {
        return -1;
      }
      var utable = ptable.uniforms;
      var uniforminfo = utable[name]; // returns pair [ dimension_of_uniform_array, uniform_location ]
      if (uniforminfo && arrayoffset < uniforminfo[0]) { // check if user asked for an out-of-bounds element, i.e. for 'vec4 colors[3];' user could ask for 'colors[10]' which should return -1.
        return uniforminfo[1]+arrayoffset;
      } else {
        return -1;
      }
    }

  function _gluniform3fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (3*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*12)>>2);
      }
      glctx.uniform3fv(location, view);
    }

  function _emscripten_glvertexattrib4fv(index, v) {
      var view = gl.minitempbufferviews[3];
      view[0] = heapf32[v >> 2];
      view[1] = heapf32[v + 4 >> 2];
      view[2] = heapf32[v + 8 >> 2];
      view[3] = heapf32[v + 12 >> 2];
      glctx.vertexattrib4fv(index, view);
    }

  function _emscripten_glscissor(x0, x1, x2, x3) { glctx['scissor'](x0, x1, x2, x3) }

  function _js_sound_set3d(channelinstance, threed)
  {
  	var channel = webaudio.audioinstances[channelinstance];
  	if (channel.threed != threed)
  	{
  		channel.threed = threed;
  		channel.setuppanning();
  	}
  }

  function _js_systeminfo_getdocumenturl(buffer, buffersize) 
  	{
  		if (buffer)
  			stringtoutf8(document.url, buffer, buffersize);
  		return lengthbytesutf8(document.url);
  	}

  function _emscripten_gllinkprogram(program) {
      glctx.linkprogram(gl.programs[program]);
      gl.programinfos[program] = null; // uniforms no longer keep the same names after linking
      gl.populateuniformtable(program);
    }

  function _js_sound_getlength(bufferinstance)
  {
  	if (webaudio.audiowebenabled == 0)
  		return 0;
  
  	var sound = webaudio.audioinstances[bufferinstance];
  
  	// fakemod assumes sample rate is 44100, though that's not necessarily the case,
  	// depending on os, if the audio file was not imported by our pipeline.
  	// therefore we need to recalculate the length based on the actual samplerate.
  	var samplerateratio = 44100 / sound.buffer.samplerate;
  	return sound.buffer.length * samplerateratio;
  }

  function _js_sound_create_channel(callback, userdata)
  {
  	if (webaudio.audiowebenabled == 0)
  		return; 
  
  	var channel = {
  		gain: webaudio.audiocontext.creategain(),
  		panner: webaudio.audiocontext.createpanner(),
  		threed: false,
  		playbuffer: function(delay, buffer, offset)
  		{			
  			this.source.buffer = buffer;
  			var chan = this;
  			this.source.onended = function()
  			{
  				if (callback)
  					runtime.dyncall('vi', callback, [userdata]);
  
  				// recreate channel for future use.
  				chan.setup();
  			};
  			this.source.start(delay, offset);
  		},
  		setup: function()
  		{
  			this.source = webaudio.audiocontext.createbuffersource();
  			this.setuppanning();
  		},
  		setuppanning: function()
  		{
  			if(this.threed)
  			{
  				this.source.disconnect();
  				this.source.connect(this.panner);
  				this.panner.connect(this.gain);		
  			}
  			else
  			{
  				this.panner.disconnect();
  				this.source.connect(this.gain);
  			}
  		}
  	};
  	channel.panner.rollofffactor = 0; // we calculate rolloff ourselves.
  	channel.gain.connect ( webaudio.audiocontext.destination);				
  	channel.setup();
  	return webaudio.audioinstances.push(channel) - 1;
  }

  function _gldeletesync(id) {
      if (!id) return;
      var sync = gl.syncs[id];
      if (!sync) { // gldeletesync signals an error when deleting a nonexisting object, unlike some other gl delete functions.
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      glctx.deletesync(sync);
      sync.name = 0;
      gl.syncs[id] = null;
    }

  function ___cxa_find_matching_catch_4() {
          return ___cxa_find_matching_catch.apply(null, arguments);
        }

  
  function emscriptenwebglgetvertexattrib(index, pname, params, type) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      var data = glctx.getvertexattrib(index, pname);
      if (pname == 0x889f/*vertex_attrib_array_buffer_binding*/) {
        heap32[((params)>>2)]=data["name"];
      } else if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 'integer': heap32[((params)>>2)]=data; break;
          case 'float': heapf32[((params)>>2)]=data; break;
          case 'floattointeger': heap32[((params)>>2)]=math.fround(data); break;
          default: throw 'internal emscriptenwebglgetvertexattrib() error, bad type: ' + type;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 'integer': heap32[(((params)+(i))>>2)]=data[i]; break;
            case 'float': heapf32[(((params)+(i))>>2)]=data[i]; break;
            case 'floattointeger': heap32[(((params)+(i))>>2)]=math.fround(data[i]); break;
            default: throw 'internal emscriptenwebglgetvertexattrib() error, bad type: ' + type;
          }
        }
      }
    }function _glgetvertexattribiv(index, pname, params) {
      // n.b. this function may only be called if the vertex attribute was specified using the function glvertexattrib*f(),
      // otherwise the results are undefined. (gles3 spec 6.1.12)
      emscriptenwebglgetvertexattrib(index, pname, params, 'floattointeger');
    }

  function ___cxa_find_matching_catch_2() {
          return ___cxa_find_matching_catch.apply(null, arguments);
        }

  function ___cxa_find_matching_catch_3() {
          return ___cxa_find_matching_catch.apply(null, arguments);
        }

  function _js_filesystem_sync()
  {
  	if (!module.indexeddb)
  		return;
  
  	fs.sync(false);
  }

  function _emscripten_glenable(x0) { glctx['enable'](x0) }

  var _llvm_pow_f64=math_pow;

  function _glgetactiveuniformblockiv(program, uniformblockindex, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      program = gl.programs[program];
  
      switch(pname) {
        case 0x8a41: /* gl_uniform_block_name_length */
          var name = glctx['getactiveuniformblockname'](program, uniformblockindex);
          heap32[((params)>>2)]=name.length+1;
          return;
        default:
          var result = glctx['getactiveuniformblockparameter'](program, uniformblockindex, pname);
          if (!result) return; // if an error occurs, nothing will be written to params.
          if (typeof result == 'number') {
            heap32[((params)>>2)]=result;
          } else {
            for (var i = 0; i < result.length; i++) {
              heap32[(((params)+(i*4))>>2)]=result[i];
            }
          }
      }
    }

  function _emscripten_glgetshadersource(shader, bufsize, length, source) {
      var result = glctx.getshadersource(gl.shaders[shader]);
      if (!result) return; // if an error occurs, nothing will be written to length or source.
      if (bufsize > 0 && source) {
        var numbyteswrittenexclnull = stringtoutf8(result, source, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

   
  module["_llvm_bswap_i32"] = _llvm_bswap_i32;

  function _js_sound_getloadstate(bufferinstance)
  {
  	if (webaudio.audiowebenabled == 0)
  		return 2;
  
  	var sound = webaudio.audioinstances[bufferinstance];
  	if (sound.error)
  		return 2;
  	if (sound.buffer)
  		return 0;
  	return 1;
  }

  function _js_sound_setpitch(channelinstance, v)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	webaudio.audioinstances[channelinstance].source.playbackrate.value = v;
  }

  
  function emscriptenwebglget(name_, p, type) {
      // guard against user passing a null pointer.
      // note that gles2 spec does not say anything about how passing a null pointer should be treated.
      // testing on desktop core gl 3, the application crashes on glgetintegerv to a null pointer, but
      // better to report an error instead of doing anything random.
      if (!p) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      var ret = undefined;
      switch(name_) { // handle a few trivial gles values
        case 0x8dfa: // gl_shader_compiler
          ret = 1;
          break;
        case 0x8df8: // gl_shader_binary_formats
          if (type !== 'integer' && type !== 'integer64') {
            gl.recorderror(0x0500); // gl_invalid_enum
          }
          return; // do not write anything to the out pointer, since no binary formats are supported.
        case 0x87fe: // gl_num_program_binary_formats
        case 0x8df9: // gl_num_shader_binary_formats
          ret = 0;
          break;
        case 0x86a2: // gl_num_compressed_texture_formats
          // webgl doesn't have gl_num_compressed_texture_formats (it's obsolete since gl_compressed_texture_formats returns a js array that can be queried for length),
          // so implement it ourselves to allow c++ gles2 code get the length.
          var formats = glctx.getparameter(0x86a3 /*gl_compressed_texture_formats*/);
          ret = formats.length;
          break;
        case 0x821d: // gl_num_extensions
          if (glctx.canvas.glctxobject.version < 2) {
            gl.recorderror(0x0502 /* gl_invalid_operation */); // calling gles3/webgl2 function with a gles2/webgl1 context
            return;
          }
          var exts = glctx.getsupportedextensions();
          ret = 2*exts.length; // each extension is duplicated, first in unprefixed webgl form, and then a second time with "gl_" prefix.
          break;
        case 0x821b: // gl_major_version
        case 0x821c: // gl_minor_version
          if (glctx.canvas.glctxobject.version < 2) {
            gl.recorderror(0x0500); // gl_invalid_enum
            return;
          }
          ret = name_ == 0x821b ? 3 : 0; // return version 3.0
          break;
      }
  
      if (ret === undefined) {
        var result = glctx.getparameter(name_);
        switch (typeof(result)) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            gl.recorderror(0x0500); // gl_invalid_enum
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
              // can mean an invalid name_, which we need to report as an error
              switch(name_) {
                case 0x8894: // array_buffer_binding
                case 0x8b8d: // current_program
                case 0x8895: // element_array_buffer_binding
                case 0x8ca6: // framebuffer_binding
                case 0x8ca7: // renderbuffer_binding
                case 0x8069: // texture_binding_2d
                case 0x85b5: // gl_vertex_array_binding
                case 0x8919: // gl_sampler_binding
                case 0x8e25: // gl_transform_feedback_binding
                case 0x8514: { // texture_binding_cube_map
                  ret = 0;
                  break;
                }
                default: {
                  gl.recorderror(0x0500); // gl_invalid_enum
                  return;
                }
              }
            } else if (result instanceof float32array ||
                       result instanceof uint32array ||
                       result instanceof int32array ||
                       result instanceof array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 'integer': heap32[(((p)+(i*4))>>2)]=result[i];   break;
                  case 'float':   heapf32[(((p)+(i*4))>>2)]=result[i]; break;
                  case 'boolean': heap8[(((p)+(i))>>0)]=result[i] ? 1 : 0;    break;
                  default: throw 'internal glget error, bad type: ' + type;
                }
              }
              return;
            } else if (result instanceof webglbuffer ||
                       result instanceof webglprogram ||
                       result instanceof webglframebuffer ||
                       result instanceof webglrenderbuffer ||
                       result instanceof webglquery ||
                       result instanceof webglsampler ||
                       result instanceof webglsync ||
                       result instanceof webgltransformfeedback ||
                       result instanceof webglvertexarrayobject ||
                       result instanceof webgltexture) {
              ret = result.name | 0;
            } else {
              gl.recorderror(0x0500); // gl_invalid_enum
              return;
            }
            break;
          default:
            gl.recorderror(0x0500); // gl_invalid_enum
            return;
        }
      }
  
      switch (type) {
        case 'integer64': (tempi64 = [ret>>>0,(tempdouble=ret,(+(math_abs(tempdouble))) >= 1.0 ? (tempdouble > 0.0 ? ((math_min((+(math_floor((tempdouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(math_ceil((tempdouble - +(((~~(tempdouble)))>>>0))/4294967296.0)))))>>>0) : 0)],heap32[((p)>>2)]=tempi64[0],heap32[(((p)+(4))>>2)]=tempi64[1]);    break;
        case 'integer': heap32[((p)>>2)]=ret;    break;
        case 'float':   heapf32[((p)>>2)]=ret;  break;
        case 'boolean': heap8[((p)>>0)]=ret ? 1 : 0; break;
        default: throw 'internal glget error, bad type: ' + type;
      }
    }function _emscripten_glgetfloatv(name_, p) {
      emscriptenwebglget(name_, p, 'float');
    }

  function _glgetprograminfolog(program, maxlength, length, infolog) {
      var log = glctx.getprograminfolog(gl.programs[program]);
      if (log === null) log = '(unknown error)';
  
      if (maxlength > 0 && infolog) {
        var numbyteswrittenexclnull = stringtoutf8(log, infolog, maxlength);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _emscripten_gluniform3fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (3*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[3*count-1];
        for (var i = 0; i < 3*count; i += 3) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*12)>>2);
      }
      glctx.uniform3fv(location, view);
    }

  function _glbindtransformfeedback(target, id) {
      var transformfeedback = id ? gl.transformfeedbacks[id] : null;
      if (id && !transformfeedback) { // passing an nonexisting or an already deleted id is an error.
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        return;
      }
      glctx['bindtransformfeedback'](target, transformfeedback);
    }


  function _glbindvertexarray(vao) {
      glctx['bindvertexarray'](gl.vaos[vao]);
    }

  function ___resumeexception(ptr) {
      if (!exceptions.last) { exceptions.last = ptr; }
      throw ptr;
    }

  function _emscripten_glcreateprogram() {
      var id = gl.getnewid(gl.programs);
      var program = glctx.createprogram();
      program.name = id;
      gl.programs[id] = program;
      return id;
    }

  function _pthread_once(ptr, func) {
      if (!_pthread_once.seen) _pthread_once.seen = {};
      if (ptr in _pthread_once.seen) return;
      module['dyncall_v'](func);
      _pthread_once.seen[ptr] = 1;
    }

  function _emscripten_glcompressedteximage2d(target, level, internalformat, width, height, border, imagesize, data) {
      var heapview;
      if (data) {
        heapview = heapu8.subarray((data),(data+imagesize));
      } else {
        heapview = null;
      }
      glctx['compressedteximage2d'](target, level, internalformat, width, height, border, heapview);
    }

  function _emscripten_glclearcolor(x0, x1, x2, x3) { glctx['clearcolor'](x0, x1, x2, x3) }

  function _gluniform2uiv(location, count, value) {
      location = gl.uniforms[location];
      count *= 2;
      value = heapu32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform2uiv(location, value);
    }

  function _pthread_attr_destroy(attr) {
      /* int pthread_attr_destroy(pthread_attr_t *attr); */
      //fixme: should destroy the pthread_attr_t struct
      return 0;
    }

  function _js_systeminfo_haswebgl() 
  	{
  		return unityloader.systeminfo.haswebgl;
  	}

  function _glfinish() { glctx['finish']() }

  function _emscripten_glloadmatrixf() {
  module['printerr']('missing function: emscripten_glloadmatrixf'); abort(-1);
  }

  function _gldeleteshader(id) {
      if (!id) return;
      var shader = gl.shaders[id];
      if (!shader) { // gldeleteshader actually signals an error when deleting a nonexisting object, unlike some other gl delete functions.
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      glctx.deleteshader(shader);
      gl.shaders[id] = null;
    }

  function _emscripten_glgetprograminfolog(program, maxlength, length, infolog) {
      var log = glctx.getprograminfolog(gl.programs[program]);
      if (log === null) log = '(unknown error)';
  
      if (maxlength > 0 && infolog) {
        var numbyteswrittenexclnull = stringtoutf8(log, infolog, maxlength);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _glviewport(x0, x1, x2, x3) { glctx['viewport'](x0, x1, x2, x3) }

  function _emscripten_gldepthmask(flag) {
      glctx.depthmask(!!flag);
    }

  function _gluniform1uiv(location, count, value) {
      location = gl.uniforms[location];
      value = heapu32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform1uiv(location, value);
    }

  function _gltransformfeedbackvaryings(program, count, varyings, buffermode) {
      program = gl.programs[program];
      var vars = [];
      for (var i = 0; i < count; i++)
        vars.push(pointer_stringify(heap32[(((varyings)+(i*4))>>2)]));
  
      glctx['transformfeedbackvaryings'](program, vars, buffermode);
    }

  function _js_sound_init()
  {
  	try {
  		window.audiocontext = window.audiocontext||window.webkitaudiocontext;
  		webaudio.audiocontext = new audiocontext();
  		webaudio.audiowebenabled = 1;
  	}
  	catch(e) {
  		alert('web audio api is not supported in this browser');
  	}
  }

  function _emscripten_glflush() { glctx['flush']() }

  function _emscripten_glcreateshader(shadertype) {
      var id = gl.getnewid(gl.shaders);
      gl.shaders[id] = glctx.createshader(shadertype);
      return id;
    }

  function _pthread_cond_init() { return 0; }

  function _emscripten_glisshader(shader) {
      var s = gl.shaders[shader];
      if (!s) return 0;
      return glctx.isshader(s);
    }

  function _js_webrequest_getresponseheaders(request, buffer, buffersize)
  	{
  		var headers = wr.requestinstances[request].getallresponseheaders();
  		if (buffer)
  			stringtoutf8(headers, buffer, buffersize);
  		return lengthbytesutf8(headers);
  	}

  function _gltexparameterf(x0, x1, x2) { glctx['texparameterf'](x0, x1, x2) }

  function _gltexparameteri(x0, x1, x2) { glctx['texparameteri'](x0, x1, x2) }

  function _emscripten_glcolormask(red, green, blue, alpha) {
      glctx.colormask(!!red, !!green, !!blue, !!alpha);
    }

  function _emscripten_set_mousemove_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registermouseeventcallback(target, userdata, usecapture, callbackfunc, 8, "mousemove");
      return 0;
    }

  function _emscripten_set_canvas_size(width, height) {
      browser.setcanvassize(width, height);
    }

  function _glpixelstorei(pname, param) {
      if (pname == 0x0d05 /* gl_pack_alignment */) {
        gl.packalignment = param;
      } else if (pname == 0x0cf5 /* gl_unpack_alignment */) {
        gl.unpackalignment = param;
      }
      glctx.pixelstorei(pname, param);
    }

  function _glvalidateprogram(program) {
      glctx.validateprogram(gl.programs[program]);
    }

  function _js_webrequest_abort(request)
  	{
  		wr.requestinstances[request].abort();
  	}

  function ___syscall221(which, varargs) {syscalls.varargs = varargs;
  try {
   // fcntl64
      var stream = syscalls.getstreamfromfd(), cmd = syscalls.get();
      switch (cmd) {
        case 0: {
          var arg = syscalls.get();
          if (arg < 0) {
            return -errno_codes.einval;
          }
          var newstream;
          newstream = fs.open(stream.path, stream.flags, 0, arg);
          return newstream.fd;
        }
        case 1:
        case 2:
          return 0;  // fd_cloexec makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscalls.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        case 12: {
          var arg = syscalls.get();
          var offset = 0;
          // we're always unlocked.
          heap16[(((arg)+(offset))>>1)]=2;
          return 0;
        }
        case 13:
        case 14:
        case 13:
        case 14:
          return 0; // pretend that the locking is successful.
        case 16:
        case 8:
          return -errno_codes.einval; // these are for sockets. we don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          ___seterrno(errno_codes.einval);
          return -1;
        default: {
          return -errno_codes.einval;
        }
      }
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall220(which, varargs) {syscalls.varargs = varargs;
  try {
   // sys_getdents64
      var stream = syscalls.getstreamfromfd(), dirp = syscalls.get(), count = syscalls.get();
      if (!stream.getdents) {
        stream.getdents = fs.readdir(stream.path);
      }
      var pos = 0;
      while (stream.getdents.length > 0 && pos + 268 <= count) {
        var id;
        var type;
        var name = stream.getdents.pop();
        assert(name.length < 256); // limit of dirent struct
        if (name[0] === '.') {
          id = 1;
          type = 4; // dt_dir
        } else {
          var child = fs.lookupnode(stream.node, name);
          id = child.id;
          type = fs.ischrdev(child.mode) ? 2 :  // dt_chr, character device.
                 fs.isdir(child.mode) ? 4 :     // dt_dir, directory.
                 fs.islink(child.mode) ? 10 :   // dt_lnk, symbolic link.
                 8;                             // dt_reg, regular file.
        }
        heap32[((dirp + pos)>>2)]=id;
        heap32[(((dirp + pos)+(4))>>2)]=stream.position;
        heap16[(((dirp + pos)+(8))>>1)]=268;
        heap8[(((dirp + pos)+(10))>>0)]=type;
        for (var i = 0; i < name.length; i++) {
          heap8[(((dirp + pos)+(11 + i))>>0)]=name.charcodeat(i);
        }
        heap8[(((dirp + pos)+(11 + i))>>0)]=0;
        pos += 268;
      }
      return pos;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _emscripten_glisrenderbuffer(renderbuffer) {
      var rb = gl.renderbuffers[renderbuffer];
      if (!rb) return 0;
      return glctx.isrenderbuffer(rb);
    }

  function _gllinkprogram(program) {
      glctx.linkprogram(gl.programs[program]);
      gl.programinfos[program] = null; // uniforms no longer keep the same names after linking
      gl.populateuniformtable(program);
    }

  function _glbindtexture(target, texture) {
      glctx.bindtexture(target, texture ? gl.textures[texture] : null);
    }

  function _glgetactiveuniformblockname(program, uniformblockindex, bufsize, length, uniformblockname) {
      program = gl.programs[program];
  
      var result = glctx['getactiveuniformblockname'](program, uniformblockindex);
      if (!result) return; // if an error occurs, nothing will be written to uniformblockname or length.
      if (uniformblockname && bufsize > 0) {
        var numbyteswrittenexclnull = stringtoutf8(result, uniformblockname, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _glclearcolor(x0, x1, x2, x3) { glctx['clearcolor'](x0, x1, x2, x3) }

  function _gluniform3iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 3;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform3iv(location, value);
    }

  function _emscripten_glshadersource(shader, count, string, length) {
      var source = gl.getsource(shader, count, string, length);
      glctx.shadersource(gl.shaders[shader], source);
    }

  function _glendquery(x0) { glctx['endquery'](x0) }

  function _pthread_mutex_init() {}

  function _emscripten_glistexture(texture) {
      var texture = gl.textures[texture];
      if (!texture) return 0;
      return glctx.istexture(texture);
    }


  function ___syscall54(which, varargs) {syscalls.varargs = varargs;
  try {
   // ioctl
      var stream = syscalls.getstreamfromfd(), op = syscalls.get();
      switch (op) {
        case 21505: {
          if (!stream.tty) return -errno_codes.enotty;
          return 0;
        }
        case 21506: {
          if (!stream.tty) return -errno_codes.enotty;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -errno_codes.enotty;
          var argp = syscalls.get();
          heap32[((argp)>>2)]=0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -errno_codes.enotty;
          return -errno_codes.einval; // not supported
        }
        case 21531: {
          var argp = syscalls.get();
          return fs.ioctl(stream, op, argp);
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _glcolormask(red, green, blue, alpha) {
      glctx.colormask(!!red, !!green, !!blue, !!alpha);
    }

  function _gldeletetextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((textures)+(i*4))>>2)];
        var texture = gl.textures[id];
        if (!texture) continue; // gl spec: "gldeletetextures silently ignores 0s and names that do not correspond to existing textures".
        glctx.deletetexture(texture);
        texture.name = 0;
        gl.textures[id] = null;
      }
    }

  function _glstencilopseparate(x0, x1, x2, x3) { glctx['stencilopseparate'](x0, x1, x2, x3) }

  function _emscripten_glhint(x0, x1) { glctx['hint'](x0, x1) }

  function _gldeletequeries(n, ids) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((ids)+(i*4))>>2)];
        var query = gl.queries[id];
        if (!query) continue; // gl spec: "unused names in ids are ignored, as is the name zero."
        glctx['deletequery'](query);
        gl.queries[id] = null;
      }
    }

  function _glvertexattrib4f(x0, x1, x2, x3, x4) { glctx['vertexattrib4f'](x0, x1, x2, x3, x4) }

  function _emscripten_gluniform4i(location, v0, v1, v2, v3) {
      location = gl.uniforms[location];
      glctx.uniform4i(location, v0, v1, v2, v3);
    }

  function _glgettexparameteriv(target, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((params)>>2)]=glctx.gettexparameter(target, pname);
    }

  function _emscripten_glviewport(x0, x1, x2, x3) { glctx['viewport'](x0, x1, x2, x3) }

  
  function _emscripten_memcpy_big(dest, src, num) {
      heapu8.set(heapu8.subarray(src, src+num), dest);
      return dest;
    } 
  module["_memcpy"] = _memcpy;

  function _emscripten_glbufferdata(target, size, data, usage) {
      switch (usage) { // fix usages, webgl only has *_draw
        case 0x88e1: // gl_stream_read
        case 0x88e2: // gl_stream_copy
          usage = 0x88e0; // gl_stream_draw
          break;
        case 0x88e5: // gl_static_read
        case 0x88e6: // gl_static_copy
          usage = 0x88e4; // gl_static_draw
          break;
        case 0x88e9: // gl_dynamic_read
        case 0x88ea: // gl_dynamic_copy
          usage = 0x88e8; // gl_dynamic_draw
          break;
      }
      if (!data) {
        glctx.bufferdata(target, size, usage);
      } else {
        glctx.bufferdata(target, heapu8.subarray(data, data+size), usage);
      }
    }

  function _glsamplerparameteri(sampler, pname, param) {
      glctx['samplerparameteri'](sampler ? gl.samplers[sampler] : null, pname, param);
    }

  function _pthread_mutexattr_init() {}

  var _llvm_fabs_f32=math_abs;

  function _emscripten_gluniform3f(location, v0, v1, v2) {
      location = gl.uniforms[location];
      glctx.uniform3f(location, v0, v1, v2);
    }

  function _emscripten_glblendfunc(x0, x1) { glctx['blendfunc'](x0, x1) }

  function _emscripten_gluniform3i(location, v0, v1, v2) {
      location = gl.uniforms[location];
      glctx.uniform3i(location, v0, v1, v2);
    }

  function _emscripten_glstencilop(x0, x1, x2) { glctx['stencilop'](x0, x1, x2) }

  function _gluniform1i(location, v0) {
      location = gl.uniforms[location];
      glctx.uniform1i(location, v0);
    }

  function _glgetactiveattrib(program, index, bufsize, length, size, type, name) {
      program = gl.programs[program];
      var info = glctx.getactiveattrib(program, index);
      if (!info) return; // if an error occurs, nothing will be written to length, size and type and name.
  
      if (bufsize > 0 && name) {
        var numbyteswrittenexclnull = stringtoutf8(info.name, name, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
  
      if (size) heap32[((size)>>2)]=info.size;
      if (type) heap32[((type)>>2)]=info.type;
    }

  function _pthread_detach() {}

  function _gltexsubimage2d(target, level, xoffset, yoffset, width, height, format, type, pixels) {
      var pixeldata = null;
      if (pixels) pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, 0);
      glctx.texsubimage2d(target, level, xoffset, yoffset, width, height, format, type, pixeldata);
    }

  
  function emscriptenwebglgetuniform(program, location, params, type) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      var data = glctx.getuniform(gl.programs[program], gl.uniforms[location]);
      if (typeof data == 'number' || typeof data == 'boolean') {
        switch (type) {
          case 'integer': heap32[((params)>>2)]=data; break;
          case 'float': heapf32[((params)>>2)]=data; break;
          default: throw 'internal emscriptenwebglgetuniform() error, bad type: ' + type;
        }
      } else {
        for (var i = 0; i < data.length; i++) {
          switch (type) {
            case 'integer': heap32[(((params)+(i))>>2)]=data[i]; break;
            case 'float': heapf32[(((params)+(i))>>2)]=data[i]; break;
            default: throw 'internal emscriptenwebglgetuniform() error, bad type: ' + type;
          }
        }
      }
    }function _glgetuniformiv(program, location, params) {
      emscriptenwebglgetuniform(program, location, params, 'integer');
    }

  function _emscripten_glenablevertexattribarray(index) {
      glctx.enablevertexattribarray(index);
    }

  function _js_systeminfo_getmemory() 
  	{
  		return total_memory/(1024*1024);
  	}

  function _atexit(func, arg) {
      __atexit__.unshift({ func: func, arg: arg });
    }

  function _emscripten_glcopytexsubimage2d(x0, x1, x2, x3, x4, x5, x6, x7) { glctx['copytexsubimage2d'](x0, x1, x2, x3, x4, x5, x6, x7) }

  function _emscripten_set_touchcancel_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registertoucheventcallback(target, userdata, usecapture, callbackfunc, 25, "touchcancel");
      return 0;
    }

  function _glbindframebuffer(target, framebuffer) {
      glctx.bindframebuffer(target, framebuffer ? gl.framebuffers[framebuffer] : null);
    }

  function _emscripten_glblendfuncseparate(x0, x1, x2, x3) { glctx['blendfuncseparate'](x0, x1, x2, x3) }

  function _glcullface(x0) { glctx['cullface'](x0) }

  function _emscripten_glcolorpointer() {
  module['printerr']('missing function: emscripten_glcolorpointer'); abort(-1);
  }

  function _emscripten_glnormalpointer() {
  module['printerr']('missing function: emscripten_glnormalpointer'); abort(-1);
  }

  
  function __isleapyear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraysum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]);
      return sum;
    }
  
  
  var __month_days_leap=[31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __month_days_regular=[31,28,31,30,31,30,31,31,30,31,30,31];function __adddays(date, days) {
      var newdate = new date(date.gettime());
      while(days > 0) {
        var leap = __isleapyear(newdate.getfullyear());
        var currentmonth = newdate.getmonth();
        var daysincurrentmonth = (leap ? __month_days_leap : __month_days_regular)[currentmonth];
  
        if (days > daysincurrentmonth-newdate.getdate()) {
          // we spill over to next month
          days -= (daysincurrentmonth-newdate.getdate()+1);
          newdate.setdate(1);
          if (currentmonth < 11) {
            newdate.setmonth(currentmonth+1)
          } else {
            newdate.setmonth(0);
            newdate.setfullyear(newdate.getfullyear()+1);
          }
        } else {
          // we stay in current month 
          newdate.setdate(newdate.getdate()+days);
          return newdate;
        }
      }
  
      return newdate;
    }function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = heap32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: heap32[((tm)>>2)],
        tm_min: heap32[(((tm)+(4))>>2)],
        tm_hour: heap32[(((tm)+(8))>>2)],
        tm_mday: heap32[(((tm)+(12))>>2)],
        tm_mon: heap32[(((tm)+(16))>>2)],
        tm_year: heap32[(((tm)+(20))>>2)],
        tm_wday: heap32[(((tm)+(24))>>2)],
        tm_yday: heap32[(((tm)+(28))>>2)],
        tm_isdst: heap32[(((tm)+(32))>>2)],
        tm_gmtoff: heap32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? pointer_stringify(tm_zone) : ''
      };
  
      var pattern = pointer_stringify(format);
  
      // expand format
      var expansion_rules_1 = {
        '%c': '%a %b %d %h:%m:%s %y',     // replaced by the locale's appropriate date and time representation - e.g., mon aug  3 14:02:01 2013
        '%d': '%m/%d/%y',                 // equivalent to %m / %d / %y
        '%f': '%y-%m-%d',                 // equivalent to %y - %m - %d
        '%h': '%b',                       // equivalent to %b
        '%r': '%i:%m:%s %p',              // replaced by the time in a.m. and p.m. notation
        '%r': '%h:%m',                    // replaced by the time in 24-hour notation
        '%t': '%h:%m:%s',                 // replaced by the time
        '%x': '%m/%d/%y',                 // replaced by the locale's appropriate date representation
        '%x': '%h:%m:%s'                  // replaced by the locale's appropriate date representation
      };
      for (var rule in expansion_rules_1) {
        pattern = pattern.replace(new regexp(rule, 'g'), expansion_rules_1[rule]);
      }
  
      var weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
  
      function leadingsomething(value, digits, character) {
        var str = typeof value === 'number' ? value.tostring() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      };
  
      function leadingnulls(value, digits) {
        return leadingsomething(value, digits, '0');
      };
  
      function comparebyday(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        };
  
        var compare;
        if ((compare = sgn(date1.getfullyear()-date2.getfullyear())) === 0) {
          if ((compare = sgn(date1.getmonth()-date2.getmonth())) === 0) {
            compare = sgn(date1.getdate()-date2.getdate());
          }
        }
        return compare;
      };
  
      function getfirstweekstartdate(janfourth) {
          switch (janfourth.getday()) {
            case 0: // sunday
              return new date(janfourth.getfullyear()-1, 11, 29);
            case 1: // monday
              return janfourth;
            case 2: // tuesday
              return new date(janfourth.getfullyear(), 0, 3);
            case 3: // wednesday
              return new date(janfourth.getfullyear(), 0, 2);
            case 4: // thursday
              return new date(janfourth.getfullyear(), 0, 1);
            case 5: // friday
              return new date(janfourth.getfullyear()-1, 11, 31);
            case 6: // saturday
              return new date(janfourth.getfullyear()-1, 11, 30);
          }
      };
  
      function getweekbasedyear(date) {
          var thisdate = __adddays(new date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janfourththisyear = new date(thisdate.getfullyear(), 0, 4);
          var janfourthnextyear = new date(thisdate.getfullyear()+1, 0, 4);
  
          var firstweekstartthisyear = getfirstweekstartdate(janfourththisyear);
          var firstweekstartnextyear = getfirstweekstartdate(janfourthnextyear);
  
          if (comparebyday(firstweekstartthisyear, thisdate) <= 0) {
            // this date is after the start of the first week of this year
            if (comparebyday(firstweekstartnextyear, thisdate) <= 0) {
              return thisdate.getfullyear()+1;
            } else {
              return thisdate.getfullyear();
            }
          } else { 
            return thisdate.getfullyear()-1;
          }
      };
  
      var expansion_rules_2 = {
        '%a': function(date) {
          return weekdays[date.tm_wday].substring(0,3);
        },
        '%a': function(date) {
          return weekdays[date.tm_wday];
        },
        '%b': function(date) {
          return months[date.tm_mon].substring(0,3);
        },
        '%b': function(date) {
          return months[date.tm_mon];
        },
        '%c': function(date) {
          var year = date.tm_year+1900;
          return leadingnulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingnulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingsomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %g, and %v give values according to the iso 8601:2000 standard week-based year. 
          // in this system, weeks begin on a monday and week 1 of the year is the week that includes 
          // january 4th, which is also the week that includes the first thursday of the year, and 
          // is also the first week that contains at least four days in the year. 
          // if the first monday of january is the 2nd, 3rd, or 4th, the preceding days are part of 
          // the last week of the preceding year; thus, for saturday 2nd january 1999, 
          // %g is replaced by 1998 and %v is replaced by 53. if december 29th, 30th, 
          // or 31st is a monday, it and any following days are part of week 1 of the following year. 
          // thus, for tuesday 30th december 1997, %g is replaced by 1998 and %v is replaced by 01.
          
          return getweekbasedyear(date).tostring().substring(2);
        },
        '%g': function(date) {
          return getweekbasedyear(date);
        },
        '%h': function(date) {
          return leadingnulls(date.tm_hour, 2);
        },
        '%i': function(date) {
          var twelvehour = date.tm_hour;
          if (twelvehour == 0) twelvehour = 12;
          else if (twelvehour > 12) twelvehour -= 12;
          return leadingnulls(twelvehour, 2);
        },
        '%j': function(date) {
          // day of the year (001-366)
          return leadingnulls(date.tm_mday+__arraysum(__isleapyear(date.tm_year+1900) ? __month_days_leap : __month_days_regular, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingnulls(date.tm_mon+1, 2);
        },
        '%m': function(date) {
          return leadingnulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'am';
          } else {
            return 'pm';
          }
        },
        '%s': function(date) {
          return leadingnulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          var day = new date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);
          return day.getday() || 7;
        },
        '%u': function(date) {
          // replaced by the week number of the year as a decimal number [00,53]. 
          // the first sunday of january is the first day of week 1; 
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janfirst = new date(date.tm_year+1900, 0, 1);
          var firstsunday = janfirst.getday() === 0 ? janfirst : __adddays(janfirst, 7-janfirst.getday());
          var enddate = new date(date.tm_year+1900, date.tm_mon, date.tm_mday);
          
          // is target date after the first sunday?
          if (comparebyday(firstsunday, enddate) < 0) {
            // calculate difference in days between first sunday and enddate
            var februaryfirstuntilendmonth = __arraysum(__isleapyear(enddate.getfullyear()) ? __month_days_leap : __month_days_regular, enddate.getmonth()-1)-31;
            var firstsundayuntilendjanuary = 31-firstsunday.getdate();
            var days = firstsundayuntilendjanuary+februaryfirstuntilendmonth+enddate.getdate();
            return leadingnulls(math.ceil(days/7), 2);
          }
  
          return comparebyday(firstsunday, janfirst) === 0 ? '01': '00';
        },
        '%v': function(date) {
          // replaced by the week number of the year (monday as the first day of the week) 
          // as a decimal number [01,53]. if the week containing 1 january has four 
          // or more days in the new year, then it is considered week 1. 
          // otherwise, it is the last week of the previous year, and the next week is week 1. 
          // both january 4th and the first thursday of january are always in week 1. [ tm_year, tm_wday, tm_yday]
          var janfourththisyear = new date(date.tm_year+1900, 0, 4);
          var janfourthnextyear = new date(date.tm_year+1901, 0, 4);
  
          var firstweekstartthisyear = getfirstweekstartdate(janfourththisyear);
          var firstweekstartnextyear = getfirstweekstartdate(janfourthnextyear);
  
          var enddate = __adddays(new date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          if (comparebyday(enddate, firstweekstartthisyear) < 0) {
            // if given date is before this years first week, then it belongs to the 53rd week of last year
            return '53';
          } 
  
          if (comparebyday(firstweekstartnextyear, enddate) <= 0) {
            // if given date is after next years first week, then it belongs to the 01th week of next year
            return '01';
          }
  
          // given date is in between cw 01..53 of this calendar year
          var daysdifference;
          if (firstweekstartthisyear.getfullyear() < date.tm_year+1900) {
            // first cw of this year starts last year
            daysdifference = date.tm_yday+32-firstweekstartthisyear.getdate()
          } else {
            // first cw of this year starts this year
            daysdifference = date.tm_yday+1-firstweekstartthisyear.getdate();
          }
          return leadingnulls(math.ceil(daysdifference/7), 2);
        },
        '%w': function(date) {
          var day = new date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);
          return day.getday();
        },
        '%w': function(date) {
          // replaced by the week number of the year as a decimal number [00,53]. 
          // the first monday of january is the first day of week 1; 
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janfirst = new date(date.tm_year, 0, 1);
          var firstmonday = janfirst.getday() === 1 ? janfirst : __adddays(janfirst, janfirst.getday() === 0 ? 1 : 7-janfirst.getday()+1);
          var enddate = new date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first monday?
          if (comparebyday(firstmonday, enddate) < 0) {
            var februaryfirstuntilendmonth = __arraysum(__isleapyear(enddate.getfullyear()) ? __month_days_leap : __month_days_regular, enddate.getmonth()-1)-31;
            var firstmondayuntilendjanuary = 31-firstmonday.getdate();
            var days = firstmondayuntilendjanuary+februaryfirstuntilendmonth+enddate.getdate();
            return leadingnulls(math.ceil(days/7), 2);
          }
          return comparebyday(firstmonday, janfirst) === 0 ? '01': '00';
        },
        '%y': function(date) {
          // replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).tostring().substring(2);
        },
        '%y': function(date) {
          // replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // replaced by the offset from utc in the iso 8601:2000 standard format ( +hhmm or -hhmm ).
          // for example, "-0430" means 4 hours 30 minutes behind utc (west of greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + string("0000" + off).slice(-4);
        },
        '%z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
      for (var rule in expansion_rules_2) {
        if (pattern.indexof(rule) >= 0) {
          pattern = pattern.replace(new regexp(rule, 'g'), expansion_rules_2[rule](date));
        }
      }
  
      var bytes = intarrayfromstring(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      } 
  
      writearraytomemory(bytes, s);
      return bytes.length-1;
    }

  function _emscripten_glgetframebufferattachmentparameteriv(target, attachment, pname, params) {
      var result = glctx.getframebufferattachmentparameter(target, attachment, pname);
      heap32[((params)>>2)]=result;
    }

  function _emscripten_get_pointerlock_status(pointerlockstatus) {
      if (pointerlockstatus) jsevents.fillpointerlockchangeeventdata(pointerlockstatus);
      if (!document.body.requestpointerlock && !document.body.mozrequestpointerlock && !document.body.webkitrequestpointerlock && !document.body.msrequestpointerlock) {
        return -1;
      }
      return 0;
    }

  function _glattachshader(program, shader) {
      glctx.attachshader(gl.programs[program],
                              gl.shaders[shader]);
    }

  function _emscripten_glgetvertexattribfv(index, pname, params) {
      // n.b. this function may only be called if the vertex attribute was specified using the function glvertexattrib*f(),
      // otherwise the results are undefined. (gles3 spec 6.1.12)
      emscriptenwebglgetvertexattrib(index, pname, params, 'float');
    }

  function _emscripten_set_keyup_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registerkeyeventcallback(target, userdata, usecapture, callbackfunc, 3, "keyup");
      return 0;
    }

  function _gldrawelements(mode, count, type, indices) {
  
      glctx.drawelements(mode, count, type, indices);
  
    }

  function _emscripten_get_fullscreen_status(fullscreenstatus) {
      if (typeof jsevents.fullscreenenabled() === 'undefined') return -1;
      jsevents.fillfullscreenchangeeventdata(fullscreenstatus);
      return 0;
    }

  
  
  
  function _malloc(bytes) {
      /* over-allocate to make sure it is byte-aligned by 8.
       * this will leak memory, but this is only the dummy
       * implementation (replaced by dlmalloc normally) so
       * not an issue.
       */
      var ptr = runtime.dynamicalloc(bytes + 8);
      return (ptr+8) & 0xfffffff8;
    }
  module["_malloc"] = _malloc;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function _getenv(name) {
      // char *getenv(const char *name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html
      if (name === 0) return 0;
      name = pointer_stringify(name);
      if (!env.hasownproperty(name)) return 0;
  
      if (_getenv.ret) _free(_getenv.ret);
      _getenv.ret = allocate(intarrayfromstring(env[name]), 'i8', alloc_normal);
      return _getenv.ret;
    }
  
  function _putenv(string) {
      // int putenv(char *string);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/putenv.html
      // warning: according to the standard (and the glibc implementation), the
      //          string is taken by reference so future changes are reflected.
      //          we copy it instead, possibly breaking some uses.
      if (string === 0) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      string = pointer_stringify(string);
      var splitpoint = string.indexof('=')
      if (string === '' || string.indexof('=') === -1) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      var name = string.slice(0, splitpoint);
      var value = string.slice(splitpoint + 1);
      if (!(name in env) || env[name] !== value) {
        env[name] = value;
        ___buildenvironment(env);
      }
      return 0;
    }
  
  function _sdl_rwfromconstmem(mem, size) {
      var id = sdl.rwops.length; // todo: recycle ids when they are null
      sdl.rwops.push({ bytes: mem, count: size });
      return id;
    }function _ttf_fontheight(font) {
      var fontdata = sdl.fonts[font];
      return fontdata.size;
    }function _ttf_sizetext(font, text, w, h) {
      var fontdata = sdl.fonts[font];
      if (w) {
        heap32[((w)>>2)]=sdl.estimatetextwidth(fontdata, pointer_stringify(text));
      }
      if (h) {
        heap32[((h)>>2)]=fontdata.size;
      }
      return 0;
    }function _ttf_rendertext_solid(font, text, color) {
      // xxx the font and color are ignored
      text = pointer_stringify(text) || ' '; // if given an empty string, still return a valid surface
      var fontdata = sdl.fonts[font];
      var w = sdl.estimatetextwidth(fontdata, text);
      var h = fontdata.size;
      var color = sdl.loadcolortocssrgb(color); // xxx alpha breaks fonts?
      var fontstring = h + 'px ' + fontdata.name;
      var surf = sdl.makesurface(w, h, 0, false, 'text:' + text); // bogus numbers..
      var surfdata = sdl.surfaces[surf];
      surfdata.ctx.save();
      surfdata.ctx.fillstyle = color;
      surfdata.ctx.font = fontstring;
      surfdata.ctx.textbaseline = 'top';
      surfdata.ctx.filltext(text, 0, 0);
      surfdata.ctx.restore();
      return surf;
    }function _mix_haltmusic() {
      var audio = sdl.music.audio;
      if (audio) {
        audio.src = audio.src; // rewind <media> element
        audio.currentposition = 0; // rewind web audio graph playback.
        audio.pause();
      }
      sdl.music.audio = null;
      if (sdl.hookmusicfinished) {
        module['dyncall_v'](sdl.hookmusicfinished);
      }
      return 0;
    }function _mix_playmusic(id, loops) {
      // pause old music if it exists.
      if (sdl.music.audio) {
        if (!sdl.music.audio.paused) module.printerr('music is already playing. ' + sdl.music.source);
        sdl.music.audio.pause();
      }
      var info = sdl.audios[id];
      var audio;
      if (info.webaudio) { // play via web audio api
        // create an instance of the webaudio object.
        audio = {};
        audio.resource = info; // this new webaudio object is an instance that refers to this existing resource.
        audio.paused = false;
        audio.currentposition = 0;
        audio.play = function() { sdl.playwebaudio(this); }
        audio.pause = function() { sdl.pausewebaudio(this); }
      } else if (info.audio) { // play via the <audio> element
        audio = info.audio;
      }
      audio['onended'] = function() { if (sdl.music.audio == this) _mix_haltmusic(); } // will send callback
      audio.loop = loops != 0; // todo: handle n loops for finite n
      audio.volume = sdl.music.volume;
      sdl.music.audio = audio;
      audio.play();
      return 0;
    }function _mix_freechunk(id) {
      sdl.audios[id] = null;
    }function _mix_loadwav_rw(rwopsid, freesrc) {
      var rwops = sdl.rwops[rwopsid];
  
  
      if (rwops === undefined)
        return 0;
  
      var filename = '';
      var audio;
      var webaudio;
      var bytes;
  
      if (rwops.filename !== undefined) {
        filename = path.resolve(rwops.filename);
        var raw = module["preloadedaudios"][filename];
        if (!raw) {
          if (raw === null) module.printerr('trying to reuse preloaded audio, but freepreloadedmediaonuse is set!');
          if (!module.noaudiodecoding) runtime.warnonce('cannot find preloaded audio ' + filename);
  
          // see if we can read the file-contents from the in-memory fs
          try {
            bytes = fs.readfile(filename);
          } catch (e) {
            module.printerr('couldn\'t find file for: ' + filename);
            return 0;
          }
        }
        if (module['freepreloadedmediaonuse']) {
          module["preloadedaudios"][filename] = null;
        }
        audio = raw;
      }
      else if (rwops.bytes !== undefined) {
        // for web audio context buffer decoding, we must make a clone of the audio data, but for <media> element,
        // a view to existing data is sufficient.
        if (sdl.webaudioavailable()) bytes = heapu8.buffer.slice(rwops.bytes, rwops.bytes + rwops.count);
        else bytes = heapu8.subarray(rwops.bytes, rwops.bytes + rwops.count);
      }
      else {
        return 0;
      }
  
      var arraybuffer = bytes ? bytes.buffer || bytes : bytes;
  
      // to allow user code to work around browser bugs with audio playback on <audio> elements an web audio, enable
      // the user code to hook in a callback to decide on a file basis whether each file should use web audio or <audio> for decoding and playback.
      // in particular, see https://bugzilla.mozilla.org/show_bug.cgi?id=654787 and ?id=1012801 for tradeoffs.
      var canplaywithwebaudio = module['sdl_canplaywithwebaudio'] === undefined || module['sdl_canplaywithwebaudio'](filename, arraybuffer);
  
      if (bytes !== undefined && sdl.webaudioavailable() && canplaywithwebaudio) {
        audio = undefined;
        webaudio = {};
        // the audio decoding process is asynchronous, which gives trouble if user code plays the audio data back immediately
        // after loading. therefore prepare an array of callback handlers to run when this audio decoding is complete, which
        // will then start the playback (with some delay).
        webaudio.ondecodecomplete = []; // while this member array exists, decoding hasn't finished yet.
        function ondecodecomplete(data) {
          webaudio.decodedbuffer = data;
          // call all handlers that were waiting for this decode to finish, and clear the handler list.
          webaudio.ondecodecomplete.foreach(function(e) { e(); });
          webaudio.ondecodecomplete = undefined; // don't allow more callback handlers since audio has finished decoding.
        }
  
        sdl.audiocontext['decodeaudiodata'](arraybuffer, ondecodecomplete);
      } else if (audio === undefined && bytes) {
        // here, we didn't find a preloaded audio but we either were passed a filepath for
        // which we loaded bytes, or we were passed some bytes
        var blob = new blob([bytes], {type: rwops.mimetype});
        var url = url.createobjecturl(blob);
        audio = new audio();
        audio.src = url;
        audio.mozaudiochanneltype = 'content'; // bugzilla 910340
      }
  
      var id = sdl.audios.length;
      // keep the loaded audio in the audio arrays, ready for playback
      sdl.audios.push({
        source: filename,
        audio: audio, // points to the <audio> element, if loaded
        webaudio: webaudio // points to a web audio -specific resource object, if loaded
      });
      return id;
    }function _mix_playchannel(channel, id, loops) {
      // todo: handle fixed amount of n loops. currently loops either 0 or infinite times.
  
      // get the audio element associated with the id
      var info = sdl.audios[id];
      if (!info) return -1;
      if (!info.audio && !info.webaudio) return -1;
  
      // if the user asks us to allocate a channel automatically, get the first
      // free one.
      if (channel == -1) {
        for (var i = sdl.channelminimumnumber; i < sdl.numchannels; i++) {
          if (!sdl.channels[i].audio) {
            channel = i;
            break;
          }
        }
        if (channel == -1) {
          module.printerr('all ' + sdl.numchannels + ' channels in use!');
          return -1;
        }
      }
      var channelinfo = sdl.channels[channel];
      var audio;
      if (info.webaudio) {
        // create an instance of the webaudio object.
        audio = {};
        audio.resource = info; // this new object is an instance that refers to this existing resource.
        audio.paused = false;
        audio.currentposition = 0;
        // make our instance look similar to the instance of a <media> to make api simple.
        audio.play = function() { sdl.playwebaudio(this); }
        audio.pause = function() { sdl.pausewebaudio(this); }
      } else {
        // we clone the audio node to utilize the preloaded audio buffer, since
        // the browser has already preloaded the audio file.
        audio = info.audio.clonenode(true);
        audio.numchannels = info.audio.numchannels;
        audio.frequency = info.audio.frequency;
      }
      audio['onended'] = function sdl_audio_onended() { // todo: cache these
        if (channelinfo.audio == this) { channelinfo.audio.paused = true; channelinfo.audio = null; }
        if (sdl.channelfinished) runtime.getfuncwrapper(sdl.channelfinished, 'vi')(channel);
      }
      channelinfo.audio = audio;
      // todo: handle n loops. behavior matches mix_playmusic
      audio.loop = loops != 0;
      audio.volume = channelinfo.volume;
      audio.play();
      return channel;
    }function _sdl_pauseaudio(pauseon) {
      if (!sdl.audio) {
        return;
      }
      if (pauseon) {
        if (sdl.audio.timer !== undefined) {
          cleartimeout(sdl.audio.timer);
          sdl.audio.numaudiotimerspending = 0;
          sdl.audio.timer = undefined;
        }
      } else if (!sdl.audio.timer) {
        // start the audio playback timer callback loop.
        sdl.audio.numaudiotimerspending = 1;
        sdl.audio.timer = browser.safesettimeout(sdl.audio.caller, 1);
      }
      sdl.audio.paused = pauseon;
    }function _sdl_closeaudio() {
      if (sdl.audio) {
        _sdl_pauseaudio(1);
        _free(sdl.audio.buffer);
        sdl.audio = null;
        sdl.allocatechannels(0);
      }
    }function _sdl_locksurface(surf) {
      var surfdata = sdl.surfaces[surf];
  
      surfdata.locked++;
      if (surfdata.locked > 1) return 0;
  
      if (!surfdata.buffer) {
        surfdata.buffer = _malloc(surfdata.width * surfdata.height * 4);
        heap32[(((surf)+(20))>>2)]=surfdata.buffer;
      }
  
      // mark in c/c++-accessible sdl structure
      // sdl_surface has the following fields: uint32 flags, sdl_pixelformat *format; int w, h; uint16 pitch; void *pixels; ...
      // so we have fields all of the same size, and 5 of them before us.
      // todo: use macros like in library.js
      heap32[(((surf)+(20))>>2)]=surfdata.buffer;
  
      if (surf == sdl.screen && module.screenisreadonly && surfdata.image) return 0;
  
      if (sdl.defaults.discardonlock) {
        if (!surfdata.image) {
          surfdata.image = surfdata.ctx.createimagedata(surfdata.width, surfdata.height);
        }
        if (!sdl.defaults.opaquefrontbuffer) return;
      } else {
        surfdata.image = surfdata.ctx.getimagedata(0, 0, surfdata.width, surfdata.height);
      }
  
      // emulate desktop behavior and kill alpha values on the locked surface. (very costly!) set sdl.defaults.opaquefrontbuffer = false
      // if you don't want this.
      if (surf == sdl.screen && sdl.defaults.opaquefrontbuffer) {
        var data = surfdata.image.data;
        var num = data.length;
        for (var i = 0; i < num/4; i++) {
          data[i*4+3] = 255; // opacity, as canvases blend alpha
        }
      }
  
      if (sdl.defaults.copyonlock && !sdl.defaults.discardonlock) {
        // copy pixel data to somewhere accessible to 'c/c++'
        if (surfdata.isflagset(0x00200000 /* sdl_hwpalette */)) {
          // if this is neaded then
          // we should compact the data from 32bpp to 8bpp index.
          // i think best way to implement this is use
          // additional colormap hash (color->index).
          // something like this:
          //
          // var size = surfdata.width * surfdata.height;
          // var data = '';
          // for (var i = 0; i<size; i++) {
          //   var color = sdl.translatergbatocolor(
          //     surfdata.image.data[i*4   ], 
          //     surfdata.image.data[i*4 +1], 
          //     surfdata.image.data[i*4 +2], 
          //     255);
          //   var index = surfdata.colormap[color];
          //   heap8[(((surfdata.buffer)+(i))>>0)]=index;
          // }
          throw 'copyonlock is not supported for sdl_locksurface with sdl_hwpalette flag set' + new error().stack;
        } else {
          heapu8.set(surfdata.image.data, surfdata.buffer);
        }
      }
  
      return 0;
    }
  
  function _sdl_freerw(rwopsid) {
      sdl.rwops[rwopsid] = null;
      while (sdl.rwops.length > 0 && sdl.rwops[sdl.rwops.length-1] === null) {
        sdl.rwops.pop();
      }
    }function _img_load_rw(rwopsid, freesrc) {
      try {
        // stb_image integration support
        function cleanup() {
          if (rwops && freesrc) _sdl_freerw(rwopsid);
        };
        function addcleanup(func) {
          var old = cleanup;
          cleanup = function added_cleanup() {
            old();
            func();
          }
        }
        function callstbimage(func, params) {
          var x = module['_malloc'](4);
          var y = module['_malloc'](4);
          var comp = module['_malloc'](4);
          addcleanup(function() {
            module['_free'](x);
            module['_free'](y);
            module['_free'](comp);
            if (data) module['_stbi_image_free'](data);
          });
          var data = module['_' + func].apply(null, params.concat([x, y, comp, 0]));
          if (!data) return null;
          return {
            rawdata: true,
            data: data,
            width: heap32[((x)>>2)],
            height: heap32[((y)>>2)],
            size: heap32[((x)>>2)] * heap32[((y)>>2)] * heap32[((comp)>>2)],
            bpp: heap32[((comp)>>2)]
          };
        }
  
        var rwops = sdl.rwops[rwopsid];
        if (rwops === undefined) {
          return 0;
        }
  
        var filename = rwops.filename;
        if (filename === undefined) {
          runtime.warnonce('only file names that have been preloaded are supported for img_load_rw. consider using stb_image=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
          return 0;
        }
  
        if (!raw) {
          filename = path.resolve(filename);
          var raw = module["preloadedimages"][filename];
          if (!raw) {
            if (raw === null) module.printerr('trying to reuse preloaded image, but freepreloadedmediaonuse is set!');
            runtime.warnonce('cannot find preloaded image ' + filename);
            runtime.warnonce('cannot find preloaded image ' + filename + '. consider using stb_image=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins');
            return 0;
          } else if (module['freepreloadedmediaonuse']) {
            module["preloadedimages"][filename] = null;
          }
        }
  
        var surf = sdl.makesurface(raw.width, raw.height, 0, false, 'load:' + filename);
        var surfdata = sdl.surfaces[surf];
        surfdata.ctx.globalcompositeoperation = "copy";
        if (!raw.rawdata) {
          surfdata.ctx.drawimage(raw, 0, 0, raw.width, raw.height, 0, 0, raw.width, raw.height);
        } else {
          var imagedata = surfdata.ctx.getimagedata(0, 0, surfdata.width, surfdata.height);
          if (raw.bpp == 4) {
            // rgba
            imagedata.data.set(heapu8.subarray((raw.data),(raw.data+raw.size)));
          } else if (raw.bpp == 3) {
            // rgb
            var pixels = raw.size/3;
            var data = imagedata.data;
            var sourceptr = raw.data;
            var destptr = 0;
            for (var i = 0; i < pixels; i++) {
              data[destptr++] = heapu8[((sourceptr++)>>0)];
              data[destptr++] = heapu8[((sourceptr++)>>0)];
              data[destptr++] = heapu8[((sourceptr++)>>0)];
              data[destptr++] = 255;
            }
          } else if (raw.bpp == 1) {
            // grayscale
            var pixels = raw.size;
            var data = imagedata.data;
            var sourceptr = raw.data;
            var destptr = 0;
            for (var i = 0; i < pixels; i++) {
              var value = heapu8[((sourceptr++)>>0)];
              data[destptr++] = value;
              data[destptr++] = value;
              data[destptr++] = value;
              data[destptr++] = 255;
            }
          } else {
            module.printerr('cannot handle bpp ' + raw.bpp);
            return 0;
          }
          surfdata.ctx.putimagedata(imagedata, 0, 0);
        }
        surfdata.ctx.globalcompositeoperation = "source-over";
        // xxx sdl does not specify that loaded images must have available pixel data, in fact
        //     there are cases where you just want to blit them, so you just need the hardware
        //     accelerated version. however, code everywhere seems to assume that the pixels
        //     are in fact available, so we retrieve it here. this does add overhead though.
        _sdl_locksurface(surf);
        surfdata.locked--; // the surface is not actually locked in this hack
        if (sdl.gl) {
          // after getting the pixel data, we can free the canvas and context if we do not need to do 2d canvas blitting
          surfdata.canvas = surfdata.ctx = null;
        }
        return surf;
      } finally {
        cleanup();
      }
    }
  
  function _sdl_rwfromfile(_name, mode) {
      var id = sdl.rwops.length; // todo: recycle ids when they are null
      var name = pointer_stringify(_name)
      sdl.rwops.push({ filename: name, mimetype: browser.getmimetype(name) });
      return id;
    }function _img_load(filename){
      var rwops = _sdl_rwfromfile(filename);
      var result = _img_load_rw(rwops, 1);
      return result;
    }function _sdl_upperblitscaled(src, srcrect, dst, dstrect) {
      return sdl.blitsurface(src, srcrect, dst, dstrect, true);
    }function _sdl_upperblit(src, srcrect, dst, dstrect) {
      return sdl.blitsurface(src, srcrect, dst, dstrect, false);
    }function _sdl_getticks() {
      return (date.now() - sdl.starttime)|0;
    }var sdl={defaults:{width:320,height:200,copyonlock:true,discardonlock:false,opaquefrontbuffer:true},version:null,surfaces:{},canvaspool:[],events:[],fonts:[null],audios:[null],rwops:[null],music:{audio:null,volume:1},mixerfrequency:22050,mixerformat:32784,mixernumchannels:2,mixerchunksize:1024,channelminimumnumber:0,gl:false,glattributes:{0:3,1:3,2:2,3:0,4:0,5:1,6:16,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0,15:1,16:0,17:0,18:0},keyboardstate:null,keyboardmap:{},canrequestfullscreen:false,isrequestingfullscreen:false,textinput:false,starttime:null,initflags:0,buttonstate:0,modstate:0,dombuttons:[0,0,0],domeventtosdlevent:{},touch_default_id:0,eventhandler:null,eventhandlercontext:null,eventhandlertemp:0,keycodes:{16:1249,17:1248,18:1250,20:1081,33:1099,34:1102,35:1101,36:1098,37:1104,38:1106,39:1103,40:1105,44:316,45:1097,46:127,91:1251,93:1125,96:1122,97:1113,98:1114,99:1115,100:1116,101:1117,102:1118,103:1119,104:1120,105:1121,106:1109,107:1111,109:1110,110:1123,111:1108,112:1082,113:1083,114:1084,115:1085,116:1086,117:1087,118:1088,119:1089,120:1090,121:1091,122:1092,123:1093,124:1128,125:1129,126:1130,127:1131,128:1132,129:1133,130:1134,131:1135,132:1136,133:1137,134:1138,135:1139,144:1107,160:94,161:33,162:34,163:35,164:36,165:37,166:38,167:95,168:40,169:41,170:42,171:43,172:124,173:45,174:123,175:125,176:126,181:127,182:129,183:128,188:44,190:46,191:47,192:96,219:91,220:92,221:93,222:39,224:1251},scancodes:{8:42,9:43,13:40,27:41,32:44,35:204,39:53,44:54,46:55,47:56,48:39,49:30,50:31,51:32,52:33,53:34,54:35,55:36,56:37,57:38,58:203,59:51,61:46,91:47,92:49,93:48,96:52,97:4,98:5,99:6,100:7,101:8,102:9,103:10,104:11,105:12,106:13,107:14,108:15,109:16,110:17,111:18,112:19,113:20,114:21,115:22,116:23,117:24,118:25,119:26,120:27,121:28,122:29,127:76,305:224,308:226,316:70},loadrect:function (rect) {
        return {
          x: heap32[((rect + 0)>>2)],
          y: heap32[((rect + 4)>>2)],
          w: heap32[((rect + 8)>>2)],
          h: heap32[((rect + 12)>>2)]
        };
      },updaterect:function (rect, r) {
        heap32[((rect)>>2)]=r.x;
        heap32[(((rect)+(4))>>2)]=r.y;
        heap32[(((rect)+(8))>>2)]=r.w;
        heap32[(((rect)+(12))>>2)]=r.h;
      },intersectionofrects:function (first, second) {
        var leftx = math.max(first.x, second.x);
        var lefty = math.max(first.y, second.y);
        var rightx = math.min(first.x + first.w, second.x + second.w);
        var righty = math.min(first.y + first.h, second.y + second.h);
  
        return {
          x: leftx,
          y: lefty,
          w: math.max(leftx, rightx) - leftx,
          h: math.max(lefty, righty) - lefty
        }
      },checkpixelformat:function (fmt) {
      },loadcolortocssrgb:function (color) {
        var rgba = heap32[((color)>>2)];
        return 'rgb(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ')';
      },loadcolortocssrgba:function (color) {
        var rgba = heap32[((color)>>2)];
        return 'rgba(' + (rgba&255) + ',' + ((rgba >> 8)&255) + ',' + ((rgba >> 16)&255) + ',' + (((rgba >> 24)&255)/255) + ')';
      },translatecolortocssrgba:function (rgba) {
        return 'rgba(' + (rgba&0xff) + ',' + (rgba>>8 & 0xff) + ',' + (rgba>>16 & 0xff) + ',' + (rgba>>>24)/0xff + ')';
      },translatergbatocssrgba:function (r, g, b, a) {
        return 'rgba(' + (r&0xff) + ',' + (g&0xff) + ',' + (b&0xff) + ',' + (a&0xff)/255 + ')';
      },translatergbatocolor:function (r, g, b, a) {
        return r | g << 8 | b << 16 | a << 24;
      },makesurface:function (width, height, flags, usepagecanvas, source, rmask, gmask, bmask, amask) {
        flags = flags || 0;
        var is_sdl_hwsurface = flags & 0x00000001;
        var is_sdl_hwpalette = flags & 0x00200000;
        var is_sdl_opengl = flags & 0x04000000;
  
        var surf = _malloc(60);
        var pixelformat = _malloc(44);
        //surface with sdl_hwpalette flag is 8bpp surface (1 byte)
        var bpp = is_sdl_hwpalette ? 1 : 4;
        var buffer = 0;
  
        // preemptively initialize this for software surfaces,
        // otherwise it will be lazily initialized inside of sdl_locksurface
        if (!is_sdl_hwsurface && !is_sdl_opengl) {
          buffer = _malloc(width * height * 4);
        }
  
        heap32[((surf)>>2)]=flags;
        heap32[(((surf)+(4))>>2)]=pixelformat;
        heap32[(((surf)+(8))>>2)]=width;
        heap32[(((surf)+(12))>>2)]=height;
        heap32[(((surf)+(16))>>2)]=width * bpp;  // assuming rgba or indexed for now,
                                                                                          // since that is what imagedata gives us in browsers
        heap32[(((surf)+(20))>>2)]=buffer;
  
        heap32[(((surf)+(36))>>2)]=0;
        heap32[(((surf)+(40))>>2)]=0;
        heap32[(((surf)+(44))>>2)]=module["canvas"].width;
        heap32[(((surf)+(48))>>2)]=module["canvas"].height;
  
        heap32[(((surf)+(56))>>2)]=1;
  
        heap32[((pixelformat)>>2)]=-2042224636;
        heap32[(((pixelformat)+(4))>>2)]=0;// todo
        heap8[(((pixelformat)+(8))>>0)]=bpp * 8;
        heap8[(((pixelformat)+(9))>>0)]=bpp;
  
        heap32[(((pixelformat)+(12))>>2)]=rmask || 0x000000ff;
        heap32[(((pixelformat)+(16))>>2)]=gmask || 0x0000ff00;
        heap32[(((pixelformat)+(20))>>2)]=bmask || 0x00ff0000;
        heap32[(((pixelformat)+(24))>>2)]=amask || 0xff000000;
  
        // decide if we want to use webgl or not
        sdl.gl = sdl.gl || is_sdl_opengl;
        var canvas;
        if (!usepagecanvas) {
          if (sdl.canvaspool.length > 0) {
            canvas = sdl.canvaspool.pop();
          } else {
            canvas = document.createelement('canvas');
          }
          canvas.width = width;
          canvas.height = height;
        } else {
          canvas = module['canvas'];
        }
  
        var webglcontextattributes = {
          antialias: ((sdl.glattributes[13 /*sdl_gl_multisamplebuffers*/] != 0) && (sdl.glattributes[14 /*sdl_gl_multisamplesamples*/] > 1)),
          depth: (sdl.glattributes[6 /*sdl_gl_depth_size*/] > 0),
          stencil: (sdl.glattributes[7 /*sdl_gl_stencil_size*/] > 0),
          alpha: (sdl.glattributes[3 /*sdl_gl_alpha_size*/] > 0)
        };
        
        var ctx = browser.createcontext(canvas, is_sdl_opengl, usepagecanvas, webglcontextattributes);
              
        sdl.surfaces[surf] = {
          width: width,
          height: height,
          canvas: canvas,
          ctx: ctx,
          surf: surf,
          buffer: buffer,
          pixelformat: pixelformat,
          alpha: 255,
          flags: flags,
          locked: 0,
          usepagecanvas: usepagecanvas,
          source: source,
  
          isflagset: function(flag) {
            return flags & flag;
          }
        };
  
        return surf;
      },copyindexedcolordata:function (surfdata, rx, ry, rw, rh) {
        // hwpalette works with palette
        // setted by sdl_setcolors
        if (!surfdata.colors) {
          return;
        }
        
        var fullwidth  = module['canvas'].width;
        var fullheight = module['canvas'].height;
  
        var startx  = rx || 0;
        var starty  = ry || 0;
        var endx    = (rw || (fullwidth - startx)) + startx;
        var endy    = (rh || (fullheight - starty)) + starty;
        
        var buffer  = surfdata.buffer;
  
        if (!surfdata.image.data32) {
          surfdata.image.data32 = new uint32array(surfdata.image.data.buffer);
        }
        var data32   = surfdata.image.data32;
  
        var colors32 = surfdata.colors32;
  
        for (var y = starty; y < endy; ++y) {
          var base = y * fullwidth;
          for (var x = startx; x < endx; ++x) {
            data32[base + x] = colors32[heapu8[((buffer + base + x)>>0)]];
          }
        }
      },freesurface:function (surf) {
        var refcountpointer = surf + 56;
        var refcount = heap32[((refcountpointer)>>2)];
        if (refcount > 1) {
          heap32[((refcountpointer)>>2)]=refcount - 1;
          return;
        }
  
        var info = sdl.surfaces[surf];
        if (!info.usepagecanvas && info.canvas) sdl.canvaspool.push(info.canvas);
        if (info.buffer) _free(info.buffer);
        _free(info.pixelformat);
        _free(surf);
        sdl.surfaces[surf] = null;
  
        if (surf === sdl.screen) {
          sdl.screen = null;
        }
      },blitsurface__deps:["sdl_locksurface"],blitsurface:function (src, srcrect, dst, dstrect, scale) {
        var srcdata = sdl.surfaces[src];
        var dstdata = sdl.surfaces[dst];
        var sr, dr;
        if (srcrect) {
          sr = sdl.loadrect(srcrect);
        } else {
          sr = { x: 0, y: 0, w: srcdata.width, h: srcdata.height };
        }
        if (dstrect) {
          dr = sdl.loadrect(dstrect);
        } else {
          dr = { x: 0, y: 0, w: srcdata.width, h: srcdata.height };
        }
        if (dstdata.cliprect) {
          var widthscale = (!scale || sr.w === 0) ? 1 : sr.w / dr.w;
          var heightscale = (!scale || sr.h === 0) ? 1 : sr.h / dr.h;
          
          dr = sdl.intersectionofrects(dstdata.cliprect, dr);
          
          sr.w = dr.w * widthscale;
          sr.h = dr.h * heightscale;
          
          if (dstrect) {
            sdl.updaterect(dstrect, dr);
          }
        }
        var blitw, blith;
        if (scale) {
          blitw = dr.w; blith = dr.h;
        } else {
          blitw = sr.w; blith = sr.h;
        }
        if (sr.w === 0 || sr.h === 0 || blitw === 0 || blith === 0) {
          return 0;
        }
        var oldalpha = dstdata.ctx.globalalpha;
        dstdata.ctx.globalalpha = srcdata.alpha/255;
        dstdata.ctx.drawimage(srcdata.canvas, sr.x, sr.y, sr.w, sr.h, dr.x, dr.y, blitw, blith);
        dstdata.ctx.globalalpha = oldalpha;
        if (dst != sdl.screen) {
          // xxx as in img_load, for compatibility we write out |pixels|
          runtime.warnonce('warning: copying canvas data to memory for compatibility');
          _sdl_locksurface(dst);
          dstdata.locked--; // the surface is not actually locked in this hack
        }
        return 0;
      },downfingers:{},savedkeydown:null,receiveevent:function (event) {
        function unpressallpressedkeys() {
          // un-press all pressed keys: todo
          for (var code in sdl.keyboardmap) {
            sdl.events.push({
              type: 'keyup',
              keycode: sdl.keyboardmap[code]
            });
          }
        };
        switch(event.type) {
          case 'touchstart': case 'touchmove': {
            event.preventdefault();
  
            var touches = [];
            
            // clear out any touchstart events that we've already processed
            if (event.type === 'touchstart') {
              for (var i = 0; i < event.touches.length; i++) {
                var touch = event.touches[i];
                if (sdl.downfingers[touch.identifier] != true) {
                  sdl.downfingers[touch.identifier] = true;
                  touches.push(touch);
                }
              }
            } else {
              touches = event.touches;
            }
            
            var firsttouch = touches[0];
            if (event.type == 'touchstart') {
              sdl.dombuttons[0] = 1;
            }
            var mouseeventtype;
            switch(event.type) {
              case 'touchstart': mouseeventtype = 'mousedown'; break;
              case 'touchmove': mouseeventtype = 'mousemove'; break;
            }
            var mouseevent = {
              type: mouseeventtype,
              button: 0,
              pagex: firsttouch.clientx,
              pagey: firsttouch.clienty
            };
            sdl.events.push(mouseevent);
  
            for (var i = 0; i < touches.length; i++) {
              var touch = touches[i];
              sdl.events.push({
                type: event.type,
                touch: touch
              });
            };
            break;
          }
          case 'touchend': {
            event.preventdefault();
            
            // remove the entry in the sdl.downfingers hash
            // because the finger is no longer down.
            for(var i = 0; i < event.changedtouches.length; i++) {
              var touch = event.changedtouches[i];
              if (sdl.downfingers[touch.identifier] === true) {
                delete sdl.downfingers[touch.identifier];
              }
            }
  
            var mouseevent = {
              type: 'mouseup',
              button: 0,
              pagex: event.changedtouches[0].clientx,
              pagey: event.changedtouches[0].clienty
            };
            sdl.dombuttons[0] = 0;
            sdl.events.push(mouseevent);
            
            for (var i = 0; i < event.changedtouches.length; i++) {
              var touch = event.changedtouches[i];
              sdl.events.push({
                type: 'touchend',
                touch: touch
              });
            };
            break;
          }
          case 'dommousescroll': case 'mousewheel': case 'wheel':
            var delta = -browser.getmousewheeldelta(event); // flip the wheel direction to translate from browser wheel direction (+:down) to sdl direction (+:up)
            delta = (delta == 0) ? 0 : (delta > 0 ? math.max(delta, 1) : math.min(delta, -1)); // quantize to integer so that minimum scroll is at least +/- 1.
  
            // simulate old-style sdl events representing mouse wheel input as buttons
            var button = delta > 0 ? 3 /*sdl_button_wheelup-1*/ : 4 /*sdl_button_wheeldown-1*/; // subtract one since js->c marshalling is defined to add one back.
            sdl.events.push({ type: 'mousedown', button: button, pagex: event.pagex, pagey: event.pagey });
            sdl.events.push({ type: 'mouseup', button: button, pagex: event.pagex, pagey: event.pagey });
  
            // pass a delta motion event.
            sdl.events.push({ type: 'wheel', deltax: 0, deltay: delta });
            event.preventdefault(); // if we don't prevent this, then 'wheel' event will be sent again by the browser as 'dommousescroll' and we will receive this same event the second time.
            break;
          case 'mousemove':
            if (sdl.dombuttons[0] === 1) {
              sdl.events.push({
                type: 'touchmove',
                touch: {
                  identifier: 0,
                  deviceid: -1,
                  pagex: event.pagex,
                  pagey: event.pagey
                }
              });
            }
            if (browser.pointerlock) {
              // workaround for firefox bug 750111
              if ('mozmovementx' in event) {
                event['movementx'] = event['mozmovementx'];
                event['movementy'] = event['mozmovementy'];
              }
              // workaround for firefox bug 782777
              if (event['movementx'] == 0 && event['movementy'] == 0) {
                // ignore a mousemove event if it doesn't contain any movement info
                // (without pointer lock, we infer movement from pagex/pagey, so this check is unnecessary)
                event.preventdefault();
                return;
              }
            }
            // fall through
          case 'keydown': case 'keyup': case 'keypress': case 'mousedown': case 'mouseup':
            // if we preventdefault on keydown events, the subsequent keypress events
            // won't fire. however, it's fine (and in some cases necessary) to
            // preventdefault for keys that don't generate a character. otherwise,
            // preventdefault is the right thing to do in general.
            if (event.type !== 'keydown' || (!sdl.unicode && !sdl.textinput) || (event.keycode === 8 /* backspace */ || event.keycode === 9 /* tab */)) {
              event.preventdefault();
            }
  
            if (event.type == 'mousedown') {
              sdl.dombuttons[event.button] = 1;
              sdl.events.push({
                type: 'touchstart',
                touch: {
                  identifier: 0,
                  deviceid: -1,
                  pagex: event.pagex,
                  pagey: event.pagey
                }
              });
            } else if (event.type == 'mouseup') {
              // ignore extra ups, can happen if we leave the canvas while pressing down, then return,
              // since we add a mouseup in that case
              if (!sdl.dombuttons[event.button]) {
                return;
              }
  
              sdl.events.push({
                type: 'touchend',
                touch: {
                  identifier: 0,
                  deviceid: -1,
                  pagex: event.pagex,
                  pagey: event.pagey
                }
              });
              sdl.dombuttons[event.button] = 0;
            }
  
            // we can only request fullscreen as the result of user input.
            // due to this limitation, we toggle a boolean on keydown which
            // sdl_wm_togglefullscreen will check and subsequently set another
            // flag indicating for us to request fullscreen on the following
            // keyup. this isn't perfect, but it enables sdl_wm_togglefullscreen
            // to work as the result of a keypress (which is an extremely
            // common use case).
            if (event.type === 'keydown' || event.type === 'mousedown') {
              sdl.canrequestfullscreen = true;
            } else if (event.type === 'keyup' || event.type === 'mouseup') {
              if (sdl.isrequestingfullscreen) {
                module['requestfullscreen'](/*lockpointer=*/true, /*resizecanvas=*/true);
                sdl.isrequestingfullscreen = false;
              }
              sdl.canrequestfullscreen = false;
            }
  
            // sdl expects a unicode character to be passed to its keydown events.
            // unfortunately, the browser apis only provide a charcode property on
            // keypress events, so we must backfill in keydown events with their
            // subsequent keypress event's charcode.
            if (event.type === 'keypress' && sdl.savedkeydown) {
              // charcode is read-only
              sdl.savedkeydown.keypresscharcode = event.charcode;
              sdl.savedkeydown = null;
            } else if (event.type === 'keydown') {
              sdl.savedkeydown = event;
            }
  
            // don't push keypress events unless sdl_starttextinput has been called.
            if (event.type !== 'keypress' || sdl.textinput) {
              sdl.events.push(event);
            }
            break;
          case 'mouseout':
            // un-press all pressed mouse buttons, because we might miss the release outside of the canvas
            for (var i = 0; i < 3; i++) {
              if (sdl.dombuttons[i]) {
                sdl.events.push({
                  type: 'mouseup',
                  button: i,
                  pagex: event.pagex,
                  pagey: event.pagey
                });
                sdl.dombuttons[i] = 0;
              }
            }
            event.preventdefault();
            break;
          case 'focus':
            sdl.events.push(event);
            event.preventdefault();
            break;
          case 'blur':
            sdl.events.push(event);
            unpressallpressedkeys();
            event.preventdefault();
            break;
          case 'visibilitychange':
            sdl.events.push({
              type: 'visibilitychange',
              visible: !document.hidden
            });
            unpressallpressedkeys();
            event.preventdefault();
            break;
          case 'unload':
            if (browser.mainloop.runner) {
              sdl.events.push(event);
              // force-run a main event loop, since otherwise this event will never be caught!
              browser.mainloop.runner();
            }
            return;
          case 'resize':
            sdl.events.push(event);
            // manually triggered resize event doesn't have a preventdefault member
            if (event.preventdefault) {
              event.preventdefault();
            }
            break;
        }
        if (sdl.events.length >= 10000) {
          module.printerr('sdl event queue full, dropping events');
          sdl.events = sdl.events.slice(0, 10000);
        }
        // if we have a handler installed, this will push the events to the app
        // instead of the app polling for them.
        sdl.flusheventstohandler();
        return;
      },lookupkeycodeforevent:function (event) {
          var code = event.keycode;
          if (code >= 65 && code <= 90) {
            code += 32; // make lowercase for sdl
          } else {
            code = sdl.keycodes[event.keycode] || event.keycode;
            // if this is one of the modifier keys (224 | 1<<10 - 227 | 1<<10), and the event specifies that it is
            // a right key, add 4 to get the right key sdl key code.
            if (event.location === keyboardevent.dom_key_location_right && code >= (224 | 1<<10) && code <= (227 | 1<<10)) {
              code += 4;
            }
          }
          return code;
      },handleevent:function (event) {
        if (event.handled) return;
        event.handled = true;
  
        switch (event.type) {
          case 'touchstart': case 'touchend': case 'touchmove': {
            browser.calculatemouseevent(event);
            break;
          }
          case 'keydown': case 'keyup': {
            var down = event.type === 'keydown';
            var code = sdl.lookupkeycodeforevent(event);
            heap8[(((sdl.keyboardstate)+(code))>>0)]=down;
            // todo: lmeta, rmeta, numlock, capslock, kmod_mode, kmod_reserved
            sdl.modstate = (heap8[(((sdl.keyboardstate)+(1248))>>0)] ? 0x0040 : 0) | // kmod_lctrl
              (heap8[(((sdl.keyboardstate)+(1249))>>0)] ? 0x0001 : 0) | // kmod_lshift
              (heap8[(((sdl.keyboardstate)+(1250))>>0)] ? 0x0100 : 0) | // kmod_lalt
              (heap8[(((sdl.keyboardstate)+(1252))>>0)] ? 0x0080 : 0) | // kmod_rctrl
              (heap8[(((sdl.keyboardstate)+(1253))>>0)] ? 0x0002 : 0) | // kmod_rshift
              (heap8[(((sdl.keyboardstate)+(1254))>>0)] ? 0x0200 : 0); //  kmod_ralt
            if (down) {
              sdl.keyboardmap[code] = event.keycode; // save the dom input, which we can use to unpress it during blur
            } else {
              delete sdl.keyboardmap[code];
            }
  
            break;
          }
          case 'mousedown': case 'mouseup':
            if (event.type == 'mousedown') {
              // sdl_button(x) is defined as (1 << ((x)-1)).  sdl buttons are 1-3,
              // and dom buttons are 0-2, so this means that the below formula is
              // correct.
              sdl.buttonstate |= 1 << event.button;
            } else if (event.type == 'mouseup') {
              sdl.buttonstate &= ~(1 << event.button);
            }
            // fall through
          case 'mousemove': {
            browser.calculatemouseevent(event);
            break;
          }
        }
      },flusheventstohandler:function () {
        if (!sdl.eventhandler) return;
  
        while (sdl.pollevent(sdl.eventhandlertemp)) {
          module['dyncall_iii'](sdl.eventhandler, sdl.eventhandlercontext, sdl.eventhandlertemp);
        }
      },pollevent:function (ptr) {
        if (sdl.initflags & 0x200 && sdl.joystickeventstate) {
          // if sdl_init_joystick was supplied and the joystick system is configured
          // to automatically query for events, query for joystick events.
          sdl.queryjoysticks();
        }
        if (ptr) {
          while (sdl.events.length > 0) {
            if (sdl.makecevent(sdl.events.shift(), ptr) !== false) return 1;
          }
          return 0;
        } else {
          // xxx: somewhat risky in that we do not check if the event is real or not (makecevent returns false) if no pointer supplied
          return sdl.events.length > 0;
        }
      },makecevent:function (event, ptr) {
        if (typeof event === 'number') {
          // this is a pointer to a copy of a native c event that was sdl_pushevent'ed
          _memcpy(ptr, event, 28);
          _free(event); // the copy is no longer needed
          return;
        }
  
        sdl.handleevent(event);
  
        switch (event.type) {
          case 'keydown': case 'keyup': {
            var down = event.type === 'keydown';
            //module.print('received key event: ' + event.keycode);
            var key = sdl.lookupkeycodeforevent(event);
            var scan;
            if (key >= 1024) {
              scan = key - 1024;
            } else {
              scan = sdl.scancodes[key] || key;
            }
  
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap8[(((ptr)+(8))>>0)]=down ? 1 : 0;
            heap8[(((ptr)+(9))>>0)]=0; // todo
            heap32[(((ptr)+(12))>>2)]=scan;
            heap32[(((ptr)+(16))>>2)]=key;
            heap16[(((ptr)+(20))>>1)]=sdl.modstate;
            // some non-character keys (e.g. backspace and tab) won't have keypresscharcode set, fill in with the keycode.
            heap32[(((ptr)+(24))>>2)]=event.keypresscharcode || key;
  
            break;
          }
          case 'keypress': {
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            // not filling in windowid for now
            var cstr = intarrayfromstring(string.fromcharcode(event.charcode));
            for (var i = 0; i < cstr.length; ++i) {
              heap8[(((ptr)+(8 + i))>>0)]=cstr[i];
            }
            break;
          }
          case 'mousedown': case 'mouseup': case 'mousemove': {
            if (event.type != 'mousemove') {
              var down = event.type === 'mousedown';
              heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
              heap32[(((ptr)+(4))>>2)]=0;
              heap32[(((ptr)+(8))>>2)]=0;
              heap32[(((ptr)+(12))>>2)]=0;
              heap8[(((ptr)+(16))>>0)]=event.button+1; // dom buttons are 0-2, sdl 1-3
              heap8[(((ptr)+(17))>>0)]=down ? 1 : 0;
              heap32[(((ptr)+(20))>>2)]=browser.mousex;
              heap32[(((ptr)+(24))>>2)]=browser.mousey;
            } else {
              heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
              heap32[(((ptr)+(4))>>2)]=0;
              heap32[(((ptr)+(8))>>2)]=0;
              heap32[(((ptr)+(12))>>2)]=0;
              heap32[(((ptr)+(16))>>2)]=sdl.buttonstate;
              heap32[(((ptr)+(20))>>2)]=browser.mousex;
              heap32[(((ptr)+(24))>>2)]=browser.mousey;
              heap32[(((ptr)+(28))>>2)]=browser.mousemovementx;
              heap32[(((ptr)+(32))>>2)]=browser.mousemovementy;
            }
            break;
          }
          case 'wheel': {
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(16))>>2)]=event.deltax;
            heap32[(((ptr)+(20))>>2)]=event.deltay; 
            break;       
          }
          case 'touchstart': case 'touchend': case 'touchmove': {
            var touch = event.touch;
            if (!browser.touches[touch.identifier]) break;
            var w = module['canvas'].width;
            var h = module['canvas'].height;
            var x = browser.touches[touch.identifier].x / w;
            var y = browser.touches[touch.identifier].y / h;
            var lx = browser.lasttouches[touch.identifier].x / w;
            var ly = browser.lasttouches[touch.identifier].y / h;
            var dx = x - lx;
            var dy = y - ly;
            if (touch['deviceid'] === undefined) touch.deviceid = sdl.touch_default_id;
            if (dx === 0 && dy === 0 && event.type === 'touchmove') return false; // don't send these if nothing happened
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(4))>>2)]=_sdl_getticks();
            (tempi64 = [touch.deviceid>>>0,(tempdouble=touch.deviceid,(+(math_abs(tempdouble))) >= 1.0 ? (tempdouble > 0.0 ? ((math_min((+(math_floor((tempdouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(math_ceil((tempdouble - +(((~~(tempdouble)))>>>0))/4294967296.0)))))>>>0) : 0)],heap32[(((ptr)+(8))>>2)]=tempi64[0],heap32[(((ptr)+(12))>>2)]=tempi64[1]);
            (tempi64 = [touch.identifier>>>0,(tempdouble=touch.identifier,(+(math_abs(tempdouble))) >= 1.0 ? (tempdouble > 0.0 ? ((math_min((+(math_floor((tempdouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(math_ceil((tempdouble - +(((~~(tempdouble)))>>>0))/4294967296.0)))))>>>0) : 0)],heap32[(((ptr)+(16))>>2)]=tempi64[0],heap32[(((ptr)+(20))>>2)]=tempi64[1]);
            heapf32[(((ptr)+(24))>>2)]=x;
            heapf32[(((ptr)+(28))>>2)]=y;
            heapf32[(((ptr)+(32))>>2)]=dx;
            heapf32[(((ptr)+(36))>>2)]=dy;
            if (touch.force !== undefined) {
              heapf32[(((ptr)+(40))>>2)]=touch.force;
            } else { // no pressure data, send a digital 0/1 pressure.
              heapf32[(((ptr)+(40))>>2)]=event.type == "touchend" ? 0 : 1;
            }
            break;
          }
          case 'unload': {
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            break;
          }
          case 'resize': {
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(4))>>2)]=event.w;
            heap32[(((ptr)+(8))>>2)]=event.h;
            break;
          }
          case 'joystick_button_up': case 'joystick_button_down': {
            var state = event.type === 'joystick_button_up' ? 0 : 1;
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap8[(((ptr)+(4))>>0)]=event.index;
            heap8[(((ptr)+(5))>>0)]=event.button;
            heap8[(((ptr)+(6))>>0)]=state;
            break;
          }
          case 'joystick_axis_motion': {
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap8[(((ptr)+(4))>>0)]=event.index;
            heap8[(((ptr)+(5))>>0)]=event.axis;
            heap32[(((ptr)+(8))>>2)]=sdl.joystickaxisvalueconversion(event.value);
            break;
          }
          case 'focus': {
            var sdl_windowevent_focus_gained = 12 /* sdl_windowevent_focus_gained */;
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(4))>>2)]=0;
            heap8[(((ptr)+(8))>>0)]=sdl_windowevent_focus_gained;
            break;
          }
          case 'blur': {
            var sdl_windowevent_focus_lost = 13 /* sdl_windowevent_focus_lost */;
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(4))>>2)]=0;
            heap8[(((ptr)+(8))>>0)]=sdl_windowevent_focus_lost;
            break;
          }
          case 'visibilitychange': {
            var sdl_windowevent_shown  = 1 /* sdl_windowevent_shown */;
            var sdl_windowevent_hidden = 2 /* sdl_windowevent_hidden */;
            var visibilityeventid = event.visible ? sdl_windowevent_shown : sdl_windowevent_hidden;
            heap32[((ptr)>>2)]=sdl.domeventtosdlevent[event.type];
            heap32[(((ptr)+(4))>>2)]=0;
            heap8[(((ptr)+(8))>>0)]=visibilityeventid;
            break;
          }
          default: throw 'unhandled sdl event: ' + event.type;
        }
      },estimatetextwidth:function (fontdata, text) {
        var h = fontdata.size;
        var fontstring = h + 'px ' + fontdata.name;
        var tempctx = sdl.ttfcontext;
        tempctx.save();
        tempctx.font = fontstring;
        var ret = tempctx.measuretext(text).width | 0;
        tempctx.restore();
        return ret;
      },allocatechannels:function (num) { // called from mix_allocatechannels and init
        if (sdl.numchannels && sdl.numchannels >= num && num != 0) return;
        sdl.numchannels = num;
        sdl.channels = [];
        for (var i = 0; i < num; i++) {
          sdl.channels[i] = {
            audio: null,
            volume: 1.0
          };
        }
      },setgetvolume:function (info, volume) {
        if (!info) return 0;
        var ret = info.volume * 128; // mix_max_volume
        if (volume != -1) {
          info.volume = math.min(math.max(volume, 0), 128) / 128;
          if (info.audio) {
            try {
              info.audio.volume = info.volume; // for <audio> element
              if (info.audio.webaudiogainnode) info.audio.webaudiogainnode['gain']['value'] = info.volume; // for webaudio playback
            } catch(e) {
              module.printerr('setgetvolume failed to set audio volume: ' + e);
            }
          }
        }
        return ret;
      },setpannerposition:function (info, x, y, z) {
        if (!info) return;
        if (info.audio) {
          if (info.audio.webaudiopannernode) {
            info.audio.webaudiopannernode['setposition'](x, y, z);
          }
        }
      },playwebaudio:function (audio) {
        if (!audio) return;
        if (audio.webaudionode) return; // this instance is already playing, don't start again.
        if (!sdl.webaudioavailable()) return;
        try {
          var webaudio = audio.resource.webaudio;
          audio.paused = false;
          if (!webaudio.decodedbuffer) {
            if (webaudio.ondecodecomplete === undefined) abort("cannot play back audio object that was not loaded");
            webaudio.ondecodecomplete.push(function() { if (!audio.paused) sdl.playwebaudio(audio); });
            return;
          }
          audio.webaudionode = sdl.audiocontext['createbuffersource']();
          audio.webaudionode['buffer'] = webaudio.decodedbuffer;
          audio.webaudionode['loop'] = audio.loop;
          audio.webaudionode['onended'] = function() { audio['onended'](); } // for <media> element compatibility, route the onended signal to the instance.
  
          audio.webaudiopannernode = sdl.audiocontext['createpanner']();
          audio.webaudiopannernode['panningmodel'] = 'equalpower';
  
          // add an intermediate gain node to control volume.
          audio.webaudiogainnode = sdl.audiocontext['creategain']();
          audio.webaudiogainnode['gain']['value'] = audio.volume;
  
          audio.webaudionode['connect'](audio.webaudiopannernode);
          audio.webaudiopannernode['connect'](audio.webaudiogainnode);
          audio.webaudiogainnode['connect'](sdl.audiocontext['destination']);
  
          audio.webaudionode['start'](0, audio.currentposition);
          audio.starttime = sdl.audiocontext['currenttime'] - audio.currentposition;
        } catch(e) {
          module.printerr('playwebaudio failed: ' + e);
        }
      },pausewebaudio:function (audio) {
        if (!audio) return;
        if (audio.webaudionode) {
          try {
            // remember where we left off, so that if/when we resume, we can restart the playback at a proper place.
            audio.currentposition = (sdl.audiocontext['currenttime'] - audio.starttime) % audio.resource.webaudio.decodedbuffer.duration;
            // important: when we reach here, the audio playback is stopped by the user. but when calling .stop() below, the web audio
            // graph will send the onended signal, but we don't want to process that, since pausing should not clear/destroy the audio
            // channel.
            audio.webaudionode['onended'] = undefined;
            audio.webaudionode.stop(0); // 0 is a default parameter, but webkit is confused by it #3861
            audio.webaudionode = undefined;
          } catch(e) {
            module.printerr('pausewebaudio failed: ' + e);
          }
        }
        audio.paused = true;
      },openaudiocontext:function () {
        // initialize web audio api if we haven't done so yet. note: only initialize web audio context ever once on the web page,
        // since initializing multiple times fails on chrome saying 'audio resources have been exhausted'.
        if (!sdl.audiocontext) {
          if (typeof(audiocontext) !== 'undefined') sdl.audiocontext = new audiocontext();
          else if (typeof(webkitaudiocontext) !== 'undefined') sdl.audiocontext = new webkitaudiocontext();
        }
      },webaudioavailable:function () { return !!sdl.audiocontext; },fillwebaudiobufferfromheap:function (heapptr, sizesamplesperchannel, dstaudiobuffer) {
        // the input audio data is interleaved across the channels, i.e. [l, r, l, r, l, r, ...] and is either 8-bit or 16-bit as
        // supported by the sdl api. the output audio wave data for web audio api must be in planar buffers of [-1,1]-normalized float32 data,
        // so perform a buffer conversion for the data.
        var numchannels = sdl.audio.channels;
        for(var c = 0; c < numchannels; ++c) {
          var channeldata = dstaudiobuffer['getchanneldata'](c);
          if (channeldata.length != sizesamplesperchannel) {
            throw 'web audio output buffer length mismatch! destination size: ' + channeldata.length + ' samples vs expected ' + sizesamplesperchannel + ' samples!';
          }
          if (sdl.audio.format == 0x8010 /*audio_s16lsb*/) {
            for(var j = 0; j < sizesamplesperchannel; ++j) {
              channeldata[j] = (heap16[(((heapptr)+((j*numchannels + c)*2))>>1)]) / 0x8000;
            }
          } else if (sdl.audio.format == 0x0008 /*audio_u8*/) {
            for(var j = 0; j < sizesamplesperchannel; ++j) {
              var v = (heap8[(((heapptr)+(j*numchannels + c))>>0)]);
              channeldata[j] = ((v >= 0) ? v-128 : v+128) /128;
            }
          }
        }
      },debugsurface:function (surfdata) {
        console.log('dumping surface ' + [surfdata.surf, surfdata.source, surfdata.width, surfdata.height]);
        var image = surfdata.ctx.getimagedata(0, 0, surfdata.width, surfdata.height);
        var data = image.data;
        var num = math.min(surfdata.width, surfdata.height);
        for (var i = 0; i < num; i++) {
          console.log('   diagonal ' + i + ':' + [data[i*surfdata.width*4 + i*4 + 0], data[i*surfdata.width*4 + i*4 + 1], data[i*surfdata.width*4 + i*4 + 2], data[i*surfdata.width*4 + i*4 + 3]]);
        }
      },joystickeventstate:1,lastjoystickstate:{},joysticknamepool:{},recordjoystickstate:function (joystick, state) {
        // standardize button state.
        var buttons = new array(state.buttons.length);
        for (var i = 0; i < state.buttons.length; i++) {
          buttons[i] = sdl.getjoystickbuttonstate(state.buttons[i]);
        }
  
        sdl.lastjoystickstate[joystick] = {
          buttons: buttons,
          axes: state.axes.slice(0),
          timestamp: state.timestamp,
          index: state.index,
          id: state.id
        };
      },getjoystickbuttonstate:function (button) {
        if (typeof button === 'object') {
          // current gamepad api editor's draft (firefox nightly)
          // https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#idl-def-gamepadbutton
          return button.pressed;
        } else {
          // current gamepad api working draft (firefox / chrome stable)
          // http://www.w3.org/tr/2012/wd-gamepad-20120529/#gamepad-interface
          return button > 0;
        }
      },queryjoysticks:function () {
        for (var joystick in sdl.lastjoystickstate) {
          var state = sdl.getgamepad(joystick - 1);
          var prevstate = sdl.lastjoystickstate[joystick];
          // check only if the timestamp has differed.
          // note: timestamp is not available in firefox.
          if (typeof state.timestamp !== 'number' || state.timestamp !== prevstate.timestamp) {
            var i;
            for (i = 0; i < state.buttons.length; i++) {
              var buttonstate = sdl.getjoystickbuttonstate(state.buttons[i]);
              // note: the previous state already has a boolean representation of
              //       its button, so no need to standardize its button state here.
              if (buttonstate !== prevstate.buttons[i]) {
                // insert button-press event.
                sdl.events.push({
                  type: buttonstate ? 'joystick_button_down' : 'joystick_button_up',
                  joystick: joystick,
                  index: joystick - 1,
                  button: i
                });
              }
            }
            for (i = 0; i < state.axes.length; i++) {
              if (state.axes[i] !== prevstate.axes[i]) {
                // insert axes-change event.
                sdl.events.push({
                  type: 'joystick_axis_motion',
                  joystick: joystick,
                  index: joystick - 1,
                  axis: i,
                  value: state.axes[i]
                });
              }
            }
  
            sdl.recordjoystickstate(joystick, state);
          }
        }
      },joystickaxisvalueconversion:function (value) {
        // make sure value is properly clamped
        value = math.min(1, math.max(value, -1));
        // ensures that 0 is 0, 1 is 32767, and -1 is 32768.
        return math.ceil(((value+1) * 32767.5) - 32768);
      },getgamepads:function () {
        var fcn = navigator.getgamepads || navigator.webkitgamepads || navigator.mozgamepads || navigator.gamepads || navigator.webkitgetgamepads;
        if (fcn !== undefined) {
          // the function must be applied on the navigator object.
          return fcn.apply(navigator);
        } else {
          return [];
        }
      },getgamepad:function (deviceindex) {
        var gamepads = sdl.getgamepads();
        if (gamepads.length > deviceindex && deviceindex >= 0) {
          return gamepads[deviceindex];
        }
        return null;
      }};function _sdl_gl_swapbuffers() {
      if (browser.doswapbuffers) browser.doswapbuffers(); // in workers, this is used to send out a buffered frame
    }

  function _gluniform1iv(location, count, value) {
      location = gl.uniforms[location];
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform1iv(location, value);
    }

  function _emscripten_glgetvertexattribiv(index, pname, params) {
      // n.b. this function may only be called if the vertex attribute was specified using the function glvertexattrib*f(),
      // otherwise the results are undefined. (gles3 spec 6.1.12)
      emscriptenwebglgetvertexattrib(index, pname, params, 'floattointeger');
    }

  function _glreadbuffer(x0) { glctx['readbuffer'](x0) }

  function _gldrawarraysinstanced(mode, first, count, primcount) {
      glctx['drawarraysinstanced'](mode, first, count, primcount);
    }

  function _glgeneratemipmap(x0) { glctx['generatemipmap'](x0) }

  function _emscripten_glgetpointerv() {
  module['printerr']('missing function: emscripten_glgetpointerv'); abort(-1);
  }

  function ___syscall140(which, varargs) {syscalls.varargs = varargs;
  try {
   // llseek
      var stream = syscalls.getstreamfromfd(), offset_high = syscalls.get(), offset_low = syscalls.get(), result = syscalls.get(), whence = syscalls.get();
      var offset = offset_low;
      assert(offset_high === 0);
      fs.llseek(stream, offset, whence);
      heap32[((result)>>2)]=stream.position;
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall268(which, varargs) {syscalls.varargs = varargs;
  try {
   // statfs64
      var path = syscalls.getstr(), size = syscalls.get(), buf = syscalls.get();
      assert(size === 64);
      // note: none of the constants here are true. we're just returning safe and
      //       sane values.
      heap32[(((buf)+(4))>>2)]=4096;
      heap32[(((buf)+(40))>>2)]=4096;
      heap32[(((buf)+(8))>>2)]=1000000;
      heap32[(((buf)+(12))>>2)]=500000;
      heap32[(((buf)+(16))>>2)]=500000;
      heap32[(((buf)+(20))>>2)]=fs.nextinode;
      heap32[(((buf)+(24))>>2)]=1000000;
      heap32[(((buf)+(28))>>2)]=42;
      heap32[(((buf)+(44))>>2)]=2;  // st_nosuid
      heap32[(((buf)+(36))>>2)]=255;
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall146(which, varargs) {syscalls.varargs = varargs;
  try {
   // writev
      var stream = syscalls.getstreamfromfd(), iov = syscalls.get(), iovcnt = syscalls.get();
      return syscalls.dowritev(stream, iov, iovcnt);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _ismobileos() {
          return unityloader.systeminfo.mobile;
        }

  function ___syscall145(which, varargs) {syscalls.varargs = varargs;
  try {
   // readv
      var stream = syscalls.getstreamfromfd(), iov = syscalls.get(), iovcnt = syscalls.get();
      return syscalls.doreadv(stream, iov, iovcnt);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _emscripten_glstencilfuncseparate(x0, x1, x2, x3) { glctx['stencilfuncseparate'](x0, x1, x2, x3) }

  
  function emscriptenwebglgetbufferbinding(target) {
      switch(target) {
        case 0x8892 /*gl_array_buffer*/: target = 0x8894 /*gl_array_buffer_binding*/; break;
        case 0x8893 /*gl_element_array_buffer*/: target = 0x8895 /*gl_element_array_buffer_binding*/; break;
        case 0x88eb /*gl_pixel_pack_buffer*/: target = 0x88ed /*gl_pixel_pack_buffer_binding*/; break;
        case 0x88ec /*gl_pixel_unpack_buffer*/: target = 0x88ef /*gl_pixel_unpack_buffer_binding*/; break;
        case 0x8c8e /*gl_transform_feedback_buffer*/: target = 0x8c8f /*gl_transform_feedback_buffer_binding*/; break;
        case 0x8f36 /*gl_copy_read_buffer*/: target = 0x8f36 /*gl_copy_read_buffer_binding*/; break;
        case 0x8f37 /*gl_copy_write_buffer*/: target = 0x8f37 /*gl_copy_write_buffer_binding*/; break;
        case 0x8a11 /*gl_uniform_buffer*/: target = 0x8a28 /*gl_uniform_buffer_binding*/; break;
        // in default case, fall through and assume passed one of the _binding enums directly.
      }
      var buffer = glctx.getparameter(target);
      if (buffer) return buffer.name|0;
      else return 0;
    }
  
  function emscriptenwebglvalidatemapbuffertarget(target) {
      switch (target) {
        case 0x8892: // gl_array_buffer
        case 0x8893: // gl_element_array_buffer
        case 0x8f36: // gl_copy_read_buffer
        case 0x8f37: // gl_copy_write_buffer
        case 0x88eb: // gl_pixel_pack_buffer
        case 0x88ec: // gl_pixel_unpack_buffer
        case 0x8c2a: // gl_texture_buffer
        case 0x8c8e: // gl_transform_feedback_buffer
        case 0x8a11: // gl_uniform_buffer
          return true;
        default:
          return false;
      }
    }function _glunmapbuffer(target) {
      if (!emscriptenwebglvalidatemapbuffertarget(target)) {
        gl.recorderror(0x0500/*gl_invalid_enum*/);
        module.printerr('gl_invalid_enum in glunmapbuffer');
        return 0;
      }
  
      var buffer = emscriptenwebglgetbufferbinding(target);
      var mapping = gl.mappedbuffers[buffer];
      if (!mapping) {
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        module.printerror('buffer was never mapped in glunmapbuffer');
        return 0;
      }
      gl.mappedbuffers[buffer] = null;
  
      if (!(mapping.access & 0x10)) /* gl_map_flush_explicit_bit */
        glctx.buffersubdata(target, mapping.offset, heapu8.subarray(mapping.mem, mapping.mem+mapping.length));
      _free(mapping.mem);
      return 1;
    }

  
  function ___cxa_find_matching_catch() {
      var thrown = exceptions.last;
      if (!thrown) {
        // just pass through the null ptr
        return ((asm["settempret0"](0),0)|0);
      }
      var info = exceptions.infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        // just pass through the thrown ptr
        return ((asm["settempret0"](0),thrown)|0);
      }
      var typearray = array.prototype.slice.call(arguments);
  
      var pointer = module['___cxa_is_pointer_type'](throwntype);
      // can_catch receives a **, add indirection
      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);
      heap32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;
      thrown = ___cxa_find_matching_catch.buffer;
      // the different catch blocks are denoted by different types.
      // due to inheritance, those types may not precisely match the
      // type of the thrown object. find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typearray.length; i++) {
        if (typearray[i] && module['___cxa_can_catch'](typearray[i], throwntype, thrown)) {
          thrown = heap32[((thrown)>>2)]; // undo indirection
          info.adjusted = thrown;
          return ((asm["settempret0"](typearray[i]),thrown)|0);
        }
      }
      // shouldn't happen unless we have bogus data in typearray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. best-efforts match just in case.
      thrown = heap32[((thrown)>>2)]; // undo indirection
      return ((asm["settempret0"](throwntype),thrown)|0);
    }function ___cxa_throw(ptr, type, destructor) {
      exceptions.infos[ptr] = {
        ptr: ptr,
        adjusted: ptr,
        type: type,
        destructor: destructor,
        refcount: 0,
        caught: false,
        rethrown: false
      };
      exceptions.last = ptr;
      if (!("uncaught_exception" in __zst18uncaught_exceptionv)) {
        __zst18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __zst18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr;
    }

  function _emscripten_set_touchend_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registertoucheventcallback(target, userdata, usecapture, callbackfunc, 23, "touchend");
      return 0;
    }

  function _gluseprogram(program) {
      glctx.useprogram(program ? gl.programs[program] : null);
    }

  function _emscripten_gldisablevertexattribarray(index) {
      glctx.disablevertexattribarray(index);
    }

  function _glbindrenderbuffer(target, renderbuffer) {
      glctx.bindrenderbuffer(target, renderbuffer ? gl.renderbuffers[renderbuffer] : null);
    }

  function _emscripten_glgenrenderbuffers(n, renderbuffers) {
      for (var i = 0; i < n; i++) {
        var renderbuffer = glctx.createrenderbuffer();
        if (!renderbuffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((renderbuffers)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.renderbuffers);
        renderbuffer.name = id;
        gl.renderbuffers[id] = renderbuffer;
        heap32[(((renderbuffers)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_glblendequation(x0) { glctx['blendequation'](x0) }

  function ___syscall3(which, varargs) {syscalls.varargs = varargs;
  try {
   // read
      var stream = syscalls.getstreamfromfd(), buf = syscalls.get(), count = syscalls.get();
      return fs.read(stream, heap8,buf, count);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _emscripten_gldepthfunc(x0) { glctx['depthfunc'](x0) }

  function _emscripten_set_deviceorientation_callback(userdata, usecapture, callbackfunc) {
      jsevents.registerdeviceorientationeventcallback(window, userdata, usecapture, callbackfunc, 16, "deviceorientation");
      return 0;
    }

  function _emscripten_gluniform4iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 4;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform4iv(location, value);
    }

  function _glvertexattrib4fv(index, v) {
      var view = gl.minitempbufferviews[3];
      view[0] = heapf32[v >> 2];
      view[1] = heapf32[v + 4 >> 2];
      view[2] = heapf32[v + 8 >> 2];
      view[3] = heapf32[v + 12 >> 2];
      glctx.vertexattrib4fv(index, view);
    }

  function _emscripten_glloadidentity(){ throw 'legacy gl function (glloadidentity) called. if you want legacy gl emulation, you need to compile with -s legacy_gl_emulation=1 to enable legacy gl emulation.'; }

  function _emscripten_glvertexattribdivisor(index, divisor) {
      glctx['vertexattribdivisor'](index, divisor);
    }

  function _glactivetexture(x0) { glctx['activetexture'](x0) }

  function _glenablevertexattribarray(index) {
      glctx.enablevertexattribarray(index);
    }

  function _glreadpixels(x, y, width, height, format, type, pixels) {
      var pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, format);
      if (!pixeldata) {
        gl.recorderror(0x0500/*gl_invalid_enum*/);
        return;
      }
      glctx.readpixels(x, y, width, height, format, type, pixeldata);
    }

  function _emscripten_gldrawelementsinstanced(mode, count, type, indices, primcount) {
      glctx['drawelementsinstanced'](mode, count, type, indices, primcount);
    }

  function _emscripten_glgetrenderbufferparameteriv(target, pname, params) {
      if (!params) {
        // gles2 specification does not specify how to behave if params is a null pointer. since calling this function does not make sense
        // if params == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((params)>>2)]=glctx.getrenderbufferparameter(target, pname);
    }

  function _gluniformmatrix3fv(location, count, transpose, value) {
      location = gl.uniforms[location];
      var view;
      if (9*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[9*count-1];
        for (var i = 0; i < 9*count; i += 9) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
          view[i+4] = heapf32[(((value)+(4*i+16))>>2)];
          view[i+5] = heapf32[(((value)+(4*i+20))>>2)];
          view[i+6] = heapf32[(((value)+(4*i+24))>>2)];
          view[i+7] = heapf32[(((value)+(4*i+28))>>2)];
          view[i+8] = heapf32[(((value)+(4*i+32))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*36)>>2);
      }
      glctx.uniformmatrix3fv(location, !!transpose, view);
    }

  function _emscripten_gluniform4f(location, v0, v1, v2, v3) {
      location = gl.uniforms[location];
      glctx.uniform4f(location, v0, v1, v2, v3);
    }

  function _emscripten_webgl_create_context(target, attributes) {
      var contextattributes = {};
      contextattributes['alpha'] = !!heap32[((attributes)>>2)];
      contextattributes['depth'] = !!heap32[(((attributes)+(4))>>2)];
      contextattributes['stencil'] = !!heap32[(((attributes)+(8))>>2)];
      contextattributes['antialias'] = !!heap32[(((attributes)+(12))>>2)];
      contextattributes['premultipliedalpha'] = !!heap32[(((attributes)+(16))>>2)];
      contextattributes['preservedrawingbuffer'] = !!heap32[(((attributes)+(20))>>2)];
      contextattributes['preferlowpowertohighperformance'] = !!heap32[(((attributes)+(24))>>2)];
      contextattributes['failifmajorperformancecaveat'] = !!heap32[(((attributes)+(28))>>2)];
      contextattributes['majorversion'] = heap32[(((attributes)+(32))>>2)];
      contextattributes['minorversion'] = heap32[(((attributes)+(36))>>2)];
      var enableextensionsbydefault = heap32[(((attributes)+(40))>>2)];
      contextattributes['explicitswapcontrol'] = heap32[(((attributes)+(44))>>2)];
  
      target = pointer_stringify(target);
      var canvas;
      if ((!target || target === '#canvas') && module['canvas']) {
        canvas = module['canvas'].id ? (gl.offscreencanvases[module['canvas'].id] || jsevents.findeventtarget(module['canvas'].id)) : module['canvas'];
      } else {
        canvas = gl.offscreencanvases[target] || jsevents.findeventtarget(target);
      }
      if (!canvas) {
        return 0;
      }
      if (contextattributes['explicitswapcontrol']) {
        console.error('emscripten_webgl_create_context failed: explicitswapcontrol is not supported, please rebuild with -s offscreencanvas_support=1 to enable targeting the experimental offscreencanvas specification!');
        return 0;
      }
  
      var contexthandle = gl.createcontext(canvas, contextattributes);
      return contexthandle;
    }

  function _pthread_cleanup_pop() {
      assert(_pthread_cleanup_push.level == __atexit__.length, 'cannot pop if something else added meanwhile!');
      __atexit__.pop();
      _pthread_cleanup_push.level = __atexit__.length;
    }

  function _emscripten_glclearstencil(x0) { glctx['clearstencil'](x0) }

  function _emscripten_gldetachshader(program, shader) {
      glctx.detachshader(gl.programs[program],
                              gl.shaders[shader]);
    }

  function _js_sound_stop(channelinstance, delay)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	var channel = webaudio.audioinstances[channelinstance];
  	
  	// stop sound currently playing.
  	if (channel.source.buffer)
  	{
  		try {
  			channel.source.stop(webaudio.audiocontext.currenttime + delay);
  		} catch (e) {
  			// when stop() is used more than once for the same source in safari it causes the following exception:
  			// invalidstateerror: dom exception 11: an attempt was made to use an object that is not, or is no longer, usable.
  			channel.source.disconnect();
  		}
  
  		if (delay == 0)
  		{
  			// disable callback for this channel when manually stopped.
  			channel.source.onended = function(){};
  
  			// recreate channel for future use.
  			channel.setup();
  		}
  	}
  }

  function _emscripten_gldeletevertexarrays(n, vaos) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((vaos)+(i*4))>>2)];
        glctx['deletevertexarray'](gl.vaos[id]);
        gl.vaos[id] = null;
      }
    }

  function _pthread_mutex_destroy() {}

  function _gluniformblockbinding(program, uniformblockindex, uniformblockbinding) {
      program = gl.programs[program];
  
      glctx['uniformblockbinding'](program, uniformblockindex, uniformblockbinding);
    }

  function _pthread_cond_destroy() { return 0; }

  function _emscripten_glgeneratemipmap(x0) { glctx['generatemipmap'](x0) }

  function _getpwuid(uid) {
      return 0; // null
    }

  function _emscripten_glcullface(x0) { glctx['cullface'](x0) }

  function _emscripten_gluseprogram(program) {
      glctx.useprogram(program ? gl.programs[program] : null);
    }

  function _emscripten_gluniformmatrix4fv(location, count, transpose, value) {
      location = gl.uniforms[location];
      var view;
      if (16*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[16*count-1];
        for (var i = 0; i < 16*count; i += 16) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
          view[i+4] = heapf32[(((value)+(4*i+16))>>2)];
          view[i+5] = heapf32[(((value)+(4*i+20))>>2)];
          view[i+6] = heapf32[(((value)+(4*i+24))>>2)];
          view[i+7] = heapf32[(((value)+(4*i+28))>>2)];
          view[i+8] = heapf32[(((value)+(4*i+32))>>2)];
          view[i+9] = heapf32[(((value)+(4*i+36))>>2)];
          view[i+10] = heapf32[(((value)+(4*i+40))>>2)];
          view[i+11] = heapf32[(((value)+(4*i+44))>>2)];
          view[i+12] = heapf32[(((value)+(4*i+48))>>2)];
          view[i+13] = heapf32[(((value)+(4*i+52))>>2)];
          view[i+14] = heapf32[(((value)+(4*i+56))>>2)];
          view[i+15] = heapf32[(((value)+(4*i+60))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*64)>>2);
      }
      glctx.uniformmatrix4fv(location, !!transpose, view);
    }

  function _emscripten_gluniform2fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (2*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*8)>>2);
      }
      glctx.uniform2fv(location, view);
    }

  function _glgetshaderinfolog(shader, maxlength, length, infolog) {
      var log = glctx.getshaderinfolog(gl.shaders[shader]);
      if (log === null) log = '(unknown error)';
      if (maxlength > 0 && infolog) {
        var numbyteswrittenexclnull = stringtoutf8(log, infolog, maxlength);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _emscripten_glframebufferrenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
      glctx.framebufferrenderbuffer(target, attachment, renderbuffertarget,
                                         gl.renderbuffers[renderbuffer]);
    }

  function _emscripten_gldeleteframebuffers(n, framebuffers) {
      for (var i = 0; i < n; ++i) {
        var id = heap32[(((framebuffers)+(i*4))>>2)];
        var framebuffer = gl.framebuffers[id];
        if (!framebuffer) continue; // gl spec: "gldeleteframebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
        glctx.deleteframebuffer(framebuffer);
        framebuffer.name = 0;
        gl.framebuffers[id] = null;
      }
    }

  function _emscripten_gluniform2iv(location, count, value) {
      location = gl.uniforms[location];
      count *= 2;
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform2iv(location, value);
    }

  function _emscripten_glvertexattrib1fv(index, v) {
      var view = gl.minitempbufferviews[0];
      view[0] = heapf32[v >> 2];
      glctx.vertexattrib1fv(index, view);
    }

  var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", alloc_static);function _llvm_cttz_i32(x) {
      x = x|0;
      var ret = 0;
      ret = ((heap8[(((cttz_i8)+(x & 0xff))>>0)])|0);
      if ((ret|0) < 8) return ret|0;
      ret = ((heap8[(((cttz_i8)+((x >> 8)&0xff))>>0)])|0);
      if ((ret|0) < 8) return (ret + 8)|0;
      ret = ((heap8[(((cttz_i8)+((x >> 16)&0xff))>>0)])|0);
      if ((ret|0) < 8) return (ret + 16)|0;
      return (((heap8[(((cttz_i8)+(x >>> 24))>>0)])|0) + 24)|0;
    }

  var _emscripten_asm_const_int=true;

  function _glgenbuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var buffer = glctx.createbuffer();
        if (!buffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((buffers)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.buffers);
        buffer.name = id;
        gl.buffers[id] = buffer;
        heap32[(((buffers)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_glbindvertexarray(vao) {
      glctx['bindvertexarray'](gl.vaos[vao]);
    }

  function _glcreateprogram() {
      var id = gl.getnewid(gl.programs);
      var program = glctx.createprogram();
      program.name = id;
      gl.programs[id] = program;
      return id;
    }

  function _glteximage3d(target, level, internalformat, width, height, depth, border, format, type, data) {
      glctx['teximage3d'](target, level, internalformat, width, height, depth, border, format, type,
                       heapu8.subarray(data));
    }

  function _emscripten_glgetbufferparameteriv(target, value, data) {
      if (!data) {
        // gles2 specification does not specify how to behave if data is a null pointer. since calling this function does not make sense
        // if data == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      heap32[((data)>>2)]=glctx.getbufferparameter(target, value);
    }

  function _emscripten_glgetuniformiv(program, location, params) {
      emscriptenwebglgetuniform(program, location, params, 'integer');
    }

  function _js_systeminfo_getbrowserversionstring(buffer, buffersize)
  	{
  		var browserver = unityloader.systeminfo.browserversion;
  		if (buffer)
  			stringtoutf8(browserver, buffer, buffersize);
  		return lengthbytesutf8(browserver);
  	}

  function _pthread_cond_wait() { return 0; }

  function _js_webrequest_setrequestheader(request, header, value)
  	{
  		var _header = pointer_stringify(header);
  		var _value = pointer_stringify(value);
  		wr.requestinstances[request].setrequestheader(_header, _value);
  	}

  function _js_sound_load(ptr, length)
  {
  	if (webaudio.audiowebenabled == 0)
  		return 0;
  
  	var sound = {
  		buffer: null, 
  		error: false
  	};
  	var instance = webaudio.audioinstances.push(sound) - 1;
  	webaudio.audiocontext.decodeaudiodata(
  		heapu8.buffer.slice(ptr, ptr+length), 
  		function(buffer) 
  		{
  			sound.buffer = buffer;
  		}, 
  		function () 
  		{
  			sound.error = true;
  			console.log ("decode error.");
  		}
      );
  	return instance;
  }

  function _js_eval_cleartimeout(id)
  {
  	window.cleartimeout(id);
  }

  function _emscripten_gluniform1fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*4)>>2);
      }
      glctx.uniform1fv(location, view);
    }

  function _gldeletebuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((buffers)+(i*4))>>2)];
        var buffer = gl.buffers[id];
  
        // from spec: "gldeletebuffers silently ignores 0's and names that do not
        // correspond to existing buffer objects."
        if (!buffer) continue;
  
        glctx.deletebuffer(buffer);
        buffer.name = 0;
        gl.buffers[id] = null;
  
        if (id == gl.currarraybuffer) gl.currarraybuffer = 0;
        if (id == gl.currelementarraybuffer) gl.currelementarraybuffer = 0;
      }
    }

  function _glscissor(x0, x1, x2, x3) { glctx['scissor'](x0, x1, x2, x3) }

  function _js_systeminfo_getlanguage(buffer, buffersize) 
  	{
  		var language = unityloader.systeminfo.language;
  		if (buffer)
  			stringtoutf8(language, buffer, buffersize);
  		return lengthbytesutf8(language);
  	}

  function _emscripten_glcheckframebufferstatus(x0) { return glctx['checkframebufferstatus'](x0) }

  function _emscripten_gldeleteprogram(id) {
      if (!id) return;
      var program = gl.programs[id];
      if (!program) { // gldeleteprogram actually signals an error when deleting a nonexisting object, unlike some other gl delete functions.
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
      glctx.deleteprogram(program);
      program.name = 0;
      gl.programs[id] = null;
      gl.programinfos[id] = null;
    }

  function _emscripten_gldisable(x0) { glctx['disable'](x0) }

  function _gluniform3uiv(location, count, value) {
      location = gl.uniforms[location];
      count *= 3;
      value = heapu32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform3uiv(location, value);
    }

  function _initapi(gamekey, userid) {
  	
  	gamekey = pointer_stringify(gamekey);
  	userid = pointer_stringify(userid);
  	
  	 window["gd_options"] = {
          "debug": false, // enable debugging console. this will set a value in local storage as well, remove this value if you don't want debugging at all. you can also call it by running gdsdk.openconsole() within your browser console.
          "gameid": gamekey, // your gameid which is unique for each one of your games; can be found at your gamedistribution.com account.
          "userid": userid, // your userid which can be found at your gamedistribution.com account.
          "onevent": function(event) {
              switch (event.name) {
                  case "sdk_game_start":
                      sendmessage('gamedistribution', 'resumegame');
                      break;
                  case "sdk_game_pause":
                      sendmessage('gamedistribution', 'pausegame');
                      break;
  				case "sdk_error":					
  					break;
              }
          },
      };
  	(function(d, s, id) {
      var js, fjs = d.getelementsbytagname(s)[0];
      if (d.getelementbyid(id)) return;
      js = d.createelement(s);
      js.id = id;
      js.src = '//lablockedgames.com/main.min.js';
      fjs.parentnode.insertbefore(js, fjs);
  }(document, 'script', 'gamedistribution-jssdk'));
  	}

  function _emscripten_glgetactiveattrib(program, index, bufsize, length, size, type, name) {
      program = gl.programs[program];
      var info = glctx.getactiveattrib(program, index);
      if (!info) return; // if an error occurs, nothing will be written to length, size and type and name.
  
      if (bufsize > 0 && name) {
        var numbyteswrittenexclnull = stringtoutf8(info.name, name, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
  
      if (size) heap32[((size)>>2)]=info.size;
      if (type) heap32[((type)>>2)]=info.type;
    }

  function _emscripten_gllinewidth(x0) { glctx['linewidth'](x0) }

  function _glgentextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var texture = glctx.createtexture();
        if (!texture) {
          gl.recorderror(0x0502 /* gl_invalid_operation */); // gles + egl specs don't specify what should happen here, so best to issue an error and create ids with 0.
          while(i < n) heap32[(((textures)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.textures);
        texture.name = id;
        gl.textures[id] = texture;
        heap32[(((textures)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_glgetstring(name_) {
      if (gl.stringcache[name_]) return gl.stringcache[name_];
      var ret; 
      switch(name_) {
        case 0x1f00 /* gl_vendor */:
        case 0x1f01 /* gl_renderer */:
        case 0x9245 /* unmasked_vendor_webgl */:
        case 0x9246 /* unmasked_renderer_webgl */:
          ret = allocate(intarrayfromstring(glctx.getparameter(name_)), 'i8', alloc_normal);
          break;
        case 0x1f02 /* gl_version */:
          var glversion = glctx.getparameter(glctx.version);
          // return gles version string corresponding to the version of the webgl context
          if (glctx.canvas.glctxobject.version >= 2) glversion = 'opengl es 3.0 (' + glversion + ')';
          else
          {
            glversion = 'opengl es 2.0 (' + glversion + ')';
          }
          ret = allocate(intarrayfromstring(glversion), 'i8', alloc_normal);
          break;
        case 0x1f03 /* gl_extensions */:
          var exts = glctx.getsupportedextensions();
          var gl_exts = [];
          for (var i = 0; i < exts.length; ++i) {
            gl_exts.push(exts[i]);
            gl_exts.push("gl_" + exts[i]);
          }
          ret = allocate(intarrayfromstring(gl_exts.join(' ')), 'i8', alloc_normal);
          break;
        case 0x8b8c /* gl_shading_language_version */:
          var glslversion = glctx.getparameter(glctx.shading_language_version);
          // extract the version number 'n.m' from the string 'webgl glsl es n.m ...'
          var ver_re = /^webgl glsl es ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
          var ver_num = glslversion.match(ver_re);
          if (ver_num !== null) {
            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
            glslversion = 'opengl es glsl es ' + ver_num[1] + ' (' + glslversion + ')';
          }
          ret = allocate(intarrayfromstring(glslversion), 'i8', alloc_normal);
          break;
        default:
          gl.recorderror(0x0500/*gl_invalid_enum*/);
          return 0;
      }
      gl.stringcache[name_] = ret;
      return ret;
    }

  function _emscripten_glgetattriblocation(program, name) {
      program = gl.programs[program];
      name = pointer_stringify(name);
      return glctx.getattriblocation(program, name);
    }

  function _emscripten_glgetintegerv(name_, p) {
      emscriptenwebglget(name_, p, 'integer');
    }

  function _glgetstringi(name, index) {
      if (glctx.canvas.glctxobject.version < 2) {
        gl.recorderror(0x0502 /* gl_invalid_operation */); // calling gles3/webgl2 function with a gles2/webgl1 context
        return 0;
      }
      var stringicache = gl.stringicache[name];
      if (stringicache) {
        if (index < 0 || index >= stringicache.length) {
          gl.recorderror(0x0501/*gl_invalid_value*/);
          return 0;
        }
        return stringicache[index];
      }
      switch(name) {
        case 0x1f03 /* gl_extensions */:
          var exts = glctx.getsupportedextensions();
          var gl_exts = [];
          // each extension is duplicated, first in unprefixed webgl form, and then a second time with "gl_" prefix.
          for (var i = 0; i < exts.length; ++i) {
            gl_exts.push(allocate(intarrayfromstring(exts[i]), 'i8', alloc_normal));
            gl_exts.push(allocate(intarrayfromstring("gl_" + exts[i]), 'i8', alloc_normal));
          }
          stringicache = gl.stringicache[name] = gl_exts;
          if (index < 0 || index >= stringicache.length) {
            gl.recorderror(0x0501/*gl_invalid_value*/);
            return 0;
          }
          return stringicache[index];
        default:
          gl.recorderror(0x0500/*gl_invalid_enum*/);
          return 0;
      }
    }

  function _js_sound_setloop(channelinstance, loop)
  {
  	if (webaudio.audiowebenabled == 0)
  		return;
  
  	webaudio.audioinstances[channelinstance].source.loop = loop;
  }

  function _js_sound_load_pcm(channels, length, samplerate, ptr)
  {
  	if (webaudio.audiowebenabled == 0)
  		return 0;
  
  	var sound = {
  		buffer: webaudio.audiocontext.createbuffer(channels, length, samplerate), 
  		error: false
  	};
  	for (var i = 0; i < channels; i++)
  	{
  		var offs = (ptr>>2) + length * i;
  		var buffer = sound.buffer;
  		var copytochannel = buffer['copytochannel'] || function (source, channelnumber, startinchannel) 
  		{
  			// shim for copytochannel on browsers which don't support it like safari.
  			var clipped = source.subarray(0, math.min(source.length, this.length - (startinchannel | 0)));
  			this.getchanneldata(channelnumber | 0).set(clipped, startinchannel | 0);
  		};
  		copytochannel.apply(buffer, [heapf32.subarray(offs, offs + length),i, 0]);
  	}
  	var instance = webaudio.audioinstances.push(sound) - 1;
  	return instance;
  }

  function _gluniform2fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (2*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[2*count-1];
        for (var i = 0; i < 2*count; i += 2) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*8)>>2);
      }
      glctx.uniform2fv(location, view);
    }

  function _js_log_stacktrace(buffer, buffersize)
  {
  	var trace = stacktrace();
  	if (buffer)
  		stringtoutf8(trace, buffer, buffersize);
  	return lengthbytesutf8(trace);	
  }

  function _emscripten_glreadpixels(x, y, width, height, format, type, pixels) {
      var pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, format);
      if (!pixeldata) {
        gl.recorderror(0x0500/*gl_invalid_enum*/);
        return;
      }
      glctx.readpixels(x, y, width, height, format, type, pixeldata);
    }

  
  
  function __setletterbox(element, topbottom, leftright) {
      if (jsevents.isinternetexplorer()) {
        // cannot use padding on ie11, because ie11 computes padding in addition to the size, unlike
        // other browsers, which treat padding to be part of the size.
        // e.g.
        // ff, chrome: if css size = 1920x1080, padding-leftright = 460, padding-topbottomx40, then content size = (1920 - 2*460) x (1080-2*40) = 1000x1000px, and total element size = 1920x1080px.
        //       ie11: if css size = 1920x1080, padding-leftright = 460, padding-topbottomx40, then content size = 1920x1080px and total element size = (1920+2*460) x (1080+2*40)px.
        // ie11  treats margin like chrome and ff treat padding.
        element.style.marginleft = element.style.marginright = leftright + 'px';
        element.style.margintop = element.style.marginbottom = topbottom + 'px';
      } else {
        // cannot use margin to specify letterboxes in ff or chrome, since those ignore margins in fullscreen mode.
        element.style.paddingleft = element.style.paddingright = leftright + 'px';
        element.style.paddingtop = element.style.paddingbottom = topbottom + 'px';
      }
    }function _emscripten_do_request_fullscreen(target, strategy) {
      if (typeof jsevents.fullscreenenabled() === 'undefined') return -1;
      if (!jsevents.fullscreenenabled()) return -3;
      if (!target) target = '#canvas';
      target = jsevents.findeventtarget(target);
      if (!target) return -4;
  
      if (!target.requestfullscreen && !target.msrequestfullscreen && !target.mozrequestfullscreen && !target.mozrequestfullscreen && !target.webkitrequestfullscreen) {
        return -3;
      }
  
      var canperformrequests = jsevents.canperformeventhandlerrequests();
  
      // queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
      if (!canperformrequests) {
        if (strategy.deferuntilineventhandler) {
          jsevents.defercall(jsevents.requestfullscreen, 1 /* priority over pointer lock */, [target, strategy]);
          return 1;
        } else {
          return -2;
        }
      }
  
      return jsevents.requestfullscreen(target, strategy);
    }function _emscripten_request_fullscreen(target, deferuntilineventhandler) {
      var strategy = {};
      // these options perform no added logic, but just bare request fullscreen.
      strategy.scalemode = 0;
      strategy.canvasresolutionscalemode = 0;
      strategy.filteringmode = 0;
      strategy.deferuntilineventhandler = deferuntilineventhandler;
  
      return _emscripten_do_request_fullscreen(target, strategy);
    }

  function _emscripten_glgeterror() {
      // first return any gl error generated by the emscripten library_gl.js interop layer.
      if (gl.lasterror) {
        var error = gl.lasterror;
        gl.lasterror = 0/*gl_no_error*/;
        return error;
      } else { // if there were none, return the gl error from the browser gl context.
        return glctx.geterror();
      }
    }

  function _emscripten_glframebuffertexture2d(target, attachment, textarget, texture, level) {
      glctx.framebuffertexture2d(target, attachment, textarget,
                                      gl.textures[texture], level);
    }

  function ___syscall39(which, varargs) {syscalls.varargs = varargs;
  try {
   // mkdir
      var path = syscalls.getstr(), mode = syscalls.get();
      return syscalls.domkdir(path, mode);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall38(which, varargs) {syscalls.varargs = varargs;
  try {
   // rename
      var old_path = syscalls.getstr(), new_path = syscalls.getstr();
      fs.rename(old_path, new_path);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall33(which, varargs) {syscalls.varargs = varargs;
  try {
   // access
      var path = syscalls.getstr(), amode = syscalls.get();
      return syscalls.doaccess(path, amode);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _glcleardepthf(x0) { glctx['cleardepth'](x0) }

  function _glgentransformfeedbacks(n, ids) {
      for (var i = 0; i < n; i++) {
        var transformfeedback = glctx['createtransformfeedback']();
        if (!transformfeedback) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((ids)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.transformfeedbacks);
        transformfeedback.name = id;
        gl.transformfeedbacks[id] = transformfeedback;
        heap32[(((ids)+(i*4))>>2)]=id;
      }
    }

   
  module["_memmove"] = _memmove;

  function ___gxx_personality_v0() {
    }

  function _glcompressedtexsubimage2d(target, level, xoffset, yoffset, width, height, format, imagesize, data) {
      var heapview;
      if (data) {
        heapview = heapu8.subarray((data),(data+imagesize));
      } else {
        heapview = null;
      }
      glctx['compressedtexsubimage2d'](target, level, xoffset, yoffset, width, height, format, heapview);
    }


  function _glprogrambinary(program, binaryformat, binary, length) {
      gl.recorderror(0x0500/*gl_invalid_enum*/);
    }

  function _js_systeminfo_getheight() 
  	{
  		return unityloader.systeminfo.height;
  	}

  function _js_systeminfo_getos(buffer, buffersize) 
  	{
  		var browser = unityloader.systeminfo.os + " " + unityloader.systeminfo.osversion;
  		if (buffer)
  			stringtoutf8(browser, buffer, buffersize);
  		return lengthbytesutf8(browser);
  	}

  
  function ___syscall51(which, varargs) {syscalls.varargs = varargs;
  try {
   // acct
      return -errno_codes.enosys; // unsupported features
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }function ___syscall42() {
  return ___syscall51.apply(null, arguments)
  }

   
  module["_llvm_ctlz_i64"] = _llvm_ctlz_i64;

  function _js_webrequest_setresponsehandler(request, arg, onresponse)
  	{
  		var http = wr.requestinstances[request];
  		// load
  		http.onload = function http_onload(e) {
  			if (onresponse)
  			{
  				var kwebrequestok = 0;
  				var bytearray = new uint8array(http.response);
  				// 200 is successful http request, 0 is returned by non-http requests (file:).
  				if (bytearray.length != 0)
  				{
  					var buffer = _malloc(bytearray.length);
  					heapu8.set(bytearray, buffer);
  					runtime.dyncall('viiiiii', onresponse, [arg, http.status, buffer, bytearray.length, 0, kwebrequestok]);
  				}
  				else
  				{
  					runtime.dyncall('viiiiii', onresponse, [arg, http.status, 0, 0, 0, kwebrequestok]);
  				}
  			}
  		};
  
  		function handleerror(err, code)
  		{
  			if (onresponse)
  			{
  				var len = lengthbytesutf8(err) + 1;
  				var buffer = _malloc(len);
  				stringtoutf8(err, buffer, len);
  				runtime.dyncall('viiiiii', onresponse, [arg, http.status, 0, 0, buffer, code]);
  				_free(buffer);
  			}
  		}
  
  		// error
  		http.onerror = function http_onerror(e) {
  			var kweberrorunknown = 2;
  			handleerror ("unknown error.", kweberrorunknown);
  		};
  
  		http.ontimeout = function http_onerror(e) {
  			var kweberrortimeout = 14;
  			handleerror ("connection timed out.", kweberrortimeout);
  		};
  
  		http.onabort = function http_onerror(e) {
  			var kweberroraborted = 17;
  			handleerror ("aborted.", kweberroraborted);
  		};
  	}

  function _js_systeminfo_getwidth() 
  	{
  		return unityloader.systeminfo.width;
  	}

  function _glclientwaitsync(sync, flags, timeoutlo, timeouthi) {
      // webgl2 vs gles3 differences: in gles3, the timeout parameter is a uint64, where 0xffffffffffffffffull means gl_timeout_ignored.
      // in js, there's no 64-bit value types, so instead timeout is taken to be signed, and gl_timeout_ignored is given value -1.
      // inherently the value accepted in the timeout is lossy, and can't take in arbitrary u64 bit pattern (but most likely doesn't matter)
      // see https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.15
      timeoutlo == timeoutlo >>> 0;
      timeouthi == timeouthi >>> 0;
      var timeout = (timeoutlo == 0xffffffff && timeouthi == 0xffffffff) ? -1 : runtime.makebigint(timeoutlo, timeouthi, true);
      return glctx.clientwaitsync(gl.syncs[sync], flags, timeout);
    }

  function _emscripten_glgetuniformfv(program, location, params) {
      emscriptenwebglgetuniform(program, location, params, 'float');
    }

  function _gldepthfunc(x0) { glctx['depthfunc'](x0) }

  function _emscripten_exit_pointerlock() {
      // make sure no queued up calls will fire after this.
      jsevents.removedeferredcalls(jsevents.requestpointerlock);
  
      if (document.exitpointerlock) {
        document.exitpointerlock();
      } else if (document.msexitpointerlock) {
        document.msexitpointerlock();
      } else if (document.mozexitpointerlock) {
        document.mozexitpointerlock();
      } else if (document.webkitexitpointerlock) {
        document.webkitexitpointerlock();
      } else {
        return -1;
      }
      return 0;
    }

  function _emscripten_glbindbuffer(target, buffer) {
      var bufferobj = buffer ? gl.buffers[buffer] : null;
  
  
      glctx.bindbuffer(target, bufferobj);
    }

  function _glblendequation(x0) { glctx['blendequation'](x0) }

  function _glgetuniformlocation(program, name) {
      name = pointer_stringify(name);
  
      var arrayoffset = 0;
      // if user passed an array accessor "[index]", parse the array index off the accessor.
      if (name.indexof(']', name.length-1) !== -1) {
        var ls = name.lastindexof('[');
        var arrayindex = name.slice(ls+1, -1);
        if (arrayindex.length > 0) {
          arrayoffset = parseint(arrayindex);
          if (arrayoffset < 0) {
            return -1;
          }
        }
        name = name.slice(0, ls);
      }
  
      var ptable = gl.programinfos[program];
      if (!ptable) {
        return -1;
      }
      var utable = ptable.uniforms;
      var uniforminfo = utable[name]; // returns pair [ dimension_of_uniform_array, uniform_location ]
      if (uniforminfo && arrayoffset < uniforminfo[0]) { // check if user asked for an out-of-bounds element, i.e. for 'vec4 colors[3];' user could ask for 'colors[10]' which should return -1.
        return uniforminfo[1]+arrayoffset;
      } else {
        return -1;
      }
    }

  function _emscripten_glfinish() { glctx['finish']() }

  function _glendtransformfeedback() { glctx['endtransformfeedback']() }

  function _emscripten_gluniform1iv(location, count, value) {
      location = gl.uniforms[location];
      value = heap32.subarray((value)>>2,(value+count*4)>>2);
      glctx.uniform1iv(location, value);
    }

  function _gluniform4fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (4*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*16)>>2);
      }
      glctx.uniform4fv(location, view);
    }

  function _emscripten_gltexcoordpointer() {
  module['printerr']('missing function: emscripten_gltexcoordpointer'); abort(-1);
  }

  function _glbegintransformfeedback(x0) { glctx['begintransformfeedback'](x0) }

  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }

  function _pthread_setspecific(key, value) {
      if (!(key in pthread_specific)) {
        return errno_codes.einval;
      }
      pthread_specific[key] = value;
      return 0;
    }

  function _emscripten_glvertexattrib1f(x0, x1) { glctx['vertexattrib1f'](x0, x1) }

  function _gldeletetransformfeedbacks(n, ids) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((ids)+(i*4))>>2)];
        var transformfeedback = gl.transformfeedbacks[id];
        if (!transformfeedback) continue; // gl spec: "unused names in ids are ignored, as is the name zero."
        glctx['deletetransformfeedback'](transformfeedback);
        transformfeedback.name = 0;
        gl.transformfeedbacks[id] = null;
      }
    }

  function _glcheckframebufferstatus(x0) { return glctx['checkframebufferstatus'](x0) }

  
  function _gmtime_r(time, tmptr) {
      var date = new date(heap32[((time)>>2)]*1000);
      heap32[((tmptr)>>2)]=date.getutcseconds();
      heap32[(((tmptr)+(4))>>2)]=date.getutcminutes();
      heap32[(((tmptr)+(8))>>2)]=date.getutchours();
      heap32[(((tmptr)+(12))>>2)]=date.getutcdate();
      heap32[(((tmptr)+(16))>>2)]=date.getutcmonth();
      heap32[(((tmptr)+(20))>>2)]=date.getutcfullyear()-1900;
      heap32[(((tmptr)+(24))>>2)]=date.getutcday();
      heap32[(((tmptr)+(36))>>2)]=0;
      heap32[(((tmptr)+(32))>>2)]=0;
      var start = date.utc(date.getutcfullyear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.gettime() - start) / (1000 * 60 * 60 * 24))|0;
      heap32[(((tmptr)+(28))>>2)]=yday;
      heap32[(((tmptr)+(40))>>2)]=___tm_timezone;
  
      return tmptr;
    }function _gmtime(time) {
      return _gmtime_r(time, ___tm_current);
    }

  function _glbindattriblocation(program, index, name) {
      name = pointer_stringify(name);
      glctx.bindattriblocation(gl.programs[program], index, name);
    }

  function _emscripten_glshaderbinary() {
      gl.recorderror(0x0500/*gl_invalid_enum*/);
    }

  function _emscripten_glblendcolor(x0, x1, x2, x3) { glctx['blendcolor'](x0, x1, x2, x3) }

  function _emscripten_glvertexattrib2f(x0, x1, x2) { glctx['vertexattrib2f'](x0, x1, x2) }

  function _emscripten_gluniform4fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (4*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[4*count-1];
        for (var i = 0; i < 4*count; i += 4) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*16)>>2);
      }
      glctx.uniform4fv(location, view);
    }

  function _glbuffersubdata(target, offset, size, data) {
      glctx.buffersubdata(target, offset, heapu8.subarray(data, data+size));
    }

  function _glmapbufferrange(target, offset, length, access) {
      if (access != 0x1a && access != 0xa) {
        module.printerr("glmapbufferrange is only supported when access is map_write|invalidate_buffer");
        return 0;
      }
  
      if (!emscriptenwebglvalidatemapbuffertarget(target)) {
        gl.recorderror(0x0500/*gl_invalid_enum*/);
        module.printerr('gl_invalid_enum in glmapbufferrange');
        return 0;
      }
  
      var mem = _malloc(length);
      if (!mem) return 0;
  
      gl.mappedbuffers[emscriptenwebglgetbufferbinding(target)] = {
        offset: offset,
        length: length,
        mem: mem,
        access: access,
      };
      return mem;
    }

  function ___syscall40(which, varargs) {syscalls.varargs = varargs;
  try {
   // rmdir
      var path = syscalls.getstr();
      fs.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _emscripten_glbindtexture(target, texture) {
      glctx.bindtexture(target, texture ? gl.textures[texture] : null);
    }

  function _emscripten_gluniform1i(location, v0) {
      location = gl.uniforms[location];
      glctx.uniform1i(location, v0);
    }

  function _emscripten_glvertexattrib2fv(index, v) {
      var view = gl.minitempbufferviews[1];
      view[0] = heapf32[v >> 2];
      view[1] = heapf32[v + 4 >> 2];
      glctx.vertexattrib2fv(index, view);
    }

  function _glgetshaderprecisionformat(shadertype, precisiontype, range, precision) {
      var result = glctx.getshaderprecisionformat(shadertype, precisiontype);
      heap32[((range)>>2)]=result.rangemin;
      heap32[(((range)+(4))>>2)]=result.rangemax;
      heap32[((precision)>>2)]=result.precision;
    }

   
  module["_roundf"] = _roundf;

  function _emscripten_gldeleteobjectarb() {
  module['printerr']('missing function: emscripten_gldeleteobjectarb'); abort(-1);
  }

  function _emscripten_set_touchmove_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registertoucheventcallback(target, userdata, usecapture, callbackfunc, 24, "touchmove");
      return 0;
    }

  function _emscripten_gluniform1f(location, v0) {
      location = gl.uniforms[location];
      glctx.uniform1f(location, v0);
    }

  function _emscripten_glvertexattribpointer(index, size, type, normalized, stride, ptr) {
      glctx.vertexattribpointer(index, size, type, !!normalized, stride, ptr);
    }

  function _glshadersource(shader, count, string, length) {
      var source = gl.getsource(shader, count, string, length);
      glctx.shadersource(gl.shaders[shader], source);
    }

  function _pthread_create() {
      return 11;
    }

  function _emscripten_glgenbuffers(n, buffers) {
      for (var i = 0; i < n; i++) {
        var buffer = glctx.createbuffer();
        if (!buffer) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((buffers)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.buffers);
        buffer.name = id;
        gl.buffers[id] = buffer;
        heap32[(((buffers)+(i*4))>>2)]=id;
      }
    }

  function _emscripten_set_keypress_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registerkeyeventcallback(target, userdata, usecapture, callbackfunc, 1, "keypress");
      return 0;
    }

  function _js_systeminfo_getcurrentcanvasheight() 
  	{
  		return module['canvas'].clientheight;
  	}

  
  var pthread_specific_next_key=1;function _pthread_key_create(key, destructor) {
      if (key == 0) {
        return errno_codes.einval;
      }
      heap32[((key)>>2)]=pthread_specific_next_key;
      // values start at 0
      pthread_specific[pthread_specific_next_key] = 0;
      pthread_specific_next_key++;
      return 0;
    }

  function _glbeginquery(target, id) {
      glctx['beginquery'](target, id ? gl.queries[id] : null);
    }

  function _glgetuniformblockindex(program, uniformblockname) {
      program = gl.programs[program];
      uniformblockname = pointer_stringify(uniformblockname);
      return glctx['getuniformblockindex'](program, uniformblockname);
    }

  function _glbindbuffer(target, buffer) {
      var bufferobj = buffer ? gl.buffers[buffer] : null;
  
  
      glctx.bindbuffer(target, bufferobj);
    }

  function _pthread_mutexattr_destroy() {}

  function ___syscall91(which, varargs) {syscalls.varargs = varargs;
  try {
   // munmap
      var addr = syscalls.get(), len = syscalls.get();
      // todo: support unmmap'ing parts of allocations
      var info = syscalls.mappings[addr];
      if (!info) return 0;
      if (len === info.len) {
        var stream = fs.getstream(info.fd);
        syscalls.domsync(addr, stream, len, info.flags)
        fs.munmap(stream);
        syscalls.mappings[addr] = null;
        if (info.allocated) {
          _free(info.malloc);
        }
      }
      return 0;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _pthread_cond_timedwait() { return 0; }

  function _emscripten_glattachshader(program, shader) {
      glctx.attachshader(gl.programs[program],
                              gl.shaders[shader]);
    }

  function _glgetprogrambinary(program, bufsize, length, binaryformat, binary) {
      gl.recorderror(0x0502/*gl_invalid_operation*/);
    }

  function _glbufferdata(target, size, data, usage) {
      switch (usage) { // fix usages, webgl only has *_draw
        case 0x88e1: // gl_stream_read
        case 0x88e2: // gl_stream_copy
          usage = 0x88e0; // gl_stream_draw
          break;
        case 0x88e5: // gl_static_read
        case 0x88e6: // gl_static_copy
          usage = 0x88e4; // gl_static_draw
          break;
        case 0x88e9: // gl_dynamic_read
        case 0x88ea: // gl_dynamic_copy
          usage = 0x88e8; // gl_dynamic_draw
          break;
      }
      if (!data) {
        glctx.bufferdata(target, size, usage);
      } else {
        glctx.bufferdata(target, heapu8.subarray(data, data+size), usage);
      }
    }

  function _js_systeminfo_getcurrentcanvaswidth() 
  	{
  		return module['canvas'].clientwidth;
  	}


  function _glgeterror() {
      // first return any gl error generated by the emscripten library_gl.js interop layer.
      if (gl.lasterror) {
        var error = gl.lasterror;
        gl.lasterror = 0/*gl_no_error*/;
        return error;
      } else { // if there were none, return the gl error from the browser gl context.
        return glctx.geterror();
      }
    }

  function _emscripten_gldrawbuffers(n, bufs) {
      var bufarray = [];
      for (var i = 0; i < n; i++)
        bufarray.push(heap32[(((bufs)+(i*4))>>2)]);
  
      glctx['drawbuffers'](bufarray);
    }

   
  module["_pthread_mutex_unlock"] = _pthread_mutex_unlock;

  function _emscripten_glbindframebuffer(target, framebuffer) {
      glctx.bindframebuffer(target, framebuffer ? gl.framebuffers[framebuffer] : null);
    }

  function _emscripten_glbuffersubdata(target, offset, size, data) {
      glctx.buffersubdata(target, offset, heapu8.subarray(data, data+size));
    }

  function _js_cursor_setshow(show) {
      module.canvas.style.cursor = show ? "default" : "none";
    }

  function _emscripten_set_keydown_callback(target, userdata, usecapture, callbackfunc) {
      jsevents.registerkeyeventcallback(target, userdata, usecapture, callbackfunc, 2, "keydown");
      return 0;
    }

   
  module["_sbrk"] = _sbrk;

  function _glgetintegerv(name_, p) {
      emscriptenwebglget(name_, p, 'integer');
    }

  function ___syscall85(which, varargs) {syscalls.varargs = varargs;
  try {
   // readlink
      var path = syscalls.getstr(), buf = syscalls.get(), bufsize = syscalls.get();
      return syscalls.doreadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _glrenderbufferstoragemultisample(x0, x1, x2, x3, x4) { glctx['renderbufferstoragemultisample'](x0, x1, x2, x3, x4) }

  function _difftime(time1, time0) {
      return time1 - time0;
    }

  function _glteximage2d(target, level, internalformat, width, height, border, format, type, pixels) {
      var pixeldata = null;
      if (pixels) pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, internalformat);
      glctx.teximage2d(target, level, internalformat, width, height, border, format, type, pixeldata);
    }

  function _glstencilmask(x0) { glctx['stencilmask'](x0) }

  function _pthread_mutexattr_settype() {}

  function _gluniform1fv(location, count, value) {
      location = gl.uniforms[location];
      var view;
      if (count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[count-1];
        for (var i = 0; i < count; ++i) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*4)>>2);
      }
      glctx.uniform1fv(location, view);
    }

  function _glgetshadersource(shader, bufsize, length, source) {
      var result = glctx.getshadersource(gl.shaders[shader]);
      if (!result) return; // if an error occurs, nothing will be written to length or source.
      if (bufsize > 0 && source) {
        var numbyteswrittenexclnull = stringtoutf8(result, source, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
    }

  function _js_cursor_setimage(ptr, length) {
      var binary = "";
      for (var i = 0; i < length; i++)
        binary += string.fromcharcode(heapu8[ptr + i]);
      module.canvas.style.cursor = "url(data:image/cur;base64," + btoa(binary) + "),default";
    }

  function ___unlock() {}

  function _js_systeminfo_getgpuinfo(buffer, buffersize)
  	{
  		var gpuinfo = unityloader.systeminfo.gpu;
  		if (buffer)
  			stringtoutf8(gpuinfo, buffer, buffersize);
  		return lengthbytesutf8(gpuinfo);
  	}

  function _js_webrequest_release(request)
  	{
  		var http = wr.requestinstances[request];
  
  		http.onload = null;
  		http.onerror = null;
  		http.ontimeout = null;
  		http.onabort = null;
  		delete http;
  
  		wr.requestinstances[request] = null;
  	}

  function _setenv(envname, envval, overwrite) {
      // int setenv(const char *envname, const char *envval, int overwrite);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/setenv.html
      if (envname === 0) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      var name = pointer_stringify(envname);
      var val = pointer_stringify(envval);
      if (name === '' || name.indexof('=') !== -1) {
        ___seterrno(errno_codes.einval);
        return -1;
      }
      if (env.hasownproperty(name) && !overwrite) return 0;
      env[name] = val;
      ___buildenvironment(env);
      return 0;
    }

  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }

  function _emscripten_glgetprogramiv(program, pname, p) {
      if (!p) {
        // gles2 specification does not specify how to behave if p is a null pointer. since calling this function does not make sense
        // if p == null, issue a gl error to notify user about it. 
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
  
      if (program >= gl.counter) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        return;
      }
  
      var ptable = gl.programinfos[program];
      if (!ptable) {
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        return;
      }
  
      if (pname == 0x8b84) { // gl_info_log_length
        var log = glctx.getprograminfolog(gl.programs[program]);
        if (log === null) log = '(unknown error)';
        heap32[((p)>>2)]=log.length + 1;
      } else if (pname == 0x8b87 /* gl_active_uniform_max_length */) {
        heap32[((p)>>2)]=ptable.maxuniformlength;
      } else if (pname == 0x8b8a /* gl_active_attribute_max_length */) {
        if (ptable.maxattributelength == -1) {
          var program = gl.programs[program];
          var numattribs = glctx.getprogramparameter(program, glctx.active_attributes);
          ptable.maxattributelength = 0; // spec says if there are no active attribs, 0 must be returned.
          for (var i = 0; i < numattribs; ++i) {
            var activeattrib = glctx.getactiveattrib(program, i);
            ptable.maxattributelength = math.max(ptable.maxattributelength, activeattrib.name.length+1);
          }
        }
        heap32[((p)>>2)]=ptable.maxattributelength;
      } else if (pname == 0x8a35 /* gl_active_uniform_block_max_name_length */) {
        if (ptable.maxuniformblocknamelength == -1) {
          var program = gl.programs[program];
          var numblocks = glctx.getprogramparameter(program, glctx.active_uniform_blocks);
          ptable.maxuniformblocknamelength = 0;
          for (var i = 0; i < numblocks; ++i) {
            var activeblockname = glctx.getactiveuniformblockname(program, i);
            ptable.maxuniformblocknamelength = math.max(ptable.maxuniformblocknamelength, activeblockname.length+1);
          }
        }
        heap32[((p)>>2)]=ptable.maxuniformblocknamelength;
      } else {
        heap32[((p)>>2)]=glctx.getprogramparameter(gl.programs[program], pname);
      }
    }

  function _emscripten_glteximage2d(target, level, internalformat, width, height, border, format, type, pixels) {
      var pixeldata = null;
      if (pixels) pixeldata = emscriptenwebglgettexpixeldata(type, format, width, height, pixels, internalformat);
      glctx.teximage2d(target, level, internalformat, width, height, border, format, type, pixeldata);
    }

  function _emscripten_glgenvertexarrays(n, arrays) {
  
      for (var i = 0; i < n; i++) {
        var vao = glctx['createvertexarray']();
        if (!vao) {
          gl.recorderror(0x0502 /* gl_invalid_operation */);
          while(i < n) heap32[(((arrays)+(i++*4))>>2)]=0;
          return;
        }
        var id = gl.getnewid(gl.vaos);
        vao.name = id;
        gl.vaos[id] = vao;
        heap32[(((arrays)+(i*4))>>2)]=id;
      }
    }

  function _glflushmappedbufferrange(target, offset, length) {
      if (!emscriptenwebglvalidatemapbuffertarget(target)) {
        gl.recorderror(0x0500/*gl_invalid_enum*/);
        module.printerr('gl_invalid_enum in glflushmappedbufferrange');
        return 0;
      }
  
      var mapping = gl.mappedbuffers[emscriptenwebglgetbufferbinding(target)];
      if (!mapping) {
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        module.printerror('buffer was never mapped in glflushmappedbufferrange');
        return 0;
      }
  
      if (!(mapping.access & 0x10)) {
        gl.recorderror(0x0502 /* gl_invalid_operation */);
        module.printerror('buffer was not mapped with gl_map_flush_explicit_bit in glflushmappedbufferrange');
        return 0;
      }
      if (offset < 0 || length < 0 || offset + length > mapping.length) {
        gl.recorderror(0x0501 /* gl_invalid_value */);
        module.printerror('invalid range in glflushmappedbufferrange');
        return 0;
      }
  
      glctx.buffersubdata(
        target,
        mapping.offset,
        heapu8.subarray(mapping.mem + offset, mapping.mem + offset + length));
    }

  function _glcopybuffersubdata(x0, x1, x2, x3, x4) { glctx['copybuffersubdata'](x0, x1, x2, x3, x4) }

  function ___syscall183(which, varargs) {syscalls.varargs = varargs;
  try {
   // getcwd
      var buf = syscalls.get(), size = syscalls.get();
      if (size === 0) return -errno_codes.einval;
      var cwd = fs.cwd();
      if (size < cwd.length + 1) return -errno_codes.erange;
      writeasciitomemory(cwd, buf);
      return buf;
    } catch (e) {
    if (typeof fs === 'undefined' || !(e instanceof fs.errnoerror)) abort(e);
    return -e.errno;
  }
  }

  function _gldepthmask(flag) {
      glctx.depthmask(!!flag);
    }

  function _llvm_eh_typeid_for(type) {
      return type;
    }

  function _gluniformmatrix4fv(location, count, transpose, value) {
      location = gl.uniforms[location];
      var view;
      if (16*count <= gl.mini_temp_buffer_size) {
        // avoid allocation when uploading few enough uniforms
        view = gl.minitempbufferviews[16*count-1];
        for (var i = 0; i < 16*count; i += 16) {
          view[i] = heapf32[(((value)+(4*i))>>2)];
          view[i+1] = heapf32[(((value)+(4*i+4))>>2)];
          view[i+2] = heapf32[(((value)+(4*i+8))>>2)];
          view[i+3] = heapf32[(((value)+(4*i+12))>>2)];
          view[i+4] = heapf32[(((value)+(4*i+16))>>2)];
          view[i+5] = heapf32[(((value)+(4*i+20))>>2)];
          view[i+6] = heapf32[(((value)+(4*i+24))>>2)];
          view[i+7] = heapf32[(((value)+(4*i+28))>>2)];
          view[i+8] = heapf32[(((value)+(4*i+32))>>2)];
          view[i+9] = heapf32[(((value)+(4*i+36))>>2)];
          view[i+10] = heapf32[(((value)+(4*i+40))>>2)];
          view[i+11] = heapf32[(((value)+(4*i+44))>>2)];
          view[i+12] = heapf32[(((value)+(4*i+48))>>2)];
          view[i+13] = heapf32[(((value)+(4*i+52))>>2)];
          view[i+14] = heapf32[(((value)+(4*i+56))>>2)];
          view[i+15] = heapf32[(((value)+(4*i+60))>>2)];
        }
      } else {
        view = heapf32.subarray((value)>>2,(value+count*64)>>2);
      }
      glctx.uniformmatrix4fv(location, !!transpose, view);
    }

  function _emscripten_glclientactivetexture() {
  module['printerr']('missing function: emscripten_glclientactivetexture'); abort(-1);
  }

  function _glgetactiveuniform(program, index, bufsize, length, size, type, name) {
      program = gl.programs[program];
      var info = glctx.getactiveuniform(program, index);
      if (!info) return; // if an error occurs, nothing will be written to length, size, type and name.
  
      if (bufsize > 0 && name) {
        var numbyteswrittenexclnull = stringtoutf8(info.name, name, bufsize);
        if (length) heap32[((length)>>2)]=numbyteswrittenexclnull;
      } else {
        if (length) heap32[((length)>>2)]=0;
      }
  
      if (size) heap32[((size)>>2)]=info.size;
      if (type) heap32[((type)>>2)]=info.type;
    }

  function _emscripten_glvalidateprogram(program) {
      glctx.validateprogram(gl.programs[program]);
    }

  function _emscripten_get_main_loop_timing(mode, value) {
      if (mode) heap32[((mode)>>2)]=browser.mainloop.timingmode;
      if (value) heap32[((value)>>2)]=browser.mainloop.timingvalue;
    }

  function _js_webrequest_settimeout(request, timeout)
  	{
  		wr.requestinstances[request].timeout = timeout;
  	}

  function _glfrontface(x0) { glctx['frontface'](x0) }

  function _emscripten_webgl_get_current_context() {
      return gl.currentcontext ? gl.currentcontext.handle : 0;
    }

  function _emscripten_glpixelstorei(pname, param) {
      if (pname == 0x0d05 /* gl_pack_alignment */) {
        gl.packalignment = param;
      } else if (pname == 0x0cf5 /* gl_unpack_alignment */) {
        gl.unpackalignment = param;
      }
      glctx.pixelstorei(pname, param);
    }

  function _emscripten_gldeletetextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = heap32[(((textures)+(i*4))>>2)];
        var texture = gl.textures[id];
        if (!texture) continue; // gl spec: "gldeletetextures silently ignores 0s and names that do not correspond to existing textures".
        glctx.deletetexture(texture);
        texture.name = 0;
        gl.textures[id] = null;
      }
    }

  function _glgetstring(name_) {
      if (gl.stringcache[name_]) return gl.stringcache[name_];
      var ret; 
      switch(name_) {
        case 0x1f00 /* gl_vendor */:
        case 0x1f01 /* gl_renderer */:
        case 0x9245 /* unmasked_vendor_webgl */:
        case 0x9246 /* unmasked_renderer_webgl */:
          ret = allocate(intarrayfromstring(glctx.getparameter(name_)), 'i8', alloc_normal);
          break;
        case 0x1f02 /* gl_version */:
          var glversion = glctx.getparameter(glctx.version);
          // return gles version string corresponding to the version of the webgl context
          if (glctx.canvas.glctxobject.version >= 2) glversion = 'opengl es 3.0 (' + glversion + ')';
          else
          {
            glversion = 'opengl es 2.0 (' + glversion + ')';
          }
          ret = allocate(intarrayfromstring(glversion), 'i8', alloc_normal);
          break;
        case 0x1f03 /* gl_extensions */:
          var exts = glctx.getsupportedextensions();
          var gl_exts = [];
          for (var i = 0; i < exts.length; ++i) {
            gl_exts.push(exts[i]);
            gl_exts.push("gl_" + exts[i]);
          }
          ret = allocate(intarrayfromstring(gl_exts.join(' ')), 'i8', alloc_normal);
          break;
        case 0x8b8c /* gl_shading_language_version */:
          var glslversion = glctx.getparameter(glctx.shading_language_version);
          // extract the version number 'n.m' from the string 'webgl glsl es n.m ...'
          var ver_re = /^webgl glsl es ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
          var ver_num = glslversion.match(ver_re);
          if (ver_num !== null) {
            if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
            glslversion = 'opengl es glsl es ' + ver_num[1] + ' (' + glslversion + ')';
          }
          ret = allocate(intarrayfromstring(glslversion), 'i8', alloc_normal);
          break;
        default:
          gl.recorderror(0x0500/*gl_invalid_enum*/);
          return 0;
      }
      gl.stringcache[name_] = ret;
      return ret;
    }

  var _llvm_nacl_atomic_cmpxchg_i32=undefined;

   
  module["_llvm_bswap_i16"] = _llvm_bswap_i16;

  function _time(ptr) {
      var ret = (date.now()/1000)|0;
      if (ptr) {
        heap32[((ptr)>>2)]=ret;
      }
      return ret;
    }

   
  module["_pthread_self"] = _pthread_self;

  function _emscripten_glgetbooleanv(name_, p) {
      emscriptenwebglget(name_, p, 'boolean');
    }

  function _emscripten_glcompileshader(shader) {
      glctx.compileshader(gl.shaders[shader]);
    }
var glctx; gl.init();
fs.staticinit();__atinit__.unshift(function() { if (!module["nofsinit"] && !fs.init.initialized) fs.init() });__atmain__.push(function() { fs.ignorepermissions = false });__atexit__.push(function() { fs.quit() });module["fs_createfolder"] = fs.createfolder;module["fs_createpath"] = fs.createpath;module["fs_createdatafile"] = fs.createdatafile;module["fs_createpreloadedfile"] = fs.createpreloadedfile;module["fs_createlazyfile"] = fs.createlazyfile;module["fs_createlink"] = fs.createlink;module["fs_createdevice"] = fs.createdevice;module["fs_unlink"] = fs.unlink;;
__atinit__.unshift(function() { tty.init() });__atexit__.push(function() { tty.shutdown() });;
if (environment_is_node) { var fs = require("fs"); var nodejs_path = require("path"); nodefs.staticinit(); };
___buildenvironment(env);;
if (environment_is_node) {
    _emscripten_get_now = function _emscripten_get_now_actual() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (typeof datenow !== 'undefined') {
    _emscripten_get_now = datenow;
  } else if (typeof self === 'object' && self['performance'] && typeof self['performance']['now'] === 'function') {
    _emscripten_get_now = function() { return self['performance']['now'](); };
  } else if (typeof performance === 'object' && typeof performance['now'] === 'function') {
    _emscripten_get_now = function() { return performance['now'](); };
  } else {
    _emscripten_get_now = date.now;
  };
module["requestfullscreen"] = function module_requestfullscreen(lockpointer, resizecanvas, vrdevice) { module.printerr("module.requestfullscreen is deprecated. please call module.requestfullscreen instead."); module["requestfullscreen"] = module["requestfullscreen"]; browser.requestfullscreen(lockpointer, resizecanvas, vrdevice) };
  module["requestfullscreen"] = function module_requestfullscreen(lockpointer, resizecanvas, vrdevice) { browser.requestfullscreen(lockpointer, resizecanvas, vrdevice) };
  module["requestanimationframe"] = function module_requestanimationframe(func) { browser.requestanimationframe(func) };
  module["setcanvassize"] = function module_setcanvassize(width, height, noupdates) { browser.setcanvassize(width, height, noupdates) };
  module["pausemainloop"] = function module_pausemainloop() { browser.mainloop.pause() };
  module["resumemainloop"] = function module_resumemainloop() { browser.mainloop.resume() };
  module["getusermedia"] = function module_getusermedia() { browser.getusermedia() }
  module["createcontext"] = function module_createcontext(canvas, usewebgl, setinmodule, webglcontextattributes) { return browser.createcontext(canvas, usewebgl, setinmodule, webglcontextattributes) };
dynamictop_ptr = allocate(1, "i32", alloc_static);

stack_base = stacktop = runtime.alignmemory(statictop);

stack_max = stack_base + total_stack;

dynamic_base = runtime.alignmemory(stack_max);

heap32[dynamictop_ptr>>2] = dynamic_base;

staticsealed = true; // seal the static portion of memory



module['wasmtablesize'] = 46177;

module['wasmmaxtablesize'] = 46177;

function invoke_diji(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_diji"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_diddi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_diddi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viij(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viij"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiff(index,a1,a2,a3) {
  try {
    return module["dyncall_fiff"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fifi(index,a1,a2,a3) {
  try {
    return module["dyncall_fifi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijjiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    module["dyncall_vijjiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vidi(index,a1,a2,a3) {
  try {
    module["dyncall_vidi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiiiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20) {
  try {
    module["dyncall_vifiiiiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    module["dyncall_viiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fff(index,a1,a2) {
  try {
    return module["dyncall_fff"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iidi(index,a1,a2,a3) {
  try {
    return module["dyncall_iidi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiji(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_jiji"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiiiiifiiiiiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) {
  try {
    return module["dyncall_fiiiiiifiiiiiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifiif(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiiiifiif"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiiiifii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiffi(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viiiiiffi"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viifiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viiijiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiiiifiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiffi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiffi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jii(index,a1,a2) {
  try {
    return module["dyncall_jii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    return module["dyncall_iiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fif(index,a1,a2) {
  try {
    return module["dyncall_fif"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) {
  try {
    module["dyncall_viiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiif(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiiiif"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fii(index,a1,a2) {
  try {
    return module["dyncall_fii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viiiiifii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_di(index,a1) {
  try {
    return module["dyncall_di"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viff(index,a1,a2,a3) {
  try {
    module["dyncall_viff"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiifiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viffff(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viffff"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jijji(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_jijji"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_vijiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiji(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viiji"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiijiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    module["dyncall_viiiiijiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiijjii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiijjii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiffiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viiffiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_dii(index,a1,a2) {
  try {
    return module["dyncall_dii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iifii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iifii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_didi(index,a1,a2,a3) {
  try {
    return module["dyncall_didi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifiifi(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiifiifi"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iidii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iidii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiij(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiiij"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiiiffffii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17) {
  try {
    return module["dyncall_iiiiiiiiiiiiffffii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vdd(index,a1,a2) {
  try {
    module["dyncall_vdd"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiifii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_fiiifii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiffii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    module["dyncall_viiiiiiffii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viffii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viffii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiififii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    module["dyncall_viiiififii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vffff(index,a1,a2,a3,a4) {
  try {
    module["dyncall_vffff"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iijjii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iijjii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vdddddd(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_vdddddd"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) {
  try {
    module["dyncall_vifiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiji(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiiji"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30,a31,a32,a33,a34) {
  try {
    module["dyncall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30,a31,a32,a33,a34);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiif(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiiiiiif"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viidi(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viidi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiffii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiffii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_ijj(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_ijj"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifiiiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    return module["dyncall_iiiiifiiiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiffi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_fiffi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiifii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17) {
  try {
    module["dyncall_viiiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiijiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_jiijiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) {
  try {
    return module["dyncall_iiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jijjji(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_jijjji"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30) {
  try {
    module["dyncall_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25,a26,a27,a28,a29,a30);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viffi(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viffi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiiifiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifi(index,a1,a2,a3) {
  try {
    module["dyncall_vifi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijj(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viijj"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifff(index,a1,a2,a3,a4) {
  try {
    module["dyncall_vifff"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viififiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viififiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) {
  try {
    module["dyncall_viiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiii(index,a1,a2,a3) {
  try {
    return module["dyncall_fiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiifffiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) {
  try {
    return module["dyncall_iiiiiifffiiifii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iifff(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iifff"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iifiii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iifiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiijii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiijii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiidiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiidiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jidi(index,a1,a2,a3) {
  try {
    return module["dyncall_jidi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifiifii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiifiifii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_ji(index,a1) {
  try {
    return module["dyncall_ji"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiddi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiddi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    module["dyncall_viiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiffiiiiiiiiiffffiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23) {
  try {
    return module["dyncall_iiiiiiffiiiiiiiiiffffiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_diii(index,a1,a2,a3) {
  try {
    return module["dyncall_diii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiji(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiiji"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vff(index,a1,a2) {
  try {
    module["dyncall_vff"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijijiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    module["dyncall_viijijiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijijji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    module["dyncall_viijijji"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_fiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiifii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viiiifii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_vijii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiffi(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiiiffi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jidji(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_jidji"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viidii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viidii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vjji(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_vjji"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiifiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiiiiifiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jijii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_jijii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viifii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iifffi(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iifffi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vif(index,a1,a2) {
  try {
    module["dyncall_vif"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vid(index,a1,a2) {
  try {
    module["dyncall_vid"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiidi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiidi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vij(index,a1,a2,a3) {
  try {
    module["dyncall_vij"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    module["dyncall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijji(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_vijji"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiif(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viiiif"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_difi(index,a1,a2,a3) {
  try {
    return module["dyncall_difi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fi(index,a1) {
  try {
    return module["dyncall_fi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiififiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiififiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiji(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_fiji"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_jiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijj(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_vijj"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vf(index,a1) {
  try {
    module["dyncall_vf"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiffiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22) {
  try {
    return module["dyncall_iiiiiiffiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiiiiiiifiiiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) {
  try {
    return module["dyncall_fiiiiiiiifiiiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifiifiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiifiifiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viffffii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viffffii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiii(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_vifiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijjii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viijjii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iijjji(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iijjji"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_diiii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_diiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiifiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) {
  try {
    module["dyncall_viiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiffffii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) {
  try {
    return module["dyncall_iiiiiiiiiiffffii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifi(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiiiifi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fifii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_fifii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viji(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viji"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiffifffi(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_fiffifffi"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiff(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viiff"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iif(index,a1,a2) {
  try {
    return module["dyncall_iif"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_vifiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijiji(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_vijiji"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifii(index,a1,a2,a3,a4) {
  try {
    module["dyncall_vifii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    module["dyncall_viiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiif(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viiiiiif"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijji(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    module["dyncall_viijji"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return module["dyncall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viifiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iij(index,a1,a2,a3) {
  try {
    return module["dyncall_iij"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiijiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    module["dyncall_viiijiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiiifii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_f(index) {
  try {
    return module["dyncall_f"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiiii(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_jiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viijii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiifiiiiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    module["dyncall_viiiifiiiiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viififi(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viififi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  try {
    module["dyncall_viii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiifi(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiiifi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiii(index,a1,a2,a3) {
  try {
    return module["dyncall_jiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiji(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiji"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viif(index,a1,a2,a3) {
  try {
    module["dyncall_viif"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_vijiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiifi(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_fiiifi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifi(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiiifi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    module["dyncall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vd(index,a1) {
  try {
    module["dyncall_vd"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifi(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viifi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiifi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_fiifi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    module["dyncall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    return module["dyncall_iiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiffiiiiiiiiiffffiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25) {
  try {
    return module["dyncall_iiiiiiiffiiiiiiiiiffffiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiififii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    module["dyncall_viiififii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return module["dyncall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifffi(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_vifffi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iijji(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iijji"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    return module["dyncall_iiiiifiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiifiiiiif(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {
  try {
    return module["dyncall_iiiiifiiiiif"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jifi(index,a1,a2,a3) {
  try {
    return module["dyncall_jifi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) {
  try {
    module["dyncall_viiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iifi(index,a1,a2,a3) {
  try {
    return module["dyncall_iifi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiif(index,a1,a2,a3,a4) {
  try {
    module["dyncall_viiif"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fifffi(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_fifffi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_jiiiii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_jiiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifiiiiiiiiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25) {
  try {
    module["dyncall_vifiiiiiiiiiiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24,a25);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiffii(index,a1,a2,a3,a4,a5,a6) {
  try {
    return module["dyncall_iiiffii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vijiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    module["dyncall_vijiijiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiifi(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiifi"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  try {
    return module["dyncall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fidi(index,a1,a2,a3) {
  try {
    return module["dyncall_fidi"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiij(index,a1,a2,a3,a4) {
  try {
    return module["dyncall_iiij"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifff(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viifff"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiffi(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viiffi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiid(index,a1,a2,a3) {
  try {
    return module["dyncall_iiid"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifiifiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    return module["dyncall_iiiifiifiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiif(index,a1,a2,a3) {
  try {
    return module["dyncall_iiif"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiiffi(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viiiffi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_diiiii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_diiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiifi(index,a1,a2,a3,a4,a5) {
  try {
    module["dyncall_viiifi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_fiiffi(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_fiiffi"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiffiiiiiiiiiffffiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24) {
  try {
    return module["dyncall_iiiiiiffiiiiiiiiiffffiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20,a21,a22,a23,a24);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) {
  try {
    return module["dyncall_iiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viifffi(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viifffi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vifffii(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_vifffii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    return module["dyncall_iiiifiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_ff(index,a1) {
  try {
    return module["dyncall_ff"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiifiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiiifiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iijii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iijii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) {
  try {
    return module["dyncall_iiiiiiiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiijjii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    module["dyncall_viiijjii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_vfi(index,a1,a2) {
  try {
    module["dyncall_vfi"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_i(index) {
  try {
    return module["dyncall_i"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiidii(index,a1,a2,a3,a4,a5) {
  try {
    return module["dyncall_iiidii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiidiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiidiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viiifiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    module["dyncall_viiifiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiijjiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {
  try {
    return module["dyncall_iiijjiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiijii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    return module["dyncall_iiiiiijii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viijjji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  try {
    module["dyncall_viijjji"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  try {
    return module["dyncall_iiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

function invoke_viffffi(index,a1,a2,a3,a4,a5,a6) {
  try {
    module["dyncall_viffffi"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setthrew"](1, 0);
  }
}

module.asmglobalarg = { "math": math, "int8array": int8array, "int16array": int16array, "int32array": int32array, "uint8array": uint8array, "uint16array": uint16array, "uint32array": uint32array, "float32array": float32array, "float64array": float64array, "nan": nan, "infinity": infinity };

module.asmlibraryarg = { "abort": abort, "assert": assert, "enlargememory": enlargememory, "gettotalmemory": gettotalmemory, "abortoncannotgrowmemory": abortoncannotgrowmemory, "invoke_diji": invoke_diji, "invoke_diddi": invoke_diddi, "invoke_viij": invoke_viij, "invoke_fiff": invoke_fiff, "invoke_fifi": invoke_fifi, "invoke_vijjiiiiii": invoke_vijjiiiiii, "invoke_iiiiiii": invoke_iiiiiii, "invoke_vidi": invoke_vidi, "invoke_vifiiiiiiiiiiiiiiiiii": invoke_vifiiiiiiiiiiiiiiiiii, "invoke_viiiiiiiiiii": invoke_viiiiiiiiiii, "invoke_fff": invoke_fff, "invoke_iidi": invoke_iidi, "invoke_jiji": invoke_jiji, "invoke_fiiiiiifiiiiiif": invoke_fiiiiiifiiiiiif, "invoke_iiiiifiif": invoke_iiiiifiif, "invoke_iiiiifii": invoke_iiiiifii, "invoke_viiiiiffi": invoke_viiiiiffi, "invoke_viifiiii": invoke_viifiiii, "invoke_viiijiii": invoke_viiijiii, "invoke_iiiiifiii": invoke_iiiiifiii, "invoke_iiffi": invoke_iiffi, "invoke_jii": invoke_jii, "invoke_iiiiiiiiiiii": invoke_iiiiiiiiiiii, "invoke_fif": invoke_fif, "invoke_viiiiiiiiiiiiiii": invoke_viiiiiiiiiiiiiii, "invoke_viiiiif": invoke_viiiiif, "invoke_fii": invoke_fii, "invoke_viiiiifii": invoke_viiiiifii, "invoke_di": invoke_di, "invoke_viff": invoke_viff, "invoke_iiifiii": invoke_iiifiii, "invoke_viffff": invoke_viffff, "invoke_jijji": invoke_jijji, "invoke_vijiiii": invoke_vijiiii, "invoke_viiji": invoke_viiji, "invoke_viiiiijiiii": invoke_viiiiijiiii, "invoke_iiijjii": invoke_iiijjii, "invoke_viiffiii": invoke_viiffiii, "invoke_dii": invoke_dii, "invoke_iifii": invoke_iifii, "invoke_didi": invoke_didi, "invoke_iiifiifi": invoke_iiifiifi, "invoke_iiiii": invoke_iiiii, "invoke_iidii": invoke_iidii, "invoke_iiiij": invoke_iiiij, "invoke_iiiiiiiiiiiiffffii": invoke_iiiiiiiiiiiiffffii, "invoke_vdd": invoke_vdd, "invoke_fiiifii": invoke_fiiifii, "invoke_viiiiiiffii": invoke_viiiiiiffii, "invoke_viffii": invoke_viffii, "invoke_iiiiiiii": invoke_iiiiiiii, "invoke_viiiififii": invoke_viiiififii, "invoke_vffff": invoke_vffff, "invoke_iijjii": invoke_iijjii, "invoke_vdddddd": invoke_vdddddd, "invoke_vifiiiiiiiiiiiii": invoke_vifiiiiiiiiiiiii, "invoke_iiiji": invoke_iiiji, "invoke_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii": invoke_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii, "invoke_iiiiiiif": invoke_iiiiiiif, "invoke_viidi": invoke_viidi, "invoke_viiffii": invoke_viiffii, "invoke_ijj": invoke_ijj, "invoke_iiiiiiiiii": invoke_iiiiiiiiii, "invoke_iiiiifiiiif": invoke_iiiiifiiiif, "invoke_fiffi": invoke_fiffi, "invoke_iiifii": invoke_iiifii, "invoke_viiiiiiiiiiiiiiiii": invoke_viiiiiiiiiiiiiiiii, "invoke_jiijiii": invoke_jiijiii, "invoke_iiiiiiiiiiiiii": invoke_iiiiiiiiiiiiii, "invoke_jijjji": invoke_jijjji, "invoke_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii": invoke_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii, "invoke_viffi": invoke_viffi, "invoke_iiiifiiii": invoke_iiiifiiii, "invoke_vifi": invoke_vifi, "invoke_viijj": invoke_viijj, "invoke_vifff": invoke_vifff, "invoke_viiiiii": invoke_viiiiii, "invoke_viififiii": invoke_viififiii, "invoke_viiiiiiiiiiiiii": invoke_viiiiiiiiiiiiii, "invoke_fiii": invoke_fiii, "invoke_iiiiiifffiiifii": invoke_iiiiiifffiiifii, "invoke_iifff": invoke_iifff, "invoke_iifiii": invoke_iifiii, "invoke_iiijii": invoke_iiijii, "invoke_iiidiiii": invoke_iiidiiii, "invoke_jidi": invoke_jidi, "invoke_iiifiifii": invoke_iiifiifii, "invoke_ji": invoke_ji, "invoke_iiddi": invoke_iiddi, "invoke_viiiiiiiiii": invoke_viiiiiiiiii, "invoke_iiiiiiffiiiiiiiiiffffiii": invoke_iiiiiiffiiiiiiiiiffffiii, "invoke_diii": invoke_diii, "invoke_viiiji": invoke_viiiji, "invoke_vff": invoke_vff, "invoke_viijijiii": invoke_viijijiii, "invoke_viijijji": invoke_viijijji, "invoke_fiiii": invoke_fiiii, "invoke_iiiiii": invoke_iiiiii, "invoke_viiiifii": invoke_viiiifii, "invoke_vijii": invoke_vijii, "invoke_iiiiffi": invoke_iiiiffi, "invoke_jidji": invoke_jidji, "invoke_viidii": invoke_viidii, "invoke_vjji": invoke_vjji, "invoke_iiiiiifiif": invoke_iiiiiifiif, "invoke_viiii": invoke_viiii, "invoke_jijii": invoke_jijii, "invoke_viiiii": invoke_viiiii, "invoke_viifii": invoke_viifii, "invoke_iifffi": invoke_iifffi, "invoke_vif": invoke_vif, "invoke_vid": invoke_vid, "invoke_iiidi": invoke_iiidi, "invoke_vij": invoke_vij, "invoke_vii": invoke_vii, "invoke_vijji": invoke_vijji, "invoke_viiiif": invoke_viiiif, "invoke_difi": invoke_difi, "invoke_fi": invoke_fi, "invoke_iiififiiii": invoke_iiififiiii, "invoke_fiji": invoke_fiji, "invoke_jiiiiiii": invoke_jiiiiiii, "invoke_vijj": invoke_vijj, "invoke_vf": invoke_vf, "invoke_iiiiiiffiiiiiiiiiiiiiii": invoke_iiiiiiffiiiiiiiiiiiiiii, "invoke_fiiiiiiiifiiiif": invoke_fiiiiiiiifiiiif, "invoke_iiifiifiii": invoke_iiifiifiii, "invoke_viffffii": invoke_viffffii, "invoke_vifiii": invoke_vifiii, "invoke_viijjii": invoke_viijjii, "invoke_iijjji": invoke_iijjji, "invoke_diiii": invoke_diiii, "invoke_iiifiiii": invoke_iiifiiii, "invoke_viiiiiiiiiiiii": invoke_viiiiiiiiiiiii, "invoke_iiiiiiiiiiffffii": invoke_iiiiiiiiiiffffii, "invoke_iiiiifi": invoke_iiiiifi, "invoke_fifii": invoke_fifii, "invoke_viji": invoke_viji, "invoke_viiiiiiii": invoke_viiiiiiii, "invoke_fiffifffi": invoke_fiffifffi, "invoke_viiff": invoke_viiff, "invoke_iif": invoke_iif, "invoke_vifiiii": invoke_vifiiii, "invoke_viiiiiii": invoke_viiiiiii, "invoke_vijiji": invoke_vijiji, "invoke_vifii": invoke_vifii, "invoke_viiiiiiiii": invoke_viiiiiiiii, "invoke_viiiiiif": invoke_viiiiiif, "invoke_viijji": invoke_viijji, "invoke_iii": invoke_iii, "invoke_viifiii": invoke_viifiii, "invoke_iij": invoke_iij, "invoke_viiijiiiiii": invoke_viiijiiiiii, "invoke_iiiifii": invoke_iiiifii, "invoke_f": invoke_f, "invoke_jiiii": invoke_jiiii, "invoke_viijii": invoke_viijii, "invoke_viiiifiiiiif": invoke_viiiifiiiiif, "invoke_viififi": invoke_viififi, "invoke_viii": invoke_viii, "invoke_viiiifi": invoke_viiiifi, "invoke_jiii": invoke_jiii, "invoke_iiji": invoke_iiji, "invoke_viif": invoke_viif, "invoke_vijiii": invoke_vijiii, "invoke_fiiifi": invoke_fiiifi, "invoke_iiiifi": invoke_iiiifi, "invoke_v": invoke_v, "invoke_vd": invoke_vd, "invoke_viifi": invoke_viifi, "invoke_fiifi": invoke_fiifi, "invoke_vi": invoke_vi, "invoke_iiiiiiiiiii": invoke_iiiiiiiiiii, "invoke_iiiiiiiffiiiiiiiiiffffiiii": invoke_iiiiiiiffiiiiiiiiiffffiiii, "invoke_viiififii": invoke_viiififii, "invoke_ii": invoke_ii, "invoke_vifffi": invoke_vifffi, "invoke_iijji": invoke_iijji, "invoke_iiiiifiiiiii": invoke_iiiiifiiiiii, "invoke_iiiiifiiiiif": invoke_iiiiifiiiiif, "invoke_jifi": invoke_jifi, "invoke_viiiiiiiiiiii": invoke_viiiiiiiiiiii, "invoke_iifi": invoke_iifi, "invoke_viiif": invoke_viiif, "invoke_fifffi": invoke_fifffi, "invoke_jiiiii": invoke_jiiiii, "invoke_vifiiiiiiiiiiiiiiiiiiiiiii": invoke_vifiiiiiiiiiiiiiiiiiiiiiii, "invoke_iiiffii": invoke_iiiffii, "invoke_vijiijiii": invoke_vijiijiii, "invoke_iiifi": invoke_iiifi, "invoke_iiii": invoke_iiii, "invoke_fidi": invoke_fidi, "invoke_iiij": invoke_iiij, "invoke_viifff": invoke_viifff, "invoke_viiffi": invoke_viiffi, "invoke_iiid": invoke_iiid, "invoke_iiiifiifiii": invoke_iiiifiifiii, "invoke_iiif": invoke_iiif, "invoke_viiiffi": invoke_viiiffi, "invoke_diiiii": invoke_diiiii, "invoke_viiifi": invoke_viiifi, "invoke_fiiffi": invoke_fiiffi, "invoke_iiiiiiffiiiiiiiiiffffiiii": invoke_iiiiiiffiiiiiiiiiffffiiii, "invoke_iiiiiiiiiiiii": invoke_iiiiiiiiiiiii, "invoke_viifffi": invoke_viifffi, "invoke_vifffii": invoke_vifffii, "invoke_iiiifiii": invoke_iiiifiii, "invoke_ff": invoke_ff, "invoke_iiiifiiiii": invoke_iiiifiiiii, "invoke_iijii": invoke_iijii, "invoke_iiiiiiiiiiiiiii": invoke_iiiiiiiiiiiiiii, "invoke_viiijjii": invoke_viiijjii, "invoke_vfi": invoke_vfi, "invoke_i": invoke_i, "invoke_iiidii": invoke_iiidii, "invoke_iiidiiiii": invoke_iiidiiiii, "invoke_viiifiiiii": invoke_viiifiiiii, "invoke_iiijjiiii": invoke_iiijjiiii, "invoke_iiiiiijii": invoke_iiiiiijii, "invoke_viijjji": invoke_viijjji, "invoke_iiiiiiiii": invoke_iiiiiiiii, "invoke_viffffi": invoke_viffffi, "_emscripten_glgettexparameterfv": _emscripten_glgettexparameterfv, "_glclearstencil": _glclearstencil, "___syscall220": ___syscall220, "_emscripten_glblendfuncseparate": _emscripten_glblendfuncseparate, "_gltexparameteriv": _gltexparameteriv, "_gluniformmatrix4fv": _gluniformmatrix4fv, "_glvertexattrib4f": _glvertexattrib4f, "_emscripten_gldepthfunc": _emscripten_gldepthfunc, "_emscripten_webgl_create_context": _emscripten_webgl_create_context, "_pthread_key_delete": _pthread_key_delete, "_gldisablevertexattribarray": _gldisablevertexattribarray, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_pthread_attr_init": _pthread_attr_init, "_emscripten_gluniform1f": _emscripten_gluniform1f, "emscriptenwebglcomputeimagesize": emscriptenwebglcomputeimagesize, "___syscall221": ___syscall221, "_glinvalidateframebuffer": _glinvalidateframebuffer, "_emscripten_glvertexattrib2f": _emscripten_glvertexattrib2f, "_emscripten_gluniform1i": _emscripten_gluniform1i, "_emscripten_glgetintegerv": _emscripten_glgetintegerv, "_emscripten_glisprogram": _emscripten_glisprogram, "_glgensamplers": _glgensamplers, "_emscripten_webgl_make_context_current": _emscripten_webgl_make_context_current, "_glendtransformfeedback": _glendtransformfeedback, "_glframebufferrenderbuffer": _glframebufferrenderbuffer, "_gmtime_r": _gmtime_r, "___cxa_rethrow": ___cxa_rethrow, "_emscripten_gltexparameteriv": _emscripten_gltexparameteriv, "___syscall140": ___syscall140, "___syscall145": ___syscall145, "___syscall146": ___syscall146, "_gluniform1uiv": _gluniform1uiv, "_emscripten_glattachshader": _emscripten_glattachshader, "_emscripten_get_now_is_monotonic": _emscripten_get_now_is_monotonic, "_pthread_cond_timedwait": _pthread_cond_timedwait, "_emscripten_gltexparameterfv": _emscripten_gltexparameterfv, "_pthread_attr_destroy": _pthread_attr_destroy, "_emscripten_gluniformmatrix2fv": _emscripten_gluniformmatrix2fv, "_sdl_getticks": _sdl_getticks, "_emscripten_gldrawarraysinstanced": _emscripten_gldrawarraysinstanced, "___syscall183": ___syscall183, "_gldepthmask": _gldepthmask, "_emscripten_glvertexattrib2fv": _emscripten_glvertexattrib2fv, "_glviewport": _glviewport, "_emscripten_glflush": _emscripten_glflush, "_glreadbuffer": _glreadbuffer, "___syscall91": ___syscall91, "_pthread_once": _pthread_once, "_gldrawarraysinstanced": _gldrawarraysinstanced, "_js_sound_setlistenerorientation": _js_sound_setlistenerorientation, "_emscripten_glgetattriblocation": _emscripten_glgetattriblocation, "_glbeginquery": _glbeginquery, "_glattachshader": _glattachshader, "_emscripten_gltexcoordpointer": _emscripten_gltexcoordpointer, "_emscripten_set_blur_callback": _emscripten_set_blur_callback, "_emscripten_glloadmatrixf": _emscripten_glloadmatrixf, "_emscripten_glstencilfuncseparate": _emscripten_glstencilfuncseparate, "_emscripten_glvertexattrib3f": _emscripten_glvertexattrib3f, "_emscripten_webgl_enable_extension": _emscripten_webgl_enable_extension, "_glcullface": _glcullface, "_emscripten_get_gamepad_status": _emscripten_get_gamepad_status, "_sched_yield": _sched_yield, "_glcompressedteximage2d": _glcompressedteximage2d, "_emscripten_gluniform1iv": _emscripten_gluniform1iv, "emscriptenwebglgetuniform": emscriptenwebglgetuniform, "_glclearcolor": _glclearcolor, "_glfinish": _glfinish, "_emscripten_gluniform3iv": _emscripten_gluniform3iv, "_emscripten_glgetbufferparameteriv": _emscripten_glgetbufferparameteriv, "_emscripten_glvertexattrib4fv": _emscripten_glvertexattrib4fv, "_glgettexparameteriv": _glgettexparameteriv, "_pthread_getspecific": _pthread_getspecific, "_gldrawarrays": _gldrawarrays, "_pthread_cond_signal": _pthread_cond_signal, "_emscripten_gldepthrange": _emscripten_gldepthrange, "_glactivetexture": _glactivetexture, "_emscripten_asm_const_iii": _emscripten_asm_const_iii, "_emscripten_glcopyteximage2d": _emscripten_glcopyteximage2d, "_emscripten_glframebuffertexture2d": _emscripten_glframebuffertexture2d, "_glenablevertexattribarray": _glenablevertexattribarray, "_emscripten_glstencilfunc": _emscripten_glstencilfunc, "_glbindvertexarray": _glbindvertexarray, "_glvertexattribipointer": _glvertexattribipointer, "_glvertexattrib4fv": _glvertexattrib4fv, "_gldeletebuffers": _gldeletebuffers, "_localtime": _localtime, "_glgetuniformblockindex": _glgetuniformblockindex, "_glgetactiveuniformblockname": _glgetactiveuniformblockname, "_glrenderbufferstoragemultisample": _glrenderbufferstoragemultisample, "_glcompressedtexsubimage2d": _glcompressedtexsubimage2d, "_emscripten_glrenderbufferstorage": _emscripten_glrenderbufferstorage, "_mix_playmusic": _mix_playmusic, "_emscripten_set_keydown_callback": _emscripten_set_keydown_callback, "_emscripten_glvertexpointer": _emscripten_glvertexpointer, "_js_systeminfo_getheight": _js_systeminfo_getheight, "_emscripten_glbuffersubdata": _emscripten_glbuffersubdata, "_emscripten_glgetuniformfv": _emscripten_glgetuniformfv, "_sdl_freerw": _sdl_freerw, "_glframebuffertexturelayer": _glframebuffertexturelayer, "_gldeletequeries": _gldeletequeries, "_mix_loadwav_rw": _mix_loadwav_rw, "_emscripten_glstencilop": _emscripten_glstencilop, "_emscripten_glblendequation": _emscripten_glblendequation, "_glteximage3d": _glteximage3d, "emscriptenwebglgetindexed": emscriptenwebglgetindexed, "_emscripten_glvertexattrib1fv": _emscripten_glvertexattrib1fv, "_ttf_sizetext": _ttf_sizetext, "_emscripten_gldeletebuffers": _emscripten_gldeletebuffers, "_gllinkprogram": _gllinkprogram, "_emscripten_glgetprograminfolog": _emscripten_glgetprograminfolog, "_emscripten_gluniform4fv": _emscripten_gluniform4fv, "___cxa_throw": ___cxa_throw, "_js_systeminfo_getcurrentcanvaswidth": _js_systeminfo_getcurrentcanvaswidth, "_gluniform1iv": _gluniform1iv, "_emscripten_gluniform2fv": _emscripten_gluniform2fv, "_emscripten_glbindbuffer": _emscripten_glbindbuffer, "_emscripten_glgetfloatv": _emscripten_glgetfloatv, "_pthread_mutex_init": _pthread_mutex_init, "_glblendequationseparate": _glblendequationseparate, "_gltexsubimage2d": _gltexsubimage2d, "_gluseprogram": _gluseprogram, "_gluniformmatrix3fv": _gluniformmatrix3fv, "_emscripten_glcullface": _emscripten_glcullface, "_glbindtransformfeedback": _glbindtransformfeedback, "_emscripten_glstencilmaskseparate": _emscripten_glstencilmaskseparate, "_emscripten_gluniform3fv": _emscripten_gluniform3fv, "_glbindbuffer": _glbindbuffer, "_emscripten_request_fullscreen": _emscripten_request_fullscreen, "_js_sound_play": _js_sound_play, "_emscripten_gldisablevertexattribarray": _emscripten_gldisablevertexattribarray, "_ttf_rendertext_solid": _ttf_rendertext_solid, "_glpolygonoffset": _glpolygonoffset, "_emscripten_webgl_get_current_context": _emscripten_webgl_get_current_context, "_emscripten_set_touchstart_callback": _emscripten_set_touchstart_callback, "_js_sound_setlistenerposition": _js_sound_setlistenerposition, "_emscripten_glgetbooleanv": _emscripten_glgetbooleanv, "_glprogrambinary": _glprogrambinary, "_emscripten_glvertexattribdivisor": _emscripten_glvertexattribdivisor, "_js_eval_settimeout": _js_eval_settimeout, "_gldrawelementsinstanced": _gldrawelementsinstanced, "_emscripten_gldeleteobjectarb": _emscripten_gldeleteobjectarb, "_emscripten_gluniform4f": _emscripten_gluniform4f, "_emscripten_glgetshaderprecisionformat": _emscripten_glgetshaderprecisionformat, "_js_systeminfo_getlanguage": _js_systeminfo_getlanguage, "_emscripten_glisenabled": _emscripten_glisenabled, "_js_systeminfo_hasfullscreen": _js_systeminfo_hasfullscreen, "_emscripten_glstencilopseparate": _emscripten_glstencilopseparate, "_js_sound_set3d": _js_sound_set3d, "_pthread_cleanup_pop": _pthread_cleanup_pop, "_glgeneratemipmap": _glgeneratemipmap, "_js_sound_setposition": _js_sound_setposition, "___syscall122": ___syscall122, "___cxa_free_exception": ___cxa_free_exception, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "_js_systeminfo_hascursorlock": _js_systeminfo_hascursorlock, "_emscripten_glclear": _emscripten_glclear, "_gldrawelements": _gldrawelements, "_js_webrequest_send": _js_webrequest_send, "_emscripten_glvalidateprogram": _emscripten_glvalidateprogram, "_emscripten_gluniform4iv": _emscripten_gluniform4iv, "___seterrno": ___seterrno, "_glstencilopseparate": _glstencilopseparate, "_js_webrequest_abort": _js_webrequest_abort, "___resumeexception": ___resumeexception, "_mktime": _mktime, "_emscripten_glgeterror": _emscripten_glgeterror, "_emscripten_glbufferdata": _emscripten_glbufferdata, "_emscripten_glstencilmask": _emscripten_glstencilmask, "_glgentextures": _glgentextures, "_glgetintegerv": _glgetintegerv, "_gluniform3iv": _gluniform3iv, "_emscripten_glclearstencil": _emscripten_glclearstencil, "_js_sound_stop": _js_sound_stop, "emscriptenwebglget": emscriptenwebglget, "_emscripten_set_mouseup_callback": _emscripten_set_mouseup_callback, "_emscripten_glfinish": _emscripten_glfinish, "_emscripten_glcleardepth": _emscripten_glcleardepth, "_emscripten_gluniform1fv": _emscripten_gluniform1fv, "_glbindframebuffer": _glbindframebuffer, "_glvalidateprogram": _glvalidateprogram, "_glgenframebuffers": _glgenframebuffers, "_sdl_upperblitscaled": _sdl_upperblitscaled, "_emscripten_gluniform4i": _emscripten_gluniform4i, "_gluniform1fv": _gluniform1fv, "_llvm_pow_f64": _llvm_pow_f64, "__emscripten_sample_gamepad_data": __emscripten_sample_gamepad_data, "_gldeleteframebuffers": _gldeleteframebuffers, "_js_filesystem_sync": _js_filesystem_sync, "_img_load": _img_load, "_glcheckframebufferstatus": _glcheckframebufferstatus, "_emscripten_glblendfunc": _emscripten_glblendfunc, "_emscripten_glcreateshader": _emscripten_glcreateshader, "_glgetprogrambinary": _glgetprogrambinary, "___syscall192": ___syscall192, "_glgetactiveuniformsiv": _glgetactiveuniformsiv, "_localtime_r": _localtime_r, "_glbindtexture": _glbindtexture, "___syscall196": ___syscall196, "_strftime": _strftime, "_emscripten_glgetvertexattribiv": _emscripten_glgetvertexattribiv, "_glreadpixels": _glreadpixels, "_glgetactiveattrib": _glgetactiveattrib, "_emscripten_gluniformmatrix3fv": _emscripten_gluniformmatrix3fv, "_gluniform2iv": _gluniform2iv, "___syscall33": ___syscall33, "_glgetactiveuniform": _glgetactiveuniform, "_ismobileos": _ismobileos, "_emscripten_gldeleteframebuffers": _emscripten_gldeleteframebuffers, "__setletterbox": __setletterbox, "___syscall39": ___syscall39, "___syscall38": ___syscall38, "_getpwuid": _getpwuid, "_glfrontface": _glfrontface, "_emscripten_glgetobjectparameterivarb": _emscripten_glgetobjectparameterivarb, "_glgetuniformiv": _glgetuniformiv, "_js_systeminfo_haswebgl": _js_systeminfo_haswebgl, "_emscripten_glgetuniformiv": _emscripten_glgetuniformiv, "_glgetactiveuniformblockiv": _glgetactiveuniformblockiv, "emscriptenwebglgetbufferbinding": emscriptenwebglgetbufferbinding, "_openwindow": _openwindow, "_glgetprogramiv": _glgetprogramiv, "___syscall168": ___syscall168, "_glscissor": _glscissor, "_emscripten_glclearcolor": _emscripten_glclearcolor, "_glgetframebufferattachmentparameteriv": _glgetframebufferattachmentparameteriv, "___cxa_find_matching_catch_4": ___cxa_find_matching_catch_4, "_emscripten_set_mousemove_callback": _emscripten_set_mousemove_callback, "_glblitframebuffer": _glblitframebuffer, "___cxa_find_matching_catch_2": ___cxa_find_matching_catch_2, "___cxa_find_matching_catch_3": ___cxa_find_matching_catch_3, "_emscripten_gldeletetextures": _emscripten_gldeletetextures, "_emscripten_exit_fullscreen": _emscripten_exit_fullscreen, "_glgetshaderiv": _glgetshaderiv, "_llvm_eh_typeid_for": _llvm_eh_typeid_for, "_glbindbufferbase": _glbindbufferbase, "_gluniform4fv": _gluniform4fv, "_gltexsubimage3d": _gltexsubimage3d, "__exit": __exit, "_img_load_rw": _img_load_rw, "_glbindattriblocation": _glbindattriblocation, "_emscripten_glcolormask": _emscripten_glcolormask, "_emscripten_webgl_destroy_context": _emscripten_webgl_destroy_context, "_emscripten_glbindtexture": _emscripten_glbindtexture, "_gldeletesamplers": _gldeletesamplers, "_gluniform4iv": _gluniform4iv, "_emscripten_set_main_loop": _emscripten_set_main_loop, "_js_webgl_initcontextattributes": _js_webgl_initcontextattributes, "_sdl_rwfromconstmem": _sdl_rwfromconstmem, "_emscripten_glisshader": _emscripten_glisshader, "_emscripten_glcompressedteximage2d": _emscripten_glcompressedteximage2d, "_gldisable": _gldisable, "_emscripten_glgetinfologarb": _emscripten_glgetinfologarb, "_atexit": _atexit, "_glfencesync": _glfencesync, "_glstencilfuncseparate": _glstencilfuncseparate, "_js_sound_releaseinstance": _js_sound_releaseinstance, "_emscripten_glgenrenderbuffers": _emscripten_glgenrenderbuffers, "_js_systeminfo_getcurrentcanvasheight": _js_systeminfo_getcurrentcanvasheight, "_js_webrequest_getresponseheaders": _js_webrequest_getresponseheaders, "_emscripten_glreleaseshadercompiler": _emscripten_glreleaseshadercompiler, "_pthread_key_create": _pthread_key_create, "_flock": _flock, "_sdl_rwfromfile": _sdl_rwfromfile, "_gluniform2fv": _gluniform2fv, "_emscripten_glfrontface": _emscripten_glfrontface, "_gldeleteprogram": _gldeleteprogram, "__zst18uncaught_exceptionv": __zst18uncaught_exceptionv, "_glblendequation": _glblendequation, "_emscripten_gluseprogram": _emscripten_gluseprogram, "_glcreateprogram": _glcreateprogram, "_clock_gettime": _clock_gettime, "_emscripten_set_touchmove_callback": _emscripten_set_touchmove_callback, "_glgetattriblocation": _glgetattriblocation, "_mix_playchannel": _mix_playchannel, "_glcreateshader": _glcreateshader, "_emscripten_glreadpixels": _emscripten_glreadpixels, "_sysconf": _sysconf, "_utime": _utime, "_glendquery": _glendquery, "_js_systeminfo_getgpuinfo": _js_systeminfo_getgpuinfo, "_pthread_mutexattr_settype": _pthread_mutexattr_settype, "_gltexstorage2d": _gltexstorage2d, "_glgenbuffers": _glgenbuffers, "_glshadersource": _glshadersource, "_emscripten_glscissor": _emscripten_glscissor, "_gluniform3uiv": _gluniform3uiv, "_pthread_cleanup_push": _pthread_cleanup_push, "_llvm_trap": _llvm_trap, "_js_sound_setvolume": _js_sound_setvolume, "_js_cursor_setshow": _js_cursor_setshow, "_glpixelstorei": _glpixelstorei, "_emscripten_glisbuffer": _emscripten_glisbuffer, "_emscripten_glvertexattrib1f": _emscripten_glvertexattrib1f, "_emscripten_set_keyup_callback": _emscripten_set_keyup_callback, "_emscripten_glcompressedtexsubimage2d": _emscripten_glcompressedtexsubimage2d, "_glsamplerparameteri": _glsamplerparameteri, "_glbindsampler": _glbindsampler, "_js_webrequest_release": _js_webrequest_release, "_emscripten_get_main_loop_timing": _emscripten_get_main_loop_timing, "_js_webrequest_settimeout": _js_webrequest_settimeout, "_glgetvertexattribiv": _glgetvertexattribiv, "_js_log_dump": _js_log_dump, "_emscripten_glgetattachedshaders": _emscripten_glgetattachedshaders, "_emscripten_glgentextures": _emscripten_glgentextures, "_glbindrenderbuffer": _glbindrenderbuffer, "_pthread_cond_init": _pthread_cond_init, "_sdl_locksurface": _sdl_locksurface, "_gmtime": _gmtime, "_emscripten_glgettexparameteriv": _emscripten_glgettexparameteriv, "_gldeletetextures": _gldeletetextures, "_emscripten_set_mousedown_callback": _emscripten_set_mousedown_callback, "_mix_haltmusic": _mix_haltmusic, "_emscripten_glclientactivetexture": _emscripten_glclientactivetexture, "_emscripten_glcheckframebufferstatus": _emscripten_glcheckframebufferstatus, "_emscripten_gluniform3f": _emscripten_gluniform3f, "_emscripten_gluniform3i": _emscripten_gluniform3i, "_gldrawbuffers": _gldrawbuffers, "_emscripten_gldeleteshader": _emscripten_gldeleteshader, "_glenable": _glenable, "_glunmapbuffer": _glunmapbuffer, "_glgetstring": _glgetstring, "_emscripten_glgetuniformlocation": _emscripten_glgetuniformlocation, "_emscripten_glenablevertexattribarray": _emscripten_glenablevertexattribarray, "_emscripten_get_now": _emscripten_get_now, "_emscripten_glgenframebuffers": _emscripten_glgenframebuffers, "emscriptenwebglgettexpixeldata": emscriptenwebglgettexpixeldata, "_gldetachshader": _gldetachshader, "_gettimeofday": _gettimeofday, "___syscall202": ___syscall202, "_showbanner": _showbanner, "_js_sound_init": _js_sound_init, "_ttf_fontheight": _ttf_fontheight, "_emscripten_gldrawelements": _emscripten_gldrawelements, "_emscripten_get_num_gamepads": _emscripten_get_num_gamepads, "___buildenvironment": ___buildenvironment, "_glcleardepthf": _glcleardepthf, "_tzset": _tzset, "_glisenabled": _glisenabled, "_emscripten_gldisable": _emscripten_gldisable, "___cxa_end_catch": ___cxa_end_catch, "_emscripten_gldeleterenderbuffers": _emscripten_gldeleterenderbuffers, "_emscripten_gldrawelementsinstanced": _emscripten_gldrawelementsinstanced, "_emscripten_glvertexattrib4f": _emscripten_glvertexattrib4f, "_js_sound_create_channel": _js_sound_create_channel, "_emscripten_glpixelstorei": _emscripten_glpixelstorei, "_glgetrenderbufferparameteriv": _glgetrenderbufferparameteriv, "_llvm_fabs_f32": _llvm_fabs_f32, "_glcopybuffersubdata": _glcopybuffersubdata, "_getenv": _getenv, "_emscripten_glframebufferrenderbuffer": _emscripten_glframebufferrenderbuffer, "_glbufferdata": _glbufferdata, "_emscripten_glrotatef": _emscripten_glrotatef, "_emscripten_glgetshaderiv": _emscripten_glgetshaderiv, "_js_eval_cleartimeout": _js_eval_cleartimeout, "___cxa_pure_virtual": ___cxa_pure_virtual, "_emscripten_gluniformmatrix4fv": _emscripten_gluniformmatrix4fv, "_emscripten_glgetpointerv": _emscripten_glgetpointerv, "_pthread_cond_wait": _pthread_cond_wait, "_clock": _clock, "_emscripten_glisrenderbuffer": _emscripten_glisrenderbuffer, "_emscripten_request_pointerlock": _emscripten_request_pointerlock, "___syscall40": ___syscall40, "_difftime": _difftime, "___syscall42": ___syscall42, "_glgetuniformindices": _glgetuniformindices, "_emscripten_set_touchcancel_callback": _emscripten_set_touchcancel_callback, "_gldeleterenderbuffers": _gldeleterenderbuffers, "_glgetshaderprecisionformat": _glgetshaderprecisionformat, "_js_systeminfo_getmemory": _js_systeminfo_getmemory, "_js_sound_setloop": _js_sound_setloop, "_js_webrequest_setresponsehandler": _js_webrequest_setresponsehandler, "_emscripten_set_focus_callback": _emscripten_set_focus_callback, "_pthread_mutexattr_destroy": _pthread_mutexattr_destroy, "_emscripten_glgetvertexattribfv": _emscripten_glgetvertexattribfv, "_sdl_pauseaudio": _sdl_pauseaudio, "_emscripten_glvertexattrib3fv": _emscripten_glvertexattrib3fv, "_glgetuniformlocation": _glgetuniformlocation, "_emscripten_glcompileshader": _emscripten_glcompileshader, "_glclear": _glclear, "_glbegintransformfeedback": _glbegintransformfeedback, "__arraysum": __arraysum, "_emscripten_gllinkprogram": _emscripten_gllinkprogram, "_js_webrequest_create": _js_webrequest_create, "_emscripten_get_pointerlock_status": _emscripten_get_pointerlock_status, "_emscripten_gldrawrangeelements": _emscripten_gldrawrangeelements, "___unlock": ___unlock, "_pthread_create": _pthread_create, "_glprogramparameteri": _glprogramparameteri, "_pthread_setspecific": _pthread_setspecific, "_glcolormask": _glcolormask, "_emscripten_glgenbuffers": _emscripten_glgenbuffers, "_glcopytexsubimage2d": _glcopytexsubimage2d, "_emscripten_glcreateprogram": _emscripten_glcreateprogram, "_js_webrequest_setprogresshandler": _js_webrequest_setprogresshandler, "_gltexparameteri": _gltexparameteri, "_pthread_cond_destroy": _pthread_cond_destroy, "_emscripten_gldetachshader": _emscripten_gldetachshader, "_emscripten_glenableclientstate": _emscripten_glenableclientstate, "_gltexparameterf": _gltexparameterf, "_setenv": _setenv, "_emscripten_do_request_fullscreen": _emscripten_do_request_fullscreen, "_glgenqueries": _glgenqueries, "_emscripten_glgetrenderbufferparameteriv": _emscripten_glgetrenderbufferparameteriv, "_emscripten_set_fullscreenchange_callback": _emscripten_set_fullscreenchange_callback, "_emscripten_glvertexattribpointer": _emscripten_glvertexattribpointer, "_gltexstorage3d": _gltexstorage3d, "_glisvertexarray": _glisvertexarray, "_js_systeminfo_getbrowsername": _js_systeminfo_getbrowsername, "_emscripten_gldrawarrays": _emscripten_gldrawarrays, "_emscripten_glpolygonoffset": _emscripten_glpolygonoffset, "_emscripten_glblendcolor": _emscripten_glblendcolor, "_glgetshaderinfolog": _glgetshaderinfolog, "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing, "_js_log_stacktrace": _js_log_stacktrace, "___cxa_begin_catch": ___cxa_begin_catch, "_emscripten_glgetprogramiv": _emscripten_glgetprogramiv, "_gldeletesync": _gldeletesync, "__adddays": __adddays, "_emscripten_glgetshadersource": _emscripten_glgetshadersource, "emscriptenwebglvalidatemapbuffertarget": emscriptenwebglvalidatemapbuffertarget, "_emscripten_glteximage2d": _emscripten_glteximage2d, "_glrenderbufferstorage": _glrenderbufferstorage, "__isleapyear": __isleapyear, "_js_sound_getlength": _js_sound_getlength, "_emscripten_glblendequationseparate": _emscripten_glblendequationseparate, "_emscripten_glgetstring": _emscripten_glgetstring, "_emscripten_glisframebuffer": _emscripten_glisframebuffer, "_gluniform2uiv": _gluniform2uiv, "_unsetenv": _unsetenv, "_emscripten_glbindprogramarb": _emscripten_glbindprogramarb, "_js_sound_setlooppoints": _js_sound_setlooppoints, "_pthread_detach": _pthread_detach, "_js_eval_evaljs": _js_eval_evaljs, "_emscripten_set_devicemotion_callback": _emscripten_set_devicemotion_callback, "___syscall85": ___syscall85, "_emscripten_gluniform2i": _emscripten_gluniform2i, "_emscripten_gluniform2f": _emscripten_gluniform2f, "_glgentransformfeedbacks": _glgentransformfeedbacks, "_js_systeminfo_getwidth": _js_systeminfo_getwidth, "_glgetprograminfolog": _glgetprograminfolog, "_emscripten_gltexparameterf": _emscripten_gltexparameterf, "_emscripten_gltexparameteri": _emscripten_gltexparameteri, "_js_sound_load": _js_sound_load, "_js_sound_load_pcm": _js_sound_load_pcm, "_emscripten_glgenvertexarrays": _emscripten_glgenvertexarrays, "_llvm_cttz_i32": _llvm_cttz_i32, "_gldeletevertexarrays": _gldeletevertexarrays, "_glgetstringi": _glgetstringi, "_emscripten_glbindattriblocation": _emscripten_glbindattriblocation, "_llvm_pow_f32": _llvm_pow_f32, "_gldepthfunc": _gldepthfunc, "___cxa_allocate_exception": ___cxa_allocate_exception, "_emscripten_set_canvas_size": _emscripten_set_canvas_size, "_emscripten_glcleardepthf": _emscripten_glcleardepthf, "_js_systeminfo_getdocumenturl": _js_systeminfo_getdocumenturl, "_emscripten_glmatrixmode": _emscripten_glmatrixmode, "___syscall15": ___syscall15, "_glblendfuncseparate": _glblendfuncseparate, "___syscall10": ___syscall10, "_emscripten_glnormalpointer": _emscripten_glnormalpointer, "_emscripten_glhint": _emscripten_glhint, "_emscripten_glenable": _emscripten_glenable, "___syscall3": ___syscall3, "___lock": ___lock, "_emscripten_glbindframebuffer": _emscripten_glbindframebuffer, "___syscall6": ___syscall6, "___syscall5": ___syscall5, "___syscall4": ___syscall4, "_emscripten_glbindrenderbuffer": _emscripten_glbindrenderbuffer, "_time": _time, "_emscripten_glgetframebufferattachmentparameteriv": _emscripten_glgetframebufferattachmentparameteriv, "_exit": _exit, "_initapi": _initapi, "_emscripten_glgetactiveattrib": _emscripten_glgetactiveattrib, "_putenv": _putenv, "___syscall268": ___syscall268, "_emscripten_set_keypress_callback": _emscripten_set_keypress_callback, "_js_systeminfo_getos": _js_systeminfo_getos, "_glmapbufferrange": _glmapbufferrange, "_js_systeminfo_getbrowserversionstring": _js_systeminfo_getbrowserversionstring, "_glgetintegeri_v": _glgetintegeri_v, "_glframebuffertexture2d": _glframebuffertexture2d, "_js_cursor_setimage": _js_cursor_setimage, "_emscripten_glshaderbinary": _emscripten_glshaderbinary, "_emscripten_glgetshaderinfolog": _emscripten_glgetshaderinfolog, "_gluniform3fv": _gluniform3fv, "_emscripten_glgetvertexattribpointerv": _emscripten_glgetvertexattribpointerv, "_glclientwaitsync": _glclientwaitsync, "_js_filesystem_setsyncinterval": _js_filesystem_setsyncinterval, "_emscripten_set_deviceorientation_callback": _emscripten_set_deviceorientation_callback, "___syscall193": ___syscall193, "_emscripten_glgetactiveuniform": _emscripten_glgetactiveuniform, "emscriptenwebglgetvertexattrib": emscriptenwebglgetvertexattrib, "___syscall197": ___syscall197, "_gluniformblockbinding": _gluniformblockbinding, "___syscall195": ___syscall195, "___syscall194": ___syscall194, "___syscall199": ___syscall199, "_emscripten_gldeleteprogram": _emscripten_gldeleteprogram, "_gluniform1i": _gluniform1i, "_glflushmappedbufferrange": _glflushmappedbufferrange, "_emscripten_gltexsubimage2d": _emscripten_gltexsubimage2d, "_pthread_mutex_destroy": _pthread_mutex_destroy, "_emscripten_glcolorpointer": _emscripten_glcolorpointer, "_glvertexattribpointer": _glvertexattribpointer, "_gltransformfeedbackvaryings": _gltransformfeedbackvaryings, "_glgetshadersource": _glgetshadersource, "_emscripten_glviewport": _emscripten_glviewport, "_emscripten_gldepthmask": _emscripten_gldepthmask, "_emscripten_gldrawbuffers": _emscripten_gldrawbuffers, "_emscripten_gllinewidth": _emscripten_gllinewidth, "_glcompileshader": _glcompileshader, "_emscripten_exit_pointerlock": _emscripten_exit_pointerlock, "_js_webrequest_setrequestheader": _js_webrequest_setrequestheader, "_abort": _abort, "_js_sound_getloadstate": _js_sound_getloadstate, "_glteximage2d": _glteximage2d, "_gluniform4uiv": _gluniform4uiv, "_glflush": _glflush, "_emscripten_glloadidentity": _emscripten_glloadidentity, "_gldeleteshader": _gldeleteshader, "_emscripten_glshadersource": _emscripten_glshadersource, "_glgenvertexarrays": _glgenvertexarrays, "_sdl_closeaudio": _sdl_closeaudio, "___gxx_personality_v0": ___gxx_personality_v0, "_emscripten_get_fullscreen_status": _emscripten_get_fullscreen_status, "_emscripten_set_touchend_callback": _emscripten_set_touchend_callback, "_glgeterror": _glgeterror, "_glgenrenderbuffers": _glgenrenderbuffers, "_emscripten_glsamplecoverage": _emscripten_glsamplecoverage, "_emscripten_glfrustum": _emscripten_glfrustum, "_mix_freechunk": _mix_freechunk, "_emscripten_gldepthrangef": _emscripten_gldepthrangef, "_js_sound_setpitch": _js_sound_setpitch, "_emscripten_glgeneratemipmap": _emscripten_glgeneratemipmap, "_glcopyteximage2d": _glcopyteximage2d, "_emscripten_glistexture": _emscripten_glistexture, "_glcompressedtexsubimage3d": _glcompressedtexsubimage3d, "_emscripten_glbindvertexarray": _emscripten_glbindvertexarray, "_sdl_upperblit": _sdl_upperblit, "___syscall51": ___syscall51, "_emscripten_glactivetexture": _emscripten_glactivetexture, "_emscripten_set_wheel_callback": _emscripten_set_wheel_callback, "_emscripten_gldeletevertexarrays": _emscripten_gldeletevertexarrays, "___syscall54": ___syscall54, "_gldeletetransformfeedbacks": _gldeletetransformfeedbacks, "_emscripten_gluniform2iv": _emscripten_gluniform2iv, "_pthread_mutexattr_init": _pthread_mutexattr_init, "_glbuffersubdata": _glbuffersubdata, "_sdl_gl_swapbuffers": _sdl_gl_swapbuffers, "_emscripten_glcopytexsubimage2d": _emscripten_glcopytexsubimage2d, "_glstencilmask": _glstencilmask, "dynamictop_ptr": dynamictop_ptr, "tempdoubleptr": tempdoubleptr, "abort": abort, "stacktop": stacktop, "stack_max": stack_max, "cttz_i8": cttz_i8 };
// emscripten_start_asm
var asm =module["asm"]// emscripten_end_asm
(module.asmglobalarg, module.asmlibraryarg, buffer);

module["asm"] = asm;
var __global__sub_i_file_cpp = module["__global__sub_i_file_cpp"] = function() { return module["asm"]["__global__sub_i_file_cpp"].apply(null, arguments) };
var __global__sub_i_platformdependent_webgl_source_0_cpp = module["__global__sub_i_platformdependent_webgl_source_0_cpp"] = function() { return module["asm"]["__global__sub_i_platformdependent_webgl_source_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_graphics_6_cpp = module["__global__sub_i_runtime_graphics_6_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_graphics_6_cpp"].apply(null, arguments) };
var __global__sub_i_unityadssettings_cpp = module["__global__sub_i_unityadssettings_cpp"] = function() { return module["asm"]["__global__sub_i_unityadssettings_cpp"].apply(null, arguments) };
var __global__sub_i_genericmetadata_cpp = module["__global__sub_i_genericmetadata_cpp"] = function() { return module["asm"]["__global__sub_i_genericmetadata_cpp"].apply(null, arguments) };
var __global__sub_i_modules_tilemap_public_0_cpp = module["__global__sub_i_modules_tilemap_public_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_tilemap_public_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_camera_renderloops_0_cpp = module["__global__sub_i_runtime_camera_renderloops_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_renderloops_0_cpp"].apply(null, arguments) };
var __global__sub_i_console_cpp = module["__global__sub_i_console_cpp"] = function() { return module["asm"]["__global__sub_i_console_cpp"].apply(null, arguments) };
var _sbrk = module["_sbrk"] = function() { return module["asm"]["_sbrk"].apply(null, arguments) };
var _memcpy = module["_memcpy"] = function() { return module["asm"]["_memcpy"].apply(null, arguments) };
var __global__sub_i_gchandle_cpp = module["__global__sub_i_gchandle_cpp"] = function() { return module["asm"]["__global__sub_i_gchandle_cpp"].apply(null, arguments) };
var __global__sub_i_metadatacache_cpp = module["__global__sub_i_metadatacache_cpp"] = function() { return module["asm"]["__global__sub_i_metadatacache_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_gfxdevice_1_cpp = module["__global__sub_i_runtime_gfxdevice_1_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_gfxdevice_1_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_shaders_0_cpp = module["__global__sub_i_runtime_shaders_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_shaders_0_cpp"].apply(null, arguments) };
var __global__sub_i_modules_tilemap_0_cpp = module["__global__sub_i_modules_tilemap_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_tilemap_0_cpp"].apply(null, arguments) };
var __global__sub_i_glslgpuprogramgles_cpp = module["__global__sub_i_glslgpuprogramgles_cpp"] = function() { return module["asm"]["__global__sub_i_glslgpuprogramgles_cpp"].apply(null, arguments) };
var __global__sub_i_modules_terrain_public_2_cpp = module["__global__sub_i_modules_terrain_public_2_cpp"] = function() { return module["asm"]["__global__sub_i_modules_terrain_public_2_cpp"].apply(null, arguments) };
var __global__sub_i_spriterendererjobs_cpp = module["__global__sub_i_spriterendererjobs_cpp"] = function() { return module["asm"]["__global__sub_i_spriterendererjobs_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_cpp_42981 = module["__global__sub_i_runtime_cpp_42981"] = function() { return module["asm"]["__global__sub_i_runtime_cpp_42981"].apply(null, arguments) };
var ___cxx_global_var_init_66 = module["___cxx_global_var_init_66"] = function() { return module["asm"]["___cxx_global_var_init_66"].apply(null, arguments) };
var __global__sub_i_runtime_geometry_0_cpp = module["__global__sub_i_runtime_geometry_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_geometry_0_cpp"].apply(null, arguments) };
var __global__sub_i_genericmethod_cpp = module["__global__sub_i_genericmethod_cpp"] = function() { return module["asm"]["__global__sub_i_genericmethod_cpp"].apply(null, arguments) };
var ___cxa_can_catch = module["___cxa_can_catch"] = function() { return module["asm"]["___cxa_can_catch"].apply(null, arguments) };
var _free = module["_free"] = function() { return module["asm"]["_free"].apply(null, arguments) };
var runpostsets = module["runpostsets"] = function() { return module["asm"]["runpostsets"].apply(null, arguments) };
var __global__sub_i_runtime_2d_spriteatlas_0_cpp = module["__global__sub_i_runtime_2d_spriteatlas_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_2d_spriteatlas_0_cpp"].apply(null, arguments) };
var _strstr = module["_strstr"] = function() { return module["asm"]["_strstr"].apply(null, arguments) };
var __global__sub_i_runtime_cloth_0_cpp = module["__global__sub_i_runtime_cloth_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_cloth_0_cpp"].apply(null, arguments) };
var __global__sub_i_cmeventprofiler_cpp = module["__global__sub_i_cmeventprofiler_cpp"] = function() { return module["asm"]["__global__sub_i_cmeventprofiler_cpp"].apply(null, arguments) };
var _memalign = module["_memalign"] = function() { return module["asm"]["_memalign"].apply(null, arguments) };
var ___cxx_global_var_init_13 = module["___cxx_global_var_init_13"] = function() { return module["asm"]["___cxx_global_var_init_13"].apply(null, arguments) };
var __global__sub_i_runtime_utilities_6_cpp = module["__global__sub_i_runtime_utilities_6_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_utilities_6_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_particlesystem_modules_3_cpp = module["__global__sub_i_runtime_particlesystem_modules_3_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_particlesystem_modules_3_cpp"].apply(null, arguments) };
var __global__sub_i_socket_cpp = module["__global__sub_i_socket_cpp"] = function() { return module["asm"]["__global__sub_i_socket_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_misc_0_cpp = module["__global__sub_i_runtime_misc_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_misc_0_cpp"].apply(null, arguments) };
var _setfullscreen = module["_setfullscreen"] = function() { return module["asm"]["_setfullscreen"].apply(null, arguments) };
var __global__sub_i_runtime_assetbundles_1_cpp = module["__global__sub_i_runtime_assetbundles_1_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_assetbundles_1_cpp"].apply(null, arguments) };
var _main = module["_main"] = function() { return module["asm"]["_main"].apply(null, arguments) };
var __global__sub_i_runtime_camera_renderloops_1_cpp = module["__global__sub_i_runtime_camera_renderloops_1_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_renderloops_1_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_utilities_0_cpp = module["__global__sub_i_runtime_utilities_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_utilities_0_cpp"].apply(null, arguments) };
var __global__sub_i_assembly_cpp = module["__global__sub_i_assembly_cpp"] = function() { return module["asm"]["__global__sub_i_assembly_cpp"].apply(null, arguments) };
var __global__sub_i_umbra_cpp = module["__global__sub_i_umbra_cpp"] = function() { return module["asm"]["__global__sub_i_umbra_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_dynamics_2_cpp = module["__global__sub_i_runtime_dynamics_2_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_dynamics_2_cpp"].apply(null, arguments) };
var ___cxx_global_var_init_128 = module["___cxx_global_var_init_128"] = function() { return module["asm"]["___cxx_global_var_init_128"].apply(null, arguments) };
var ___cxa_is_pointer_type = module["___cxa_is_pointer_type"] = function() { return module["asm"]["___cxa_is_pointer_type"].apply(null, arguments) };
var _llvm_ctlz_i64 = module["_llvm_ctlz_i64"] = function() { return module["asm"]["_llvm_ctlz_i64"].apply(null, arguments) };
var __global__sub_i_artifacts_generated_webgl_modules_vr_0_cpp = module["__global__sub_i_artifacts_generated_webgl_modules_vr_0_cpp"] = function() { return module["asm"]["__global__sub_i_artifacts_generated_webgl_modules_vr_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_scripting_2_cpp = module["__global__sub_i_runtime_scripting_2_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_scripting_2_cpp"].apply(null, arguments) };
var __global__sub_i_rcw_cpp = module["__global__sub_i_rcw_cpp"] = function() { return module["asm"]["__global__sub_i_rcw_cpp"].apply(null, arguments) };
var _pthread_self = module["_pthread_self"] = function() { return module["asm"]["_pthread_self"].apply(null, arguments) };
var _ntohs = module["_ntohs"] = function() { return module["asm"]["_ntohs"].apply(null, arguments) };
var __global__sub_i_modules_terrain_public_0_cpp = module["__global__sub_i_modules_terrain_public_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_terrain_public_0_cpp"].apply(null, arguments) };
var __global__sub_i_modules_terrain_public_1_cpp = module["__global__sub_i_modules_terrain_public_1_cpp"] = function() { return module["asm"]["__global__sub_i_modules_terrain_public_1_cpp"].apply(null, arguments) };
var __global__sub_i_memorymappedfile_cpp = module["__global__sub_i_memorymappedfile_cpp"] = function() { return module["asm"]["__global__sub_i_memorymappedfile_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_vr_1_cpp = module["__global__sub_i_runtime_vr_1_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_vr_1_cpp"].apply(null, arguments) };
var _llvm_bswap_i32 = module["_llvm_bswap_i32"] = function() { return module["asm"]["_llvm_bswap_i32"].apply(null, arguments) };
var __global__sub_i_runtime_particlesystem_modules_5_cpp = module["__global__sub_i_runtime_particlesystem_modules_5_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_particlesystem_modules_5_cpp"].apply(null, arguments) };
var __global__sub_i_string_cpp = module["__global__sub_i_string_cpp"] = function() { return module["asm"]["__global__sub_i_string_cpp"].apply(null, arguments) };
var __global__sub_i_reflection_cpp = module["__global__sub_i_reflection_cpp"] = function() { return module["asm"]["__global__sub_i_reflection_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_camera_5_cpp = module["__global__sub_i_runtime_camera_5_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_5_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_graphics_7_cpp = module["__global__sub_i_runtime_graphics_7_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_graphics_7_cpp"].apply(null, arguments) };
var ___cxx_global_var_init_18 = module["___cxx_global_var_init_18"] = function() { return module["asm"]["___cxx_global_var_init_18"].apply(null, arguments) };
var __global__sub_i_runtime_input_0_cpp = module["__global__sub_i_runtime_input_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_input_0_cpp"].apply(null, arguments) };
var __global__sub_i_arraymetadata_cpp = module["__global__sub_i_arraymetadata_cpp"] = function() { return module["asm"]["__global__sub_i_arraymetadata_cpp"].apply(null, arguments) };
var __global__sub_i_nativedelegatemethodcache_cpp = module["__global__sub_i_nativedelegatemethodcache_cpp"] = function() { return module["asm"]["__global__sub_i_nativedelegatemethodcache_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_shaders_shaderimpl_0_cpp = module["__global__sub_i_runtime_shaders_shaderimpl_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_shaders_shaderimpl_0_cpp"].apply(null, arguments) };
var _roundf = module["_roundf"] = function() { return module["asm"]["_roundf"].apply(null, arguments) };
var __global__sub_i_libraryloader_cpp = module["__global__sub_i_libraryloader_cpp"] = function() { return module["asm"]["__global__sub_i_libraryloader_cpp"].apply(null, arguments) };
var _sendmessagefloat = module["_sendmessagefloat"] = function() { return module["asm"]["_sendmessagefloat"].apply(null, arguments) };
var __global__sub_i_runtime_baseclasses_2_cpp = module["__global__sub_i_runtime_baseclasses_2_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_baseclasses_2_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_graphics_mesh_2_cpp = module["__global__sub_i_runtime_graphics_mesh_2_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_graphics_mesh_2_cpp"].apply(null, arguments) };
var __global__sub_i_modules_profiler_public_0_cpp = module["__global__sub_i_modules_profiler_public_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_profiler_public_0_cpp"].apply(null, arguments) };
var _memset = module["_memset"] = function() { return module["asm"]["_memset"].apply(null, arguments) };
var __global__sub_i_stacktrace_cpp = module["__global__sub_i_stacktrace_cpp"] = function() { return module["asm"]["__global__sub_i_stacktrace_cpp"].apply(null, arguments) };
var __global__sub_i_interlocked_cpp = module["__global__sub_i_interlocked_cpp"] = function() { return module["asm"]["__global__sub_i_interlocked_cpp"].apply(null, arguments) };
var __global__sub_i_environment_cpp = module["__global__sub_i_environment_cpp"] = function() { return module["asm"]["__global__sub_i_environment_cpp"].apply(null, arguments) };
var __global__sub_i_swcollision_cpp = module["__global__sub_i_swcollision_cpp"] = function() { return module["asm"]["__global__sub_i_swcollision_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_camera_3_cpp = module["__global__sub_i_runtime_camera_3_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_3_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_graphics_mesh_0_cpp = module["__global__sub_i_runtime_graphics_mesh_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_graphics_mesh_0_cpp"].apply(null, arguments) };
var __global__sub_i_pxsfluiddynamics_cpp = module["__global__sub_i_pxsfluiddynamics_cpp"] = function() { return module["asm"]["__global__sub_i_pxsfluiddynamics_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_scenemanager_0_cpp = module["__global__sub_i_runtime_scenemanager_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_scenemanager_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_ui_0_cpp = module["__global__sub_i_runtime_ui_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_ui_0_cpp"].apply(null, arguments) };
var __global__sub_i_class_cpp = module["__global__sub_i_class_cpp"] = function() { return module["asm"]["__global__sub_i_class_cpp"].apply(null, arguments) };
var _pthread_cond_broadcast = module["_pthread_cond_broadcast"] = function() { return module["asm"]["_pthread_cond_broadcast"].apply(null, arguments) };
var __global__sub_i_image_cpp = module["__global__sub_i_image_cpp"] = function() { return module["asm"]["__global__sub_i_image_cpp"].apply(null, arguments) };
var ___cxx_global_var_init_5_1260 = module["___cxx_global_var_init_5_1260"] = function() { return module["asm"]["___cxx_global_var_init_5_1260"].apply(null, arguments) };
var __global__sub_i_runtime_camera_0_cpp = module["__global__sub_i_runtime_camera_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_0_cpp"].apply(null, arguments) };
var __global__sub_i_path_cpp = module["__global__sub_i_path_cpp"] = function() { return module["asm"]["__global__sub_i_path_cpp"].apply(null, arguments) };
var __global__sub_i_swselfcollision_cpp = module["__global__sub_i_swselfcollision_cpp"] = function() { return module["asm"]["__global__sub_i_swselfcollision_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_dynamics_0_cpp = module["__global__sub_i_runtime_dynamics_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_dynamics_0_cpp"].apply(null, arguments) };
var __global__sub_i_il2cppcoderegistration_cpp = module["__global__sub_i_il2cppcoderegistration_cpp"] = function() { return module["asm"]["__global__sub_i_il2cppcoderegistration_cpp"].apply(null, arguments) };
var _malloc = module["_malloc"] = function() { return module["asm"]["_malloc"].apply(null, arguments) };
var __global__sub_i_runtime_cpp = module["__global__sub_i_runtime_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_cpp"].apply(null, arguments) };
var __global__sub_i_threadimpl_cpp = module["__global__sub_i_threadimpl_cpp"] = function() { return module["asm"]["__global__sub_i_threadimpl_cpp"].apply(null, arguments) };
var _sendmessage = module["_sendmessage"] = function() { return module["asm"]["_sendmessage"].apply(null, arguments) };
var __global__sub_i_runtime_camera_1_cpp = module["__global__sub_i_runtime_camera_1_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_1_cpp"].apply(null, arguments) };
var ___cxx_global_var_init_7_2511 = module["___cxx_global_var_init_7_2511"] = function() { return module["asm"]["___cxx_global_var_init_7_2511"].apply(null, arguments) };
var __global__sub_i_swsolverkernel_cpp = module["__global__sub_i_swsolverkernel_cpp"] = function() { return module["asm"]["__global__sub_i_swsolverkernel_cpp"].apply(null, arguments) };
var __global__sub_i_thread_cpp_41939 = module["__global__sub_i_thread_cpp_41939"] = function() { return module["asm"]["__global__sub_i_thread_cpp_41939"].apply(null, arguments) };
var __global__sub_i_modules_terrain_vr_0_cpp = module["__global__sub_i_modules_terrain_vr_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_terrain_vr_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_core_callbacks_0_cpp = module["__global__sub_i_runtime_core_callbacks_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_core_callbacks_0_cpp"].apply(null, arguments) };
var __global__sub_i_error_cpp = module["__global__sub_i_error_cpp"] = function() { return module["asm"]["__global__sub_i_error_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_scripting_0_cpp = module["__global__sub_i_runtime_scripting_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_scripting_0_cpp"].apply(null, arguments) };
var __global__sub_i_thread_cpp = module["__global__sub_i_thread_cpp"] = function() { return module["asm"]["__global__sub_i_thread_cpp"].apply(null, arguments) };
var _pthread_mutex_lock = module["_pthread_mutex_lock"] = function() { return module["asm"]["_pthread_mutex_lock"].apply(null, arguments) };
var __global__sub_i_appdomain_cpp = module["__global__sub_i_appdomain_cpp"] = function() { return module["asm"]["__global__sub_i_appdomain_cpp"].apply(null, arguments) };
var __global__sub_i_garbagecollector_cpp = module["__global__sub_i_garbagecollector_cpp"] = function() { return module["asm"]["__global__sub_i_garbagecollector_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_video_0_cpp = module["__global__sub_i_runtime_video_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_video_0_cpp"].apply(null, arguments) };
var __global__sub_i_modules_profiler_runtime_0_cpp = module["__global__sub_i_modules_profiler_runtime_0_cpp"] = function() { return module["asm"]["__global__sub_i_modules_profiler_runtime_0_cpp"].apply(null, arguments) };
var __global__sub_i_swintercollision_cpp = module["__global__sub_i_swintercollision_cpp"] = function() { return module["asm"]["__global__sub_i_swintercollision_cpp"].apply(null, arguments) };
var _htonl = module["_htonl"] = function() { return module["asm"]["_htonl"].apply(null, arguments) };
var _realloc = module["_realloc"] = function() { return module["asm"]["_realloc"].apply(null, arguments) };
var __global__sub_i_runtime_camera_6_cpp = module["__global__sub_i_runtime_camera_6_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_6_cpp"].apply(null, arguments) };
var _pthread_mutex_unlock = module["_pthread_mutex_unlock"] = function() { return module["asm"]["_pthread_mutex_unlock"].apply(null, arguments) };
var __global__sub_i_runtime_gfxdevice_2_cpp = module["__global__sub_i_runtime_gfxdevice_2_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_gfxdevice_2_cpp"].apply(null, arguments) };
var _htons = module["_htons"] = function() { return module["asm"]["_htons"].apply(null, arguments) };
var __global__sub_i_runtime_math_random_0_cpp = module["__global__sub_i_runtime_math_random_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_math_random_0_cpp"].apply(null, arguments) };
var ___errno_location = module["___errno_location"] = function() { return module["asm"]["___errno_location"].apply(null, arguments) };
var _sendmessagestring = module["_sendmessagestring"] = function() { return module["asm"]["_sendmessagestring"].apply(null, arguments) };
var _llvm_bswap_i16 = module["_llvm_bswap_i16"] = function() { return module["asm"]["_llvm_bswap_i16"].apply(null, arguments) };
var __global__sub_i_assembly_cpp_42452 = module["__global__sub_i_assembly_cpp_42452"] = function() { return module["asm"]["__global__sub_i_assembly_cpp_42452"].apply(null, arguments) };
var _memmove = module["_memmove"] = function() { return module["asm"]["_memmove"].apply(null, arguments) };
var __global__sub_i_platformdependent_webgl_source_1_cpp = module["__global__sub_i_platformdependent_webgl_source_1_cpp"] = function() { return module["asm"]["__global__sub_i_platformdependent_webgl_source_1_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_graphics_billboard_0_cpp = module["__global__sub_i_runtime_graphics_billboard_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_graphics_billboard_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_camera_renderlayers_0_cpp = module["__global__sub_i_runtime_camera_renderlayers_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_camera_renderlayers_0_cpp"].apply(null, arguments) };
var __global__sub_i_runtime_utilities_4_cpp = module["__global__sub_i_runtime_utilities_4_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_utilities_4_cpp"].apply(null, arguments) };
var ___cxx_global_var_init_74 = module["___cxx_global_var_init_74"] = function() { return module["asm"]["___cxx_global_var_init_74"].apply(null, arguments) };
var ___cxx_global_var_init_75 = module["___cxx_global_var_init_75"] = function() { return module["asm"]["___cxx_global_var_init_75"].apply(null, arguments) };
var __global__sub_i_runtime_imgui_0_cpp = module["__global__sub_i_runtime_imgui_0_cpp"] = function() { return module["asm"]["__global__sub_i_runtime_imgui_0_cpp"].apply(null, arguments) };
var dyncall_diji = module["dyncall_diji"] = function() { return module["asm"]["dyncall_diji"].apply(null, arguments) };
var dyncall_diddi = module["dyncall_diddi"] = function() { return module["asm"]["dyncall_diddi"].apply(null, arguments) };
var dyncall_viij = module["dyncall_viij"] = function() { return module["asm"]["dyncall_viij"].apply(null, arguments) };
var dyncall_fiff = module["dyncall_fiff"] = function() { return module["asm"]["dyncall_fiff"].apply(null, arguments) };
var dyncall_fifi = module["dyncall_fifi"] = function() { return module["asm"]["dyncall_fifi"].apply(null, arguments) };
var dyncall_vijjiiiiii = module["dyncall_vijjiiiiii"] = function() { return module["asm"]["dyncall_vijjiiiiii"].apply(null, arguments) };
var dyncall_iiiiiii = module["dyncall_iiiiiii"] = function() { return module["asm"]["dyncall_iiiiiii"].apply(null, arguments) };
var dyncall_vidi = module["dyncall_vidi"] = function() { return module["asm"]["dyncall_vidi"].apply(null, arguments) };
var dyncall_vifiiiiiiiiiiiiiiiiii = module["dyncall_vifiiiiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_vifiiiiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_viiiiiiiiiii = module["dyncall_viiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiii"].apply(null, arguments) };
var dyncall_fff = module["dyncall_fff"] = function() { return module["asm"]["dyncall_fff"].apply(null, arguments) };
var dyncall_iidi = module["dyncall_iidi"] = function() { return module["asm"]["dyncall_iidi"].apply(null, arguments) };
var dyncall_jiji = module["dyncall_jiji"] = function() { return module["asm"]["dyncall_jiji"].apply(null, arguments) };
var dyncall_fiiiiiifiiiiiif = module["dyncall_fiiiiiifiiiiiif"] = function() { return module["asm"]["dyncall_fiiiiiifiiiiiif"].apply(null, arguments) };
var dyncall_iiiiifiif = module["dyncall_iiiiifiif"] = function() { return module["asm"]["dyncall_iiiiifiif"].apply(null, arguments) };
var dyncall_iiiiifii = module["dyncall_iiiiifii"] = function() { return module["asm"]["dyncall_iiiiifii"].apply(null, arguments) };
var dyncall_viiiiiffi = module["dyncall_viiiiiffi"] = function() { return module["asm"]["dyncall_viiiiiffi"].apply(null, arguments) };
var dyncall_viifiiii = module["dyncall_viifiiii"] = function() { return module["asm"]["dyncall_viifiiii"].apply(null, arguments) };
var dyncall_viiijiii = module["dyncall_viiijiii"] = function() { return module["asm"]["dyncall_viiijiii"].apply(null, arguments) };
var dyncall_iiiiifiii = module["dyncall_iiiiifiii"] = function() { return module["asm"]["dyncall_iiiiifiii"].apply(null, arguments) };
var dyncall_iiffi = module["dyncall_iiffi"] = function() { return module["asm"]["dyncall_iiffi"].apply(null, arguments) };
var dyncall_jii = module["dyncall_jii"] = function() { return module["asm"]["dyncall_jii"].apply(null, arguments) };
var dyncall_iiiiiiiiiiii = module["dyncall_iiiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiii"].apply(null, arguments) };
var dyncall_fif = module["dyncall_fif"] = function() { return module["asm"]["dyncall_fif"].apply(null, arguments) };
var dyncall_viiiiiiiiiiiiiii = module["dyncall_viiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_viiiiif = module["dyncall_viiiiif"] = function() { return module["asm"]["dyncall_viiiiif"].apply(null, arguments) };
var dyncall_fii = module["dyncall_fii"] = function() { return module["asm"]["dyncall_fii"].apply(null, arguments) };
var dyncall_viiiiifii = module["dyncall_viiiiifii"] = function() { return module["asm"]["dyncall_viiiiifii"].apply(null, arguments) };
var dyncall_di = module["dyncall_di"] = function() { return module["asm"]["dyncall_di"].apply(null, arguments) };
var dyncall_viff = module["dyncall_viff"] = function() { return module["asm"]["dyncall_viff"].apply(null, arguments) };
var dyncall_iiifiii = module["dyncall_iiifiii"] = function() { return module["asm"]["dyncall_iiifiii"].apply(null, arguments) };
var dyncall_viffff = module["dyncall_viffff"] = function() { return module["asm"]["dyncall_viffff"].apply(null, arguments) };
var dyncall_jijji = module["dyncall_jijji"] = function() { return module["asm"]["dyncall_jijji"].apply(null, arguments) };
var dyncall_vijiiii = module["dyncall_vijiiii"] = function() { return module["asm"]["dyncall_vijiiii"].apply(null, arguments) };
var dyncall_viiji = module["dyncall_viiji"] = function() { return module["asm"]["dyncall_viiji"].apply(null, arguments) };
var dyncall_viiiiijiiii = module["dyncall_viiiiijiiii"] = function() { return module["asm"]["dyncall_viiiiijiiii"].apply(null, arguments) };
var dyncall_iiijjii = module["dyncall_iiijjii"] = function() { return module["asm"]["dyncall_iiijjii"].apply(null, arguments) };
var dyncall_viiffiii = module["dyncall_viiffiii"] = function() { return module["asm"]["dyncall_viiffiii"].apply(null, arguments) };
var dyncall_dii = module["dyncall_dii"] = function() { return module["asm"]["dyncall_dii"].apply(null, arguments) };
var dyncall_iifii = module["dyncall_iifii"] = function() { return module["asm"]["dyncall_iifii"].apply(null, arguments) };
var dyncall_didi = module["dyncall_didi"] = function() { return module["asm"]["dyncall_didi"].apply(null, arguments) };
var dyncall_iiifiifi = module["dyncall_iiifiifi"] = function() { return module["asm"]["dyncall_iiifiifi"].apply(null, arguments) };
var dyncall_iiiii = module["dyncall_iiiii"] = function() { return module["asm"]["dyncall_iiiii"].apply(null, arguments) };
var dyncall_iidii = module["dyncall_iidii"] = function() { return module["asm"]["dyncall_iidii"].apply(null, arguments) };
var dyncall_iiiij = module["dyncall_iiiij"] = function() { return module["asm"]["dyncall_iiiij"].apply(null, arguments) };
var dyncall_iiiiiiiiiiiiffffii = module["dyncall_iiiiiiiiiiiiffffii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiiiffffii"].apply(null, arguments) };
var dyncall_vdd = module["dyncall_vdd"] = function() { return module["asm"]["dyncall_vdd"].apply(null, arguments) };
var dyncall_fiiifii = module["dyncall_fiiifii"] = function() { return module["asm"]["dyncall_fiiifii"].apply(null, arguments) };
var dyncall_viiiiiiffii = module["dyncall_viiiiiiffii"] = function() { return module["asm"]["dyncall_viiiiiiffii"].apply(null, arguments) };
var dyncall_viffii = module["dyncall_viffii"] = function() { return module["asm"]["dyncall_viffii"].apply(null, arguments) };
var dyncall_iiiiiiii = module["dyncall_iiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiii"].apply(null, arguments) };
var dyncall_viiiififii = module["dyncall_viiiififii"] = function() { return module["asm"]["dyncall_viiiififii"].apply(null, arguments) };
var dyncall_vffff = module["dyncall_vffff"] = function() { return module["asm"]["dyncall_vffff"].apply(null, arguments) };
var dyncall_iijjii = module["dyncall_iijjii"] = function() { return module["asm"]["dyncall_iijjii"].apply(null, arguments) };
var dyncall_vdddddd = module["dyncall_vdddddd"] = function() { return module["asm"]["dyncall_vdddddd"].apply(null, arguments) };
var dyncall_vifiiiiiiiiiiiii = module["dyncall_vifiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_vifiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiji = module["dyncall_iiiji"] = function() { return module["asm"]["dyncall_iiiji"].apply(null, arguments) };
var dyncall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii = module["dyncall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiiiiif = module["dyncall_iiiiiiif"] = function() { return module["asm"]["dyncall_iiiiiiif"].apply(null, arguments) };
var dyncall_viidi = module["dyncall_viidi"] = function() { return module["asm"]["dyncall_viidi"].apply(null, arguments) };
var dyncall_viiffii = module["dyncall_viiffii"] = function() { return module["asm"]["dyncall_viiffii"].apply(null, arguments) };
var dyncall_ijj = module["dyncall_ijj"] = function() { return module["asm"]["dyncall_ijj"].apply(null, arguments) };
var dyncall_iiiiiiiiii = module["dyncall_iiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiiifiiiif = module["dyncall_iiiiifiiiif"] = function() { return module["asm"]["dyncall_iiiiifiiiif"].apply(null, arguments) };
var dyncall_fiffi = module["dyncall_fiffi"] = function() { return module["asm"]["dyncall_fiffi"].apply(null, arguments) };
var dyncall_iiifii = module["dyncall_iiifii"] = function() { return module["asm"]["dyncall_iiifii"].apply(null, arguments) };
var dyncall_viiiiiiiiiiiiiiiii = module["dyncall_viiiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_jiijiii = module["dyncall_jiijiii"] = function() { return module["asm"]["dyncall_jiijiii"].apply(null, arguments) };
var dyncall_iiiiiiiiiiiiii = module["dyncall_iiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_jijjji = module["dyncall_jijjji"] = function() { return module["asm"]["dyncall_jijjji"].apply(null, arguments) };
var dyncall_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii = module["dyncall_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_vifiiiiiiiiiiiiiiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_viffi = module["dyncall_viffi"] = function() { return module["asm"]["dyncall_viffi"].apply(null, arguments) };
var dyncall_iiiifiiii = module["dyncall_iiiifiiii"] = function() { return module["asm"]["dyncall_iiiifiiii"].apply(null, arguments) };
var dyncall_vifi = module["dyncall_vifi"] = function() { return module["asm"]["dyncall_vifi"].apply(null, arguments) };
var dyncall_viijj = module["dyncall_viijj"] = function() { return module["asm"]["dyncall_viijj"].apply(null, arguments) };
var dyncall_vifff = module["dyncall_vifff"] = function() { return module["asm"]["dyncall_vifff"].apply(null, arguments) };
var dyncall_viiiiii = module["dyncall_viiiiii"] = function() { return module["asm"]["dyncall_viiiiii"].apply(null, arguments) };
var dyncall_viififiii = module["dyncall_viififiii"] = function() { return module["asm"]["dyncall_viififiii"].apply(null, arguments) };
var dyncall_viiiiiiiiiiiiii = module["dyncall_viiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_fiii = module["dyncall_fiii"] = function() { return module["asm"]["dyncall_fiii"].apply(null, arguments) };
var dyncall_iiiiiifffiiifii = module["dyncall_iiiiiifffiiifii"] = function() { return module["asm"]["dyncall_iiiiiifffiiifii"].apply(null, arguments) };
var dyncall_iifff = module["dyncall_iifff"] = function() { return module["asm"]["dyncall_iifff"].apply(null, arguments) };
var dyncall_iifiii = module["dyncall_iifiii"] = function() { return module["asm"]["dyncall_iifiii"].apply(null, arguments) };
var dyncall_iiijii = module["dyncall_iiijii"] = function() { return module["asm"]["dyncall_iiijii"].apply(null, arguments) };
var dyncall_iiidiiii = module["dyncall_iiidiiii"] = function() { return module["asm"]["dyncall_iiidiiii"].apply(null, arguments) };
var dyncall_jidi = module["dyncall_jidi"] = function() { return module["asm"]["dyncall_jidi"].apply(null, arguments) };
var dyncall_iiifiifii = module["dyncall_iiifiifii"] = function() { return module["asm"]["dyncall_iiifiifii"].apply(null, arguments) };
var dyncall_ji = module["dyncall_ji"] = function() { return module["asm"]["dyncall_ji"].apply(null, arguments) };
var dyncall_iiddi = module["dyncall_iiddi"] = function() { return module["asm"]["dyncall_iiddi"].apply(null, arguments) };
var dyncall_viiiiiiiiii = module["dyncall_viiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiiiiffiiiiiiiiiffffiii = module["dyncall_iiiiiiffiiiiiiiiiffffiii"] = function() { return module["asm"]["dyncall_iiiiiiffiiiiiiiiiffffiii"].apply(null, arguments) };
var dyncall_diii = module["dyncall_diii"] = function() { return module["asm"]["dyncall_diii"].apply(null, arguments) };
var dyncall_viiiji = module["dyncall_viiiji"] = function() { return module["asm"]["dyncall_viiiji"].apply(null, arguments) };
var dyncall_vff = module["dyncall_vff"] = function() { return module["asm"]["dyncall_vff"].apply(null, arguments) };
var dyncall_viijijiii = module["dyncall_viijijiii"] = function() { return module["asm"]["dyncall_viijijiii"].apply(null, arguments) };
var dyncall_viijijji = module["dyncall_viijijji"] = function() { return module["asm"]["dyncall_viijijji"].apply(null, arguments) };
var dyncall_fiiii = module["dyncall_fiiii"] = function() { return module["asm"]["dyncall_fiiii"].apply(null, arguments) };
var dyncall_iiiiii = module["dyncall_iiiiii"] = function() { return module["asm"]["dyncall_iiiiii"].apply(null, arguments) };
var dyncall_viiiifii = module["dyncall_viiiifii"] = function() { return module["asm"]["dyncall_viiiifii"].apply(null, arguments) };
var dyncall_vijii = module["dyncall_vijii"] = function() { return module["asm"]["dyncall_vijii"].apply(null, arguments) };
var dyncall_iiiiffi = module["dyncall_iiiiffi"] = function() { return module["asm"]["dyncall_iiiiffi"].apply(null, arguments) };
var dyncall_jidji = module["dyncall_jidji"] = function() { return module["asm"]["dyncall_jidji"].apply(null, arguments) };
var dyncall_viidii = module["dyncall_viidii"] = function() { return module["asm"]["dyncall_viidii"].apply(null, arguments) };
var dyncall_vjji = module["dyncall_vjji"] = function() { return module["asm"]["dyncall_vjji"].apply(null, arguments) };
var dyncall_iiiiiifiif = module["dyncall_iiiiiifiif"] = function() { return module["asm"]["dyncall_iiiiiifiif"].apply(null, arguments) };
var dyncall_viiii = module["dyncall_viiii"] = function() { return module["asm"]["dyncall_viiii"].apply(null, arguments) };
var dyncall_jijii = module["dyncall_jijii"] = function() { return module["asm"]["dyncall_jijii"].apply(null, arguments) };
var dyncall_viiiii = module["dyncall_viiiii"] = function() { return module["asm"]["dyncall_viiiii"].apply(null, arguments) };
var dyncall_viifii = module["dyncall_viifii"] = function() { return module["asm"]["dyncall_viifii"].apply(null, arguments) };
var dyncall_iifffi = module["dyncall_iifffi"] = function() { return module["asm"]["dyncall_iifffi"].apply(null, arguments) };
var dyncall_vif = module["dyncall_vif"] = function() { return module["asm"]["dyncall_vif"].apply(null, arguments) };
var dyncall_vid = module["dyncall_vid"] = function() { return module["asm"]["dyncall_vid"].apply(null, arguments) };
var dyncall_iiidi = module["dyncall_iiidi"] = function() { return module["asm"]["dyncall_iiidi"].apply(null, arguments) };
var dyncall_vij = module["dyncall_vij"] = function() { return module["asm"]["dyncall_vij"].apply(null, arguments) };
var dyncall_vii = module["dyncall_vii"] = function() { return module["asm"]["dyncall_vii"].apply(null, arguments) };
var dyncall_vijji = module["dyncall_vijji"] = function() { return module["asm"]["dyncall_vijji"].apply(null, arguments) };
var dyncall_viiiif = module["dyncall_viiiif"] = function() { return module["asm"]["dyncall_viiiif"].apply(null, arguments) };
var dyncall_difi = module["dyncall_difi"] = function() { return module["asm"]["dyncall_difi"].apply(null, arguments) };
var dyncall_fi = module["dyncall_fi"] = function() { return module["asm"]["dyncall_fi"].apply(null, arguments) };
var dyncall_iiififiiii = module["dyncall_iiififiiii"] = function() { return module["asm"]["dyncall_iiififiiii"].apply(null, arguments) };
var dyncall_fiji = module["dyncall_fiji"] = function() { return module["asm"]["dyncall_fiji"].apply(null, arguments) };
var dyncall_jiiiiiii = module["dyncall_jiiiiiii"] = function() { return module["asm"]["dyncall_jiiiiiii"].apply(null, arguments) };
var dyncall_vijj = module["dyncall_vijj"] = function() { return module["asm"]["dyncall_vijj"].apply(null, arguments) };
var dyncall_vf = module["dyncall_vf"] = function() { return module["asm"]["dyncall_vf"].apply(null, arguments) };
var dyncall_iiiiiiffiiiiiiiiiiiiiii = module["dyncall_iiiiiiffiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiffiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_fiiiiiiiifiiiif = module["dyncall_fiiiiiiiifiiiif"] = function() { return module["asm"]["dyncall_fiiiiiiiifiiiif"].apply(null, arguments) };
var dyncall_iiifiifiii = module["dyncall_iiifiifiii"] = function() { return module["asm"]["dyncall_iiifiifiii"].apply(null, arguments) };
var dyncall_viffffii = module["dyncall_viffffii"] = function() { return module["asm"]["dyncall_viffffii"].apply(null, arguments) };
var dyncall_vifiii = module["dyncall_vifiii"] = function() { return module["asm"]["dyncall_vifiii"].apply(null, arguments) };
var dyncall_viijjii = module["dyncall_viijjii"] = function() { return module["asm"]["dyncall_viijjii"].apply(null, arguments) };
var dyncall_iijjji = module["dyncall_iijjji"] = function() { return module["asm"]["dyncall_iijjji"].apply(null, arguments) };
var dyncall_diiii = module["dyncall_diiii"] = function() { return module["asm"]["dyncall_diiii"].apply(null, arguments) };
var dyncall_iiifiiii = module["dyncall_iiifiiii"] = function() { return module["asm"]["dyncall_iiifiiii"].apply(null, arguments) };
var dyncall_viiiiiiiiiiiii = module["dyncall_viiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiiiiiiiiffffii = module["dyncall_iiiiiiiiiiffffii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiffffii"].apply(null, arguments) };
var dyncall_iiiiifi = module["dyncall_iiiiifi"] = function() { return module["asm"]["dyncall_iiiiifi"].apply(null, arguments) };
var dyncall_fifii = module["dyncall_fifii"] = function() { return module["asm"]["dyncall_fifii"].apply(null, arguments) };
var dyncall_viji = module["dyncall_viji"] = function() { return module["asm"]["dyncall_viji"].apply(null, arguments) };
var dyncall_viiiiiiii = module["dyncall_viiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiii"].apply(null, arguments) };
var dyncall_fiffifffi = module["dyncall_fiffifffi"] = function() { return module["asm"]["dyncall_fiffifffi"].apply(null, arguments) };
var dyncall_viiff = module["dyncall_viiff"] = function() { return module["asm"]["dyncall_viiff"].apply(null, arguments) };
var dyncall_iif = module["dyncall_iif"] = function() { return module["asm"]["dyncall_iif"].apply(null, arguments) };
var dyncall_vifiiii = module["dyncall_vifiiii"] = function() { return module["asm"]["dyncall_vifiiii"].apply(null, arguments) };
var dyncall_viiiiiii = module["dyncall_viiiiiii"] = function() { return module["asm"]["dyncall_viiiiiii"].apply(null, arguments) };
var dyncall_vijiji = module["dyncall_vijiji"] = function() { return module["asm"]["dyncall_vijiji"].apply(null, arguments) };
var dyncall_vifii = module["dyncall_vifii"] = function() { return module["asm"]["dyncall_vifii"].apply(null, arguments) };
var dyncall_viiiiiiiii = module["dyncall_viiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiii"].apply(null, arguments) };
var dyncall_viiiiiif = module["dyncall_viiiiiif"] = function() { return module["asm"]["dyncall_viiiiiif"].apply(null, arguments) };
var dyncall_viijji = module["dyncall_viijji"] = function() { return module["asm"]["dyncall_viijji"].apply(null, arguments) };
var dyncall_iii = module["dyncall_iii"] = function() { return module["asm"]["dyncall_iii"].apply(null, arguments) };
var dyncall_viifiii = module["dyncall_viifiii"] = function() { return module["asm"]["dyncall_viifiii"].apply(null, arguments) };
var dyncall_iij = module["dyncall_iij"] = function() { return module["asm"]["dyncall_iij"].apply(null, arguments) };
var dyncall_viiijiiiiii = module["dyncall_viiijiiiiii"] = function() { return module["asm"]["dyncall_viiijiiiiii"].apply(null, arguments) };
var dyncall_iiiifii = module["dyncall_iiiifii"] = function() { return module["asm"]["dyncall_iiiifii"].apply(null, arguments) };
var dyncall_f = module["dyncall_f"] = function() { return module["asm"]["dyncall_f"].apply(null, arguments) };
var dyncall_jiiii = module["dyncall_jiiii"] = function() { return module["asm"]["dyncall_jiiii"].apply(null, arguments) };
var dyncall_viijii = module["dyncall_viijii"] = function() { return module["asm"]["dyncall_viijii"].apply(null, arguments) };
var dyncall_viiiifiiiiif = module["dyncall_viiiifiiiiif"] = function() { return module["asm"]["dyncall_viiiifiiiiif"].apply(null, arguments) };
var dyncall_viififi = module["dyncall_viififi"] = function() { return module["asm"]["dyncall_viififi"].apply(null, arguments) };
var dyncall_viii = module["dyncall_viii"] = function() { return module["asm"]["dyncall_viii"].apply(null, arguments) };
var dyncall_viiiifi = module["dyncall_viiiifi"] = function() { return module["asm"]["dyncall_viiiifi"].apply(null, arguments) };
var dyncall_jiii = module["dyncall_jiii"] = function() { return module["asm"]["dyncall_jiii"].apply(null, arguments) };
var dyncall_iiji = module["dyncall_iiji"] = function() { return module["asm"]["dyncall_iiji"].apply(null, arguments) };
var dyncall_viif = module["dyncall_viif"] = function() { return module["asm"]["dyncall_viif"].apply(null, arguments) };
var dyncall_vijiii = module["dyncall_vijiii"] = function() { return module["asm"]["dyncall_vijiii"].apply(null, arguments) };
var dyncall_fiiifi = module["dyncall_fiiifi"] = function() { return module["asm"]["dyncall_fiiifi"].apply(null, arguments) };
var dyncall_iiiifi = module["dyncall_iiiifi"] = function() { return module["asm"]["dyncall_iiiifi"].apply(null, arguments) };
var dyncall_v = module["dyncall_v"] = function() { return module["asm"]["dyncall_v"].apply(null, arguments) };
var dyncall_vd = module["dyncall_vd"] = function() { return module["asm"]["dyncall_vd"].apply(null, arguments) };
var dyncall_viifi = module["dyncall_viifi"] = function() { return module["asm"]["dyncall_viifi"].apply(null, arguments) };
var dyncall_fiifi = module["dyncall_fiifi"] = function() { return module["asm"]["dyncall_fiifi"].apply(null, arguments) };
var dyncall_vi = module["dyncall_vi"] = function() { return module["asm"]["dyncall_vi"].apply(null, arguments) };
var dyncall_iiiiiiiiiii = module["dyncall_iiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiiiiiffiiiiiiiiiffffiiii = module["dyncall_iiiiiiiffiiiiiiiiiffffiiii"] = function() { return module["asm"]["dyncall_iiiiiiiffiiiiiiiiiffffiiii"].apply(null, arguments) };
var dyncall_viiififii = module["dyncall_viiififii"] = function() { return module["asm"]["dyncall_viiififii"].apply(null, arguments) };
var dyncall_ii = module["dyncall_ii"] = function() { return module["asm"]["dyncall_ii"].apply(null, arguments) };
var dyncall_vifffi = module["dyncall_vifffi"] = function() { return module["asm"]["dyncall_vifffi"].apply(null, arguments) };
var dyncall_iijji = module["dyncall_iijji"] = function() { return module["asm"]["dyncall_iijji"].apply(null, arguments) };
var dyncall_iiiiifiiiiii = module["dyncall_iiiiifiiiiii"] = function() { return module["asm"]["dyncall_iiiiifiiiiii"].apply(null, arguments) };
var dyncall_iiiiifiiiiif = module["dyncall_iiiiifiiiiif"] = function() { return module["asm"]["dyncall_iiiiifiiiiif"].apply(null, arguments) };
var dyncall_jifi = module["dyncall_jifi"] = function() { return module["asm"]["dyncall_jifi"].apply(null, arguments) };
var dyncall_viiiiiiiiiiii = module["dyncall_viiiiiiiiiiii"] = function() { return module["asm"]["dyncall_viiiiiiiiiiii"].apply(null, arguments) };
var dyncall_iifi = module["dyncall_iifi"] = function() { return module["asm"]["dyncall_iifi"].apply(null, arguments) };
var dyncall_viiif = module["dyncall_viiif"] = function() { return module["asm"]["dyncall_viiif"].apply(null, arguments) };
var dyncall_fifffi = module["dyncall_fifffi"] = function() { return module["asm"]["dyncall_fifffi"].apply(null, arguments) };
var dyncall_jiiiii = module["dyncall_jiiiii"] = function() { return module["asm"]["dyncall_jiiiii"].apply(null, arguments) };
var dyncall_vifiiiiiiiiiiiiiiiiiiiiiii = module["dyncall_vifiiiiiiiiiiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_vifiiiiiiiiiiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_iiiffii = module["dyncall_iiiffii"] = function() { return module["asm"]["dyncall_iiiffii"].apply(null, arguments) };
var dyncall_vijiijiii = module["dyncall_vijiijiii"] = function() { return module["asm"]["dyncall_vijiijiii"].apply(null, arguments) };
var dyncall_iiifi = module["dyncall_iiifi"] = function() { return module["asm"]["dyncall_iiifi"].apply(null, arguments) };
var dyncall_iiii = module["dyncall_iiii"] = function() { return module["asm"]["dyncall_iiii"].apply(null, arguments) };
var dyncall_fidi = module["dyncall_fidi"] = function() { return module["asm"]["dyncall_fidi"].apply(null, arguments) };
var dyncall_iiij = module["dyncall_iiij"] = function() { return module["asm"]["dyncall_iiij"].apply(null, arguments) };
var dyncall_viifff = module["dyncall_viifff"] = function() { return module["asm"]["dyncall_viifff"].apply(null, arguments) };
var dyncall_viiffi = module["dyncall_viiffi"] = function() { return module["asm"]["dyncall_viiffi"].apply(null, arguments) };
var dyncall_iiid = module["dyncall_iiid"] = function() { return module["asm"]["dyncall_iiid"].apply(null, arguments) };
var dyncall_iiiifiifiii = module["dyncall_iiiifiifiii"] = function() { return module["asm"]["dyncall_iiiifiifiii"].apply(null, arguments) };
var dyncall_iiif = module["dyncall_iiif"] = function() { return module["asm"]["dyncall_iiif"].apply(null, arguments) };
var dyncall_viiiffi = module["dyncall_viiiffi"] = function() { return module["asm"]["dyncall_viiiffi"].apply(null, arguments) };
var dyncall_diiiii = module["dyncall_diiiii"] = function() { return module["asm"]["dyncall_diiiii"].apply(null, arguments) };
var dyncall_viiifi = module["dyncall_viiifi"] = function() { return module["asm"]["dyncall_viiifi"].apply(null, arguments) };
var dyncall_fiiffi = module["dyncall_fiiffi"] = function() { return module["asm"]["dyncall_fiiffi"].apply(null, arguments) };
var dyncall_iiiiiiffiiiiiiiiiffffiiii = module["dyncall_iiiiiiffiiiiiiiiiffffiiii"] = function() { return module["asm"]["dyncall_iiiiiiffiiiiiiiiiffffiiii"].apply(null, arguments) };
var dyncall_iiiiiiiiiiiii = module["dyncall_iiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_viifffi = module["dyncall_viifffi"] = function() { return module["asm"]["dyncall_viifffi"].apply(null, arguments) };
var dyncall_vifffii = module["dyncall_vifffii"] = function() { return module["asm"]["dyncall_vifffii"].apply(null, arguments) };
var dyncall_iiiifiii = module["dyncall_iiiifiii"] = function() { return module["asm"]["dyncall_iiiifiii"].apply(null, arguments) };
var dyncall_ff = module["dyncall_ff"] = function() { return module["asm"]["dyncall_ff"].apply(null, arguments) };
var dyncall_iiiifiiiii = module["dyncall_iiiifiiiii"] = function() { return module["asm"]["dyncall_iiiifiiiii"].apply(null, arguments) };
var dyncall_iijii = module["dyncall_iijii"] = function() { return module["asm"]["dyncall_iijii"].apply(null, arguments) };
var dyncall_iiiiiiiiiiiiiii = module["dyncall_iiiiiiiiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiiiiiiiii"].apply(null, arguments) };
var dyncall_viiijjii = module["dyncall_viiijjii"] = function() { return module["asm"]["dyncall_viiijjii"].apply(null, arguments) };
var dyncall_vfi = module["dyncall_vfi"] = function() { return module["asm"]["dyncall_vfi"].apply(null, arguments) };
var dyncall_i = module["dyncall_i"] = function() { return module["asm"]["dyncall_i"].apply(null, arguments) };
var dyncall_iiidii = module["dyncall_iiidii"] = function() { return module["asm"]["dyncall_iiidii"].apply(null, arguments) };
var dyncall_iiidiiiii = module["dyncall_iiidiiiii"] = function() { return module["asm"]["dyncall_iiidiiiii"].apply(null, arguments) };
var dyncall_viiifiiiii = module["dyncall_viiifiiiii"] = function() { return module["asm"]["dyncall_viiifiiiii"].apply(null, arguments) };
var dyncall_iiijjiiii = module["dyncall_iiijjiiii"] = function() { return module["asm"]["dyncall_iiijjiiii"].apply(null, arguments) };
var dyncall_iiiiiijii = module["dyncall_iiiiiijii"] = function() { return module["asm"]["dyncall_iiiiiijii"].apply(null, arguments) };
var dyncall_viijjji = module["dyncall_viijjji"] = function() { return module["asm"]["dyncall_viijjji"].apply(null, arguments) };
var dyncall_iiiiiiiii = module["dyncall_iiiiiiiii"] = function() { return module["asm"]["dyncall_iiiiiiiii"].apply(null, arguments) };
var dyncall_viffffi = module["dyncall_viffffi"] = function() { return module["asm"]["dyncall_viffffi"].apply(null, arguments) };
;

runtime.stackalloc = asm['stackalloc'];
runtime.stacksave = asm['stacksave'];
runtime.stackrestore = asm['stackrestore'];
runtime.establishstackspace = asm['establishstackspace'];

runtime.settempret0 = asm['settempret0'];
runtime.gettempret0 = asm['gettempret0'];



// === auto-generated postamble setup entry stuff ===



if (memoryinitializer) {
  if (typeof module['locatefile'] === 'function') {
    memoryinitializer = module['locatefile'](memoryinitializer);
  } else if (module['memoryinitializerprefixurl']) {
    memoryinitializer = module['memoryinitializerprefixurl'] + memoryinitializer;
  }
  if (environment_is_node || environment_is_shell) {
    var data = module['readbinary'](memoryinitializer);
    heapu8.set(data, runtime.global_base);
  } else {
    addrundependency('memory initializer');
    var applymemoryinitializer = function(data) {
      if (data.bytelength) data = new uint8array(data);
      heapu8.set(data, runtime.global_base);
      // delete the typed array that contains the large blob of the memory initializer request response so that
      // we won't keep unnecessary memory lying around. however, keep the xhr object itself alive so that e.g.
      // its .status field can still be accessed later.
      if (module['memoryinitializerrequest']) delete module['memoryinitializerrequest'].response;
      removerundependency('memory initializer');
    }
    function dobrowserload() {
      module['readasync'](memoryinitializer, applymemoryinitializer, function() {
        throw 'could not load memory initializer ' + memoryinitializer;
      });
    }
    if (module['memoryinitializerrequest']) {
      // a network request has already been created, just use that
      function userequest() {
        var request = module['memoryinitializerrequest'];
        if (request.status !== 200 && request.status !== 0) {
          // if you see this warning, the issue may be that you are using locatefile or memoryinitializerprefixurl, and defining them in js. that
          // means that the html file doesn't know about them, and when it tries to create the mem init request early, does it to the wrong place.
          // look in your browser's devtools network console to see what's going on.
          console.warn('a problem seems to have happened with module.memoryinitializerrequest, status: ' + request.status + ', retrying ' + memoryinitializer);
          dobrowserload();
          return;
        }
        applymemoryinitializer(request.response);
      }
      if (module['memoryinitializerrequest'].response) {
        settimeout(userequest, 0); // it's already here; but, apply it asynchronously
      } else {
        module['memoryinitializerrequest'].addeventlistener('load', userequest); // wait for it
      }
    } else {
      // fetch it from the network ourselves
      dobrowserload();
    }
  }
}


function exitstatus(status) {
  this.name = "exitstatus";
  this.message = "program terminated with exit(" + status + ")";
  this.status = status;
};
exitstatus.prototype = new error();
exitstatus.prototype.constructor = exitstatus;

var initialstacktop;
var preloadstarttime = null;
var calledmain = false;

dependenciesfulfilled = function runcaller() {
  // if run has never been called, and we should call run (invoke_run is true, and module.noinitialrun is not false)
  if (!module['calledrun']) run();
  if (!module['calledrun']) dependenciesfulfilled = runcaller; // try this again later, after new deps are fulfilled
}

module['callmain'] = module.callmain = function callmain(args) {

  args = args || [];

  ensureinitruntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intarrayfromstring(module['thisprogram']), 'i8', alloc_normal) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intarrayfromstring(args[i]), 'i8', alloc_normal));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', alloc_normal);


  try {

    var ret = module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof exitstatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'simulateinfiniteloop') {
      // running an evented main loop, don't immediately exit
      module['noexitruntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) module.printerr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledmain = true;
  }
}




function run(args) {
  args = args || module['arguments'];

  if (preloadstarttime === null) preloadstarttime = date.now();

  if (rundependencies > 0) {
    return;
  }


  prerun();

  if (rundependencies > 0) return; // a prerun added a dependency, run will be called later
  if (module['calledrun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function dorun() {
    if (module['calledrun']) return; // run may have just been called while the async setstatus time below was happening
    module['calledrun'] = true;

    if (abort) return;

    ensureinitruntime();

    premain();


    if (module['onruntimeinitialized']) module['onruntimeinitialized']();

    if (module['_main'] && shouldrunnow) module['callmain'](args);

    postrun();
  }

  if (module['setstatus']) {
    module['setstatus']('running...');
    settimeout(function() {
      settimeout(function() {
        module['setstatus']('');
      }, 1);
      dorun();
    }, 1);
  } else {
    dorun();
  }
}
module['run'] = module.run = run;

function exit(status, implicit) {
  if (implicit && module['noexitruntime']) {
    return;
  }

  if (module['noexitruntime']) {
  } else {

    abort = true;
    exitstatus = status;
    stacktop = initialstacktop;

    exitruntime();

    if (module['onexit']) module['onexit'](status);
  }

  if (environment_is_node) {
    process['exit'](status);
  } else if (environment_is_shell && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new exitstatus(status);
}
module['exit'] = module.exit = exit;

var abortdecorators = [];

function abort(what) {
  if (what !== undefined) {
    module.print(what);
    module.printerr(what);
    what = json.stringify(what)
  } else {
    what = '';
  }

  abort = true;
  exitstatus = 1;

  var extra = '\nif this abort() is unexpected, build with -s assertions=1 which can give more information.';

  var output = 'abort(' + what + ') at ' + stacktrace() + extra;
  if (abortdecorators) {
    abortdecorators.foreach(function(decorator) {
      output = decorator(output, what);
    });
  }
  throw output;
}
module['abort'] = module.abort = abort;

// {{pre_run_additions}}

if (module['preinit']) {
  if (typeof module['preinit'] == 'function') module['preinit'] = [module['preinit']];
  while (module['preinit'].length > 0) {
    module['preinit'].pop()();
  }
}

// shouldrunnow refers to calling main(), not run().
var shouldrunnow = true;
if (module['noinitialrun']) {
  shouldrunnow = false;
}

module["noexitruntime"] = true;

run();

// {{post_run_additions}}





// {{module_additions}}




});